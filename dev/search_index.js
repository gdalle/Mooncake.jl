var documenterSearchIndex = {"docs":
[{"location":"developer_documentation/tangents/#Tangents","page":"Tangents","title":"Tangents","text":"","category":"section"},{"location":"developer_documentation/tangents/","page":"Tangents","title":"Tangents","text":"As discussed in Representing Gradients, Mooncake requires that each \"primal\" type be associated to a unique \"tangent\" type, given by the function tangent_type. Moreover, we must be able to \"split\" a given tangent into its fdata (\"forwards-data\") and rdata (\"reverse-data\"), whose types are given by Mooncake.fdata_type and Mooncake.rdata_type respectively. Furthermore, we (at the very least) require methods of rrule!! for a few core functions in order to be able to differentiate through construction and the getting / setting of fields.","category":"page"},{"location":"developer_documentation/tangents/","page":"Tangents","title":"Tangents","text":"Very occassionally it may be necessary to specify your own tangent type. This is not an entirely trivial undertaking, as there is quite a lot of functionality that must be added to make it work properly. So, before diving in to add your own custom type, seriously consider whether it is worth the effort, and whether the default definition given by Mooncake are really inadequate for your use-case.","category":"page"},{"location":"developer_documentation/tangents/#Testing-Functionality","page":"Tangents","title":"Testing Functionality","text":"","category":"section"},{"location":"developer_documentation/tangents/","page":"Tangents","title":"Tangents","text":"The interface is given in the form of three functions, each of which specifiy which functions you must implement methods for when creating a custom tangent type:","category":"page"},{"location":"developer_documentation/tangents/#Mooncake.TestUtils.test_tangent_interface","page":"Tangents","title":"Mooncake.TestUtils.test_tangent_interface","text":"test_tangent_interface(rng::AbstractRNG, p; interface_only=false)\n\nVerify that standard functionality for tangents runs, and is consistent. This function is the defacto formal definition of the \"tangent interface\" – if this function runs without error for a given value of p, then that p satisfies the tangent interface.\n\nExtended Help\n\nVerifies that the following functions are implemented correctly (as far as possible) for p / its type, and its tangents / their type:\n\nMooncake.tangent_type\nMooncake.zero_tangent_internal\nMooncake.randn_tangent_internal\nMooncake.TestUtils.has_equal_data\nMooncake.increment_internal!!\nMooncake.set_to_zero_internal!!\nMooncake._add_to_primal_internal\nMooncake._diff_internal\nMooncake._dot_internal\nMooncake._scale_internal\nMooncake.TestUtils.populate_address_map_internal\n\nIn conjunction with the functions tested by test_tangent_splitting, these functions constitute a complete set of functions which must be applicable to p in order to ensure that it operates correctly in the context of reverse-mode AD. This list should be up to date at any given point in time, but the best way to verify that you've implemented everything is simply to run this function, and see whether it errors / produces a failing test.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/tangents/#Mooncake.TestUtils.test_tangent_splitting","page":"Tangents","title":"Mooncake.TestUtils.test_tangent_splitting","text":"test_tangent_splitting(rng::AbstractRNG, p::P) where {P}\n\nVerify that tangent splitting functionality associated to primal p works correctly. Ensure that test_tangent_interface runs for p before running these tests.\n\nExtended Help\n\nVerifies that the following functionality work correctly for p / its type / tangents:\n\nMooncake.fdata_type\nMooncake.rdata_type\nMooncake.fdata\nMooncake.rdata\nMooncake.uninit_fdata\nMooncake.tangent_type (binary method)\nMooncake.tangent (binary method)\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/tangents/#Mooncake.TestUtils.test_rule_and_type_interactions","page":"Tangents","title":"Mooncake.TestUtils.test_rule_and_type_interactions","text":"test_rule_and_type_interactions(rng::AbstractRNG, p)\n\nCheck that a collection of standard functions for which we ought to have a working rrule for p work, and produce the correct answer. For example, the rrule!! for typeof should work correctly on any type, we should have a working rule for getfield for any struct-type, and we should have a rule for setfield! for any mutable struct type. See extended help for more info.\n\nExtended Help\n\nThe purpose of this test is to ensure that, for any given p, the full range of primitive functions that ought to work on it, do indeed work on it.\n\nThis is one part of the interface where some care might be required. If, for some reason, it should never be the case that e.g. for a particular p, getfield should be called, then it may make no sense at all to run these tests. In such cases, the author of the type is responsible for knowing what they are doing. Please open an issue to discuss for your type if you are at all unsure what to do.\n\nWhen defining a custom tangent type for P, the functions that you will need to pay attention to writing rules for are\n\nMooncake._new_\nMooncake.lgetfield\nMooncake.lsetfield!\n\nIn all cases, you may wish to consult the current implementations of rrule!! for these functions for inspiration regarding how you might implement them for your type.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/tangents/","page":"Tangents","title":"Tangents","text":"You can call all three of these functions at once using","category":"page"},{"location":"developer_documentation/tangents/#Mooncake.TestUtils.test_data","page":"Tangents","title":"Mooncake.TestUtils.test_data","text":"test_data(rng::AbstractRNG, p::P)\n\nVerify that all tangent / fdata / rdata functionality work properly for p. Furthermore, verify that all primitives listed in TestUtils.test_rule_and_type_interactions work correctly on p. This functionality is particularly useful if you are writing your own custom tangent / fdata / rdata types and want to be confident that you have implemented the functionality that you need in order to make these custom types work with all the rules written in Mooncake itself.\n\nYou should consult the docstrings for test_tangent_interface, test_tangent_splitting, and test_rule_and_type_interactions, in order to see what is required to satisfy the full tangent interface for p.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/tangents/","page":"Tangents","title":"Tangents","text":"If all the tests in these functions pass, then you have satisfied the interface.","category":"page"},{"location":"known_limitations/#Known-Limitations","page":"Known Limitations","title":"Known Limitations","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Mooncake.jl has a number of known qualitative limitations, which we document here.","category":"page"},{"location":"known_limitations/#Coverage-of-Julia-Syntax-and-Standard-Library","page":"Known Limitations","title":"Coverage of Julia Syntax and Standard Library","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"While Mooncake.jl should now work on a very large subset of the language, there remain things that you should expect not to work. A non-exhaustive list of things to bear in mind includes:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"It is always necessary to produce hand-written rules for ccalls (and, more generally, foreigncall nodes). We have rules for many ccalls, but not all. If you encounter a foreigncall without a hand-written rule, you should get an informative error message which tells you what is going on and how to deal with it.\nBuiltins which require rules. The vast majority of them have rules now, but some don't. You should get a sensible error if you encounter a primitive without a rule.\nAnything involving tasks / threading – we have no thread safety guarantees and, at the time of writing, I'm not entirely sure what error you will find if you attempt to AD through code which uses Julia's task / thread system. The same applies to distributed computing. These limitations ought to be possible to resolve.","category":"page"},{"location":"known_limitations/#Mutation-of-Global-Variables","page":"Known Limitations","title":"Mutation of Global Variables","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"While great care is taken in this package to prevent silent errors, this is one edge case that we have yet to provide a satisfactory solution for. Consider a function of the form:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"julia> const x = Ref(1.0);\n\njulia> function foo(y::Float64)\n           x[] = y\n           return x[]\n       end\nfoo (generic function with 1 method)","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"x is a global variable (if you refer to it in your code, it appears as a GlobalRef in the AST or lowered code). For some technical reasons that are beyond the scope of this section, this package cannot propagate gradient information through x. foo is the identity function, so it should have gradient 1.0. However, if you differentiate this example, you'll see:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"julia> rule = Mooncake.build_rrule(foo, 2.0);\n\njulia> Mooncake.value_and_gradient!!(rule, foo, 2.0)\n(2.0, (NoTangent(), 0.0))","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Observe that while it has correctly computed the identity function, the gradient is zero.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The takehome: do not attempt to differentiate functions which modify global state. Uses of globals which does not involve mutating them is fine though.","category":"page"},{"location":"known_limitations/#Circular-References","page":"Known Limitations","title":"Circular References","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"To a large extent, Mooncake.jl does not presently support circular references in an automatic fashion. It is generally possible to hand-write solutions, so we explain some of the problems here, and the general approach to resolving them.","category":"page"},{"location":"known_limitations/#Tangent-Types","page":"Known Limitations","title":"Tangent Types","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Problem","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Suppose that you have a type such as:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"mutable struct A\n    x::Float64\n    a::A\n    function A(x::Float64)\n        a = new(x)\n        a.a = a\n        return a\n    end\nend","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"This is a fairly canonical example of a self-referential type. There are a couple of things which will not work with it out-of-the-box. tangent_type(A) will produce a stack overflow error. To see this, note that it will in effect try to produce a tangent of type Tangent{Tuple{tangent_type(A)}} – the circular dependency on the tangent_type function causes real problems here.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Solution","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"In order to resolve this, you need to produce a tangent type by hand. You might go with something like","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"mutable struct TangentForA\n    x::Float64 # tangent type for Float64 is Float64\n    a::TangentForA\n    function TangentForA(x::Float64)\n        a = new(x)\n        a.a = a\n        return a\n    end\nend","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The point here is that you can manually resolve the circular dependency using a data structure which mimics the primal type. You will, however, need to implement similar methods for zero_tangent, randn_tangent, etc, and presumably need to implement additional getfield and setfield rules which are specific to this type. An example implementation of this is provided here.","category":"page"},{"location":"known_limitations/#Circular-References-in-General","page":"Known Limitations","title":"Circular References in General","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Problem","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Consider a type of the form","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"mutable struct Foo\n    x\n    Foo() = new()\nend","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"In this instance, tangent_type will work fine because Foo does not directly reference itself in its definition. Moreover, general uses of Foo will be fine.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"However, it's possible to construct an instance of Foo with a circular reference:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"f = Foo()\nf.x = f","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"This is actually fine provided we never attempt to call zero_tangent / randn_tangent / similar functionality on f once we've set its x field to itself. If we attempt to call such a function, we'll find ourselves with a stack overflow.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Solution This is a little tricker to handle. You could specialise zero_tangent etc for Foo, but this is something of a pain. Fortunately, it seems to be incredibly rare that this is ever a problem in practice. If we gain evidence that this is often a problem in practice, we'll look into supporting zero_tangent etc automatically for this case.","category":"page"},{"location":"known_limitations/#Tangent-Generation-and-Pointers","page":"Known Limitations","title":"Tangent Generation and Pointers","text":"","category":"section"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Problem","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"In many use cases, a pointer provides the address of the start of a block of memory which has been allocated to e.g. store an array. However, we cannot get any of this context from the pointer itself – by just looking at a pointer, I cannot know whether its purpose is to refer to the start of a large block of memory, some proportion of the way through a block of memory, or even to keep track of a single address.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Recall that the tangent to a pointer is another pointer:","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"julia> Mooncake.tangent_type(Ptr{Float64})\nPtr{Float64}","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Plainly I cannot implement a method of zero_tangent for Ptr{Float64} because I don't know how much memory to allocate.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"This is, however, fine if a pointer appears half way through a function, having been derived from another data structure. e.g.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"function foo(x::Vector{Float64})\n    p = pointer(x, 2)\n    return unsafe_load(p)\nend\n\nrule = build_rrule(Tuple{typeof(foo), Vector{Float64}})\nMooncake.value_and_gradient!!(rule, foo, [5.0, 4.0])\n\n# output\n(4.0, (NoTangent(), [0.0, 1.0]))","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"The Solution","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"This is only really a problem for tangent / fdata / rdata generation functionality, such as zero_tangent. As a work-around, AD testing functionality permits users to pass in CoDuals. So if you are testing something involving a pointer, you will need to construct its tangent yourself, and pass a CoDual to e.g. Mooncake.TestUtils.test_rule.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"While pointers tend to be a low-level implementation detail in Julia code, you could in principle actually be interested in differentiating a function of a pointer. In this case, you will not be able to use Mooncake.value_and_gradient!! as this requires the use of zero_tangent. Instead, you will need to use lower-level (internal) functionality, such as Mooncake.__value_and_gradient!!, or use the rule interface directly.","category":"page"},{"location":"known_limitations/","page":"Known Limitations","title":"Known Limitations","text":"Honestly, your best bet is just to avoid differentiating functions whose arguments are pointers if you can.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Misc.-Internals-Notes","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"This document contains an assortment of notes on some implementation details in Mooncake.jl. It is occassionally helpful to have them here for reference, but they are typically not essential reading unless working on the specific parts of Mooncake.jl to which they pertain.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#tangent_type-and-friends","page":"Misc. Internals Notes","title":"tangent_type and friends","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Last checked: 21/01/2025, Julia v1.10.7 / v1.11.2, Mooncake 0.4.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Background","page":"Misc. Internals Notes","title":"Background","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Mooncake.jl makes extensive use of @generated functions to ensure that its tangent_type function (among others) is both type-stable, and constant folds. I recently changed how tangent_type is implemented in Mooncake.jl to ensure that the implementations respect some specific limitations of generated functions. Here I outline the overall problem, the mistake the previous implementation made, and how the recent changes fix it.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#tangent_type","page":"Misc. Internals Notes","title":"tangent_type","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"tangent_type is a regular Julia function, which given a \"primal\" type returns another type, the tangent type. It is side-effect free, and its return value is determined entirely by the type of its argument. This means it should be possible to constant-fold. For example, consider the following definitions:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"tangent_type(::Type{Float64}) = Float64\ntangent_type(::Type{P}) where {P<:Tuple} = Tuple{map(tangent_type, fieldtypes(P))...}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"If we inspect the IRCode associated to this for Float64, we see that everything is as expected – the function literally just returns Float64:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> Base.code_ircode(tangent_type, (Type{Float64}, ))[1]\n 1 ─     return Main.Float64\n  => Type{Float64}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"A simple Tuple type will also have this property:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> Base.code_ircode(tangent_type, (Type{Tuple{Float64}}, ))[1]\n 1 ─     return Tuple{Float64}\n  => Type{Tuple{Float64}}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"However, for even slightly more complicated types, things fall over:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> Base.code_ircode(tangent_type, (Type{Tuple{Tuple{Float64}}}, ))[1]\n1 1 ─ %1 = Main.tangent_type::Core.Const(tangent_type)\n  │   %2 = invoke %1(Tuple{Float64}::Type{Tuple{Float64}})::Type{<:Tuple}\n  │   %3 = Core.apply_type(Tuple, %2)::Type{<:Tuple}\n  └──      return %3\n   => Type{<:Tuple}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"This is just one specific example, but it is really very straightforward to find others, necessitating a hunt for a more robust way of implementing tangent_type.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Bad-Generated-Function-Implementation","page":"Misc. Internals Notes","title":"Bad Generated Function Implementation","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"You might think to instead implement tangent_type for Tuples as follows:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"bad_tangent_type(::Type{Float64}) = Float64\n@generated function bad_tangent_type(::Type{P}) where {P<:Tuple}\n    return Tuple{map(bad_tangent_type, fieldtypes(P))...}\nend\nbad_tangent_type(::Type{Float32}) = Float32","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Since the generated function literally just returns the type that we want, it will definitely constant-fold:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> Base.code_ircode(bad_tangent_type, (Type{Tuple{Tuple{Float64}}}, ))[1]\n1 1 ─     return Tuple{Tuple{Float64}}\n   => Type{Tuple{Tuple{Float64}}}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"However, this implementation has a crucial flaw: we rely on the definition of bad_tangent_type in the body of the @generated method of bad_tangent_type. This means that if we e.g. add methods to bad_tangent_type after the initial definition, they won't show up. For example, in the above block, we defined the method of bad_tangent_type for Float32 after that of Tuples. This results in the following error when we call bad_tangent_type(Tuple{Float32}):","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> bad_tangent_type(Tuple{Float32})\nERROR: MethodError: no method matching bad_tangent_type(::Type{Float32})\nThe applicable method may be too new: running in world age 26713, while current world is 26714.\n\nClosest candidates are:\n  bad_tangent_type(::Type{Float32}) (method too new to be called from this world context.)\n   @ Main REPL[10]:1\n  bad_tangent_type(::Type{Float64})\n   @ Main REPL[8]:1\n  bad_tangent_type(::Type{P}) where P<:Tuple\n   @ Main REPL[9]:1\n\nStacktrace:\n [1] map(f::typeof(bad_tangent_type), t::Tuple{DataType})\n   @ Base ./tuple.jl:355\n [2] #s1#1\n   @ ./REPL[9]:2 [inlined]\n [3] var\"#s1#1\"(P::Any, ::Any, ::Any)\n   @ Main ./none:0\n [4] (::Core.GeneratedFunctionStub)(::UInt64, ::LineNumberNode, ::Any, ::Vararg{Any})\n   @ Core ./boot.jl:707\n [5] top-level scope\n   @ REPL[12]:1","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"This behaviour of @generated functions is discussed in the Julia docs – I would recommend reading this bit of the docs if you've not previously, as the explanation is quite clear.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Good-Generated-Function-Implementation","page":"Misc. Internals Notes","title":"Good Generated Function Implementation","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"@generated functions can still come to our rescue though. A better implementation is as follows:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"good_tangent_type(::Type{Float64}) = Float64\n@generated function good_tangent_type(::Type{P}) where {P<:Tuple}\n    exprs = map(p -> :(good_tangent_type($p)), fieldtypes(P))\n    return Expr(:curly, :Tuple, exprs...)\nend\ngood_tangent_type(::Type{Float32}) = Float32","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"This leads to generated code which constant-folds / infers correctly:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> Base.code_ircode(good_tangent_type, (Type{Tuple{Tuple{Float64}}}, ))[1]\n1 1 ─     return Tuple{Tuple{Float64}}\n   => Type{Tuple{Tuple{Float64}}}","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"I believe this works better because the recursion doesn't happen through another function, but appears directly in the function body. This is right at the edge of my understanding of Julia's compiler heuristics surrounding recursion though, so I might be mistaken.","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"It also behaves correctly under the addition of new methods of good_tangent_type, because good_tangent_type only appears in the expression returned by the generated function, not the body of the generated function itself:","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"julia> good_tangent_type(Tuple{Float32})\nTuple{Float32}","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Effects-Etc","page":"Misc. Internals Notes","title":"Effects Etc","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"This implementation is nearly sufficient to guarantee correct performance in all situations. However, in some cases it is possible that even this implementation will fall over. Annoyingly I've not managed to produce a MWE that is even vaguely minimal in order to support this example, so you'll just have to believe me.","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Based on all of the examples that I have seen thus far, it appears to be true that if you just tell the compiler that","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"for the same inputs, the function always returns the same outputs, and\nthe function has no side-effects, so can be removed,","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"everything will always constant fold nicely. This can be achieved by using the Base.@assume_effects macro in your method definitions, with the effects :consistent and :removable.","category":"page"},{"location":"developer_documentation/misc_internals_notes/#How-Recursion-Is-Handled","page":"Misc. Internals Notes","title":"How Recursion Is Handled","text":"","category":"section"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Last checked: 09/02/2025, Julia v1.10.8 / v1.11.3, Mooncake 0.4.82.","category":"page"},{"location":"developer_documentation/misc_internals_notes/","page":"Misc. Internals Notes","title":"Misc. Internals Notes","text":"Mooncake handles recursive function calls by delaying code generation for generic function calls until the first time that they are actually run. The docstring below contains a thorough explanation:","category":"page"},{"location":"developer_documentation/misc_internals_notes/#Mooncake.LazyDerivedRule-developer_documentation-misc_internals_notes","page":"Misc. Internals Notes","title":"Mooncake.LazyDerivedRule","text":"LazyDerivedRule(interp, mi::Core.MethodInstance, debug_mode::Bool)\n\nFor internal use only.\n\nA type-stable wrapper around a DerivedRule, which only instantiates the DerivedRule when it is first called. This is useful, as it means that if a rule does not get run, it does not have to be derived.\n\nIf debug_mode is true, then the rule constructed will be a DebugRRule. This is useful when debugging, but should usually be switched off for production code as it (in general) incurs some runtime overhead.\n\nNote: the signature of the primal for which this is a rule is stored in the type. The only reason to keep this around is for debugging – it is very helpful to have this type visible in the stack trace when something goes wrong, as it allows you to trivially determine which bit of your code is the culprit.\n\nExtended Help\n\nThere are two main reasons why deferring the construction of a DerivedRule until we need to use it is crucial.\n\nThe first is to do with recursion. Consider the following function:\n\nf(x) = x > 0 ? f(x - 1) : x\n\nIf we generate the IRCode for this function, we will see something like the following:\n\njulia> Base.code_ircode_by_type(Tuple{typeof(f), Float64})[1][1]\n1 1 ─ %1  = Base.lt_float(0.0, _2)::Bool\n  │   %2  = Base.or_int(%1, false)::Bool\n  └──       goto #6 if not %2\n  2 ─ %4  = Base.sub_float(_2, 1.0)::Float64\n  │   %5  = Base.lt_float(0.0, %4)::Bool\n  │   %6  = Base.or_int(%5, false)::Bool\n  └──       goto #4 if not %6\n  3 ─ %8  = Base.sub_float(%4, 1.0)::Float64\n  │   %9  = invoke Main.f(%8::Float64)::Float64\n  └──       goto #5\n  4 ─       goto #5\n  5 ┄ %12 = φ (#3 => %9, #4 => %4)::Float64\n  └──       return %12\n  6 ─       return _2\n\nSuppose that we decide to construct a DerivedRule immediately whenever we find an :invoke statement in a rule that we're currently building a DerivedRule for. In the above example, we produce an infinite recursion when we attempt to produce a DerivedRule for %9, because it has the same signature as the call which generates this IR. By instead adopting a policy of constructing a LazyDerivedRule whenever we encounter an :invoke statement, we avoid this problem.\n\nThe second reason that delaying the construction of a DerivedRule, is essential is that it ensures that we don't derive rules for method instances which aren't run. Suppose that function B contains code for which we can't derive a rule – perhaps it contains an unsupported language feature like a PhiCNode or an UpsilonNode. Suppose that function A contains an :invoke which refers to function B, but that this call is on a branch which deals with error handling, and doesn't get run run unless something goes wrong. By deferring the derivation of the rule for B, we only ever attempt to derive it if we land on this error handling branch. Conversely, if we attempted to derive the rule for B when we derive the rule for A, we would be unable to complete the derivation of the rule for A.\n\n\n\n\n\n","category":"type"},{"location":"understanding_mooncake/algorithmic_differentiation/#Algorithmic-Differentiation","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"This section introduces the mathematics behind AD. Even if you have worked with AD before, we recommend reading in order to acclimatise yourself to the perspective that Mooncake.jl takes on the subject.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Derivatives","page":"Algorithmic Differentiation","title":"Derivatives","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The foundation of automatic differentiation is the directional derivative. Here we build up to a general definition.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Scalar-to-Scalar Functions","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Consider first f  RR to RR, which we require to be differentiable at x in RR. Its derivative at x is usually thought of as the scalar alpha in RR such that","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"textdf = alpha  textdx ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Loosely speaking, by this notation we mean f(x + textd x) approx f(x) + textd f, or in other words, that an arbitrarily small change textd x to the input x results in a change textd f = alpha  textdx in the output. We refer readers to the first few minutes of the first lecture mentioned before for a more careful explanation.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Vector-to-Vector Functions","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The generalisation of this to Euclidean space should be familiar: if f  RR^P to RR^Q is differentiable at a point x in RR^P, then the derivative of f at x is given by the Jacobian matrix at x, denoted Jx in RR^Q times P, such that","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"textdf = Jx  textdx ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"It is possible to stop here, as all the functions we shall need to consider can in principle be written as functions on some subset RR^P.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"However, to differentiate computer programmes, we must deal with complicated nested data structures, e.g. structs inside Tuples inside Vectors etc. While all of these data structures can be mapped onto a flat vector in order to make sense of the Jacobian, this quickly becomes very inconvenient. To see the problem, consider the Julia function whose input is of type Tuple{Tuple{Float64, Vector{Float64}}, Vector{Float64}, Float64} and whose output is of type Tuple{Vector{Float64}, Float64}. What kind of object might be use to represent the derivative of a function mapping between these two spaces? We certainly can treat these as structured \"view\" into a \"flat\" Vector{Float64}s, and then define a Jacobian, but actually finding this mapping is a tedious exercise, even if it quite obviously exists.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In fact, a more general formulation of the derivative is used all the time in the context of AD – the matrix calculus discussed by [1] and [2] (to name a couple) make use of a generalised form of the derivative in order to work with functions which map to and from matrices (albeit there are slight differences in naming conventions from text to text), without needing to \"flatten\" them into vectors in order to make sense of them.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In general, it will be much easier to avoid \"flattening\" operations wherever possible. In order to do so, we now introduce a generalised notion of the derivative.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Functions Between More General Spaces","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In order to avoid the difficulties described above, we consider functions f  mathcalX to mathcalY, where mathcalX and mathcalY are finite dimensional real Hilbert spaces (read: finite-dimensional vector space with an inner product, and real-valued scalars). This definition includes functions to and from RR, RR^D, real-valued matrices, and any other \"container\" for collections of real numbers. Furthermore, we shall see later how we can model all sorts of structured representations of data directly as such spaces.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"For such spaces, the derivative of f at x in mathcalX is the linear operator (read: linear function) D f x  mathcalX to mathcalY satisfying","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"textdf = D f x  (textd x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The purpose of this linear operator is to provide a linear approximation to f which is accurate for arguments which are very close to x.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Please note that D f x is a single mathematical object, despite being three separate symbols: D f x (dotx) denotes the application of the function D f x to argument dotx. Furthermore, the dot-notation (dotx) does not have anything to do with time-derivatives, it is simply common notation used in the AD literature to denote the arguments of derivatives.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"So, instead of thinking of the derivative as a number or a matrix, we think about it as a function. We can express the previous notions of the derivative in this language.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In the scalar case, rather than thinking of the derivative as being alpha, we think of it is a the linear operator D f x (dotx) = alpha dotx. Put differently, rather than thinking of the derivative as the slope of the tangent to f at x, think of it as the function decribing the tangent itself. Observe that up until now we had only considered inputs to D f x which were small (textd x) – here we extend it to the entire space mathcalX and denote inputs in this space dotx. Inputs dotx should be thoughts of as \"directions\", in the directional derivative sense (why this is true will be discussed later).","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Similarly, if mathcalX = RR^P and mathcalY = RR^Q then this operator can be specified in terms of the Jacobian matrix: D f x (dotx) = Jx dotx – brackets are used to emphasise that D f x is a function, and is being applied to dotx.[note_for_geometers]","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"To reiterate, for the rest of this document, we define the derivative to be \"multiply by alpha\" or \"multiply by Jx\", rather than to be alpha or Jx. So whenever you see the word \"derivative\", you should think \"linear function\".","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The Chain Rule","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The chain rule is the result which makes AD work. Fortunately, it applies to this version of the derivative:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f = g circ h implies D f x = (D g h(x)) circ (D h x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"By induction, this extends to a collection of N functions f_1 dots f_N:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f = f_N circ dots circ f_1 implies D f x = (D f_N x_N) circ dots circ (D f_1 x_1)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"where x_n+1 = f(x_n), and x_1 = x.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"An aside: the definition of the Frechet Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"This definition of the derivative has a name: the Frechet derivative. It is a generalisation of the Total Derivative. Formally, we say that a function f  mathcalX to mathcalY is differentiable at a point x in mathcalX if there exists a linear operator D f x  mathcalX to mathcalY (the derivative) satisfying","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"lim_textd h to 0 frac f(x + textd h) - f(x) + D f x (textd h)  _mathcalY textdh _mathcalX = 0","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"where  cdot _mathcalX and  cdot _mathcalY are the norms associated to Hilbert spaces mathcalX and mathcalY respectively. (The Frechet derivative does not depend on the choice of norms. All norms are equivalent in finite dimensions, meaning they define the same topology and notion of convergence: if this equation is satisfied for one norm, it holds for all.)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"It is a good idea to consider what this looks like when mathcalX = mathcalY = RR and when mathcalX = mathcalY = RR^D. It is sometimes helpful to refer to this definition to e.g. verify the correctness of the derivative of a function – as with single-variable calculus, however, this is rare.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Another aside: what does Forwards-Mode AD compute?","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"At this point we have enough machinery to discuss forwards-mode AD. Expressed in the language of linear operators and Hilbert spaces, the goal of forwards-mode AD is the following: given a function f which is differentiable at a point x, compute D f x (dotx) for a given vector dotx. If f  RR^P to RR^Q, this is equivalent to computing Jx dotx, where Jx is the Jacobian of f at x. For the interested reader we provide a high-level explanation of how forwards-mode AD does this in How does Forwards-Mode AD work?.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Another aside: notation","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"You may have noticed that we typically denote the argument to a derivative with a \"dot\" over it, e.g. dotx. This is something that we will do consistently, and we will use the same notation for the outputs of derivatives. Wherever you see a symbol with a \"dot\" over it, expect it to be an input or output of a derivative / forwards-mode AD.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Reverse-Mode-AD:-*what*-does-it-do?","page":"Algorithmic Differentiation","title":"Reverse-Mode AD: what does it do?","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In order to explain what reverse-mode AD does, we first consider the \"vector-Jacobian product\" definition in Euclidean space which will be familiar to many readers. We then generalise.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Reverse-Mode AD: what does it do in Euclidean space?","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In this setting, the goal of reverse-mode AD is the following: given a function f  RR^P to RR^Q which is differentiable at x in RR^P with Jacobian Jx at x, compute Jx^top bary for any bary in RR^Q. This is useful because we can obtain the gradient from this when Q = 1 by letting bary = 1.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Adjoint Operators","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In order to generalise this algorithm to work with linear operators, we must first generalise the idea of multiplying a vector by the transpose of the Jacobian. The relevant concept here is the adjoint of a linear operator. Specifically, the adjoint A^ast of linear operator A is the linear operator satisfying","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"langle A^ast bary dotx rangle = langle bary A dotx rangle","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"for any dotx bary, where langle cdot cdot rangle denotes the inner-product. The relationship between the adjoint and matrix transpose is: if A (x) = J x for some matrix J, then A^ast (y) = J^top y.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Moreover, just as (A B)^top = B^top A^top when A and B are matrices, (A B)^ast = B^ast A^ast when A and B are linear operators. This result follows in short order from the definition of the adjoint operator – (and is a good exercise!)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Reverse-Mode AD: what does it do in general?","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Equipped with adjoints, we can express reverse-mode AD only in terms of linear operators, dispensing with the need to express everything in terms of Jacobians. The goal of reverse-mode AD is as follows: given a differentiable function f  mathcalX to mathcalY, compute D f x^ast (bary) for some bary.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Notation: D f x^ast denotes the single mathematical object which is the adjoint of D f x. It is a linear function from mathcalY to mathcalX. We may occassionally write it as (D f x)^ast if there is some risk of confusion.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"We will explain how reverse-mode AD goes about computing this after some worked examples.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Aside: Notation","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"You will have noticed that arguments to adjoints have thus far always had a \"bar\" over them, e.g. bary. This notation is common in the AD literature and will be used throughout. Additionally, this \"bar\" notation will be used for the outputs of adjoints of derivatives. So wherever you see a symbol with a \"bar\" over it, think \"input or output of adjoint of derivative\".","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Some-Worked-Examples","page":"Algorithmic Differentiation","title":"Some Worked Examples","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"We now present some worked examples in order to prime intuition, and to introduce the important classes of problems that will be encountered when doing AD in the Julia language. We will put all of these problems in a single general framework later on.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#An-Example-with-Matrix-Calculus","page":"Algorithmic Differentiation","title":"An Example with Matrix Calculus","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"We have introduced some mathematical abstraction in order to simplify the calculations involved in AD. To this end, we consider differentiating f(X) = X^top X. Results for this and similar operations are given by [1]. A similar operation, but which maps from matrices to RR is discussed in Lecture 4 part 2 of the MIT course mentioned previouly. Both [1] and Lecture 4 part 2 provide approaches to obtaining the derivative of this function.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Following either resource will yield the derivative:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f X (dotX) = dotX^top X + X^top dotX","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Observe that this is indeed a linear operator (i.e. it is linear in its argument, dotX). (You can always plug it in to the definition of the Frechet derivative to confirm that it is indeed the derivative.)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In order to perform reverse-mode AD, we need to find the adjoint operator. Using the usual definition of the inner product between matrices,","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"langle X Y rangle = textrmtr (X^top Y)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"we can rearrange the inner product as follows:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign*\nlanglebarYDfX(dotX)rangle  =langlebarYdotX^topX+X^topdotXrangle\n  =textrmtr(barY^topleft(dotX^topX+X^topdotXright))\n  =textrmtr(dotX^topXbarY^top)+textrmtr(barY^topX^topdotX)\n  =langledotXXbarY^toprangle+langle XbarYdotXrangle\n  =langle XbarY^top+XbarYdotXrangle\nendalign*","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The linearity of inner products and trace, and the cyclic property of trace was used in the above. We can read off the adjoint operator from the first argument to the inner product:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign*\nDfleftXright^*left(barYright)  =XbarY^top+XbarY\n  =Xleft(barY^top+barYright)\nendalign*","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#AD-of-a-Julia-function:-a-trivial-example","page":"Algorithmic Differentiation","title":"AD of a Julia function: a trivial example","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"We now turn to differentiating Julia functions (we use function to refer to the programming language construct, and function to refer to a more general mathematical concept). The way that Mooncake.jl handles immutable data is very similar to how Zygote / ChainRules do. For example, consider the Julia function","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f(x::Float64) = sin(x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"If you've previously worked with ChainRules / Zygote, without thinking too hard about the formalisms we introduced previously (perhaps by considering a variety of partial derivatives) you can probably arrive at the following adjoint for the derivative of f:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"g -> g * cos(x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Implicitly, you have performed three steps:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"model f as a differentiable function,\ncompute its derivative, and\ncompute the adjoint of the derivative.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"It is helpful to work through this simple example in detail, as the steps involved apply more generally. The goal is to spell out the steps involved in detail, as this detail becomes helpful in more complicated examples. If at any point this exercise feels pedantic, we ask you to stick with it.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 1: Differentiable Mathematical Model","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Obviously, we model the Julia function f as the function f  RR to RR where","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f(x) = sin(x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Observe that, we've made (at least) two modelling assumptions here:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"a Float64 is modelled as a real number,\nthe Julia function sin is modelled as the usual mathematical function sin.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"As promised we're being quite pedantic. While the first assumption is obvious and will remain true, we will shortly see examples where we have to work a bit harder to obtain a correspondence between a Julia function and a mathematical object.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 2: Compute Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Now that we have a mathematical model, we can differentiate it:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x (dotx) = cos(x) dotx","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 3: Compute Adjoint of Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Given the derivative, we can find its adjoint:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"langle barf D f x(dotx) rangle = langle barf cos(x) dotx rangle = langle cos(x) barf dotx rangle","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"From here the adjoint can be read off from the first argument to the inner product:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x^ast (barf) = cos(x) barf","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#AD-of-a-Julia-function:-a-slightly-less-trivial-example","page":"Algorithmic Differentiation","title":"AD of a Julia function: a slightly less trivial example","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Now consider the Julia function","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f(x::Float64, y::Tuple{Float64, Float64}) = x + y[1] * y[2]","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Its adjoint is going to be something along the lines of","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"g -> (g, (y[2] * g, y[1] * g))","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"As before, we work through in detail.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 1: Differentiable Mathematical Model","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"There are a couple of aspects of f which require thought:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"it has two arguments – we've only handled single argument functions previously, and\nthe second argument is a Tuple – we've not yet decided how to model this.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"To this end, we define a mathematical notion of a tuple. A tuple is a collection of N elements, each of which is drawn from some set mathcalX_n. We denote by mathcalX =  mathcalX_1 times dots times mathcalX_N  the set of all N-tuples whose nth element is drawn from mathcalX_n. Provided that each mathcalX_n forms a finite Hilbert space, mathcalX forms a Hilbert space with","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"alpha x = (alpha x_1 dots alpha x_N),\nx + y = (x_1 + y_1 dots x_N + y_N), and\nlangle x y rangle = sum_n=1^N langle x_n y_n rangle.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"We can think of multi-argument functions as single-argument functions of a tuple, so a reasonable mathematical model for f might be a function f   RR times  RR times RR   to RR, where","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f(x y) = x + y_1 y_2","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Note that while the function is written with two arguments, you should treat them as a single tuple, where we've assigned the name x to the first element, and y to the second.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 2: Compute Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Now that we have a mathematical object, we can differentiate it:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x y(dotx doty) = dotx + doty_1 y_2 + y_1 doty_2","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 3: Compute Adjoint of Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D fx y maps  RR times  RR times RR  to RR, so D f x y^ast must map the other way. You should verify that the following follows quickly from the definition of the adjoint:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x y^ast (barf) =  (barf (barf y_2 barf y_1))","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#AD-with-mutable-data","page":"Algorithmic Differentiation","title":"AD with mutable data","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In the previous two examples there was an obvious mathematical model for the Julia function. Indeed this model was sufficiently obvious that it required little explanation. This is not always the case though, in particular, Julia functions which modify / mutate their inputs require a little more thought.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Consider the following Julia function:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"function f!(x::Vector{Float64})\n    x .*= x\n    return sum(x)\nend","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"This function squares each element of its input in-place, and returns the sum of the result. So what is an appropriate mathematical model for this function?","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 1: Differentiable Mathematical Model","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The trick is to distinguish between the state of x upon entry to / exit from f!. In particular, let phi_textf  RR^N to  RR^N times RR  be given by","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"phi_textf(x) = (x odot x sum_n=1^N x_n^2)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"where odot denotes the Hadamard / element-wise product (corresponds to line x .*= x in the above code). The point here is that the inputs to phi_textf are the inputs to x upon entry to f!, and the value returned from phi_textf is a tuple containing the both the inputs upon exit from f! and the value returned by f!.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The remaining steps are straightforward now that we have the model.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 2: Compute Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The derivative of phi_textf is","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D phi_textf x(dotx) = (2 x odot dotx 2 sum_n=1^N x_n dotx_n)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Step 3: Compute Adjoint of Derivative","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The argument to the adjoint of the derivative must be a 2-tuple whose elements are drawn from RR^N times RR . Denote such a tuple as (bary_1 bary_2). Plugging this into an inner product with the derivative and rearranging yields","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign\n    langle (bary_1 bary_2) D phi_textf x (dotx) rangle = langle (bary_1 bary_2) (2 x odot dotx 2 sum_n=1^N x_n dotx_n) rangle nonumber \n        = langle bary_1 2 x odot dotx rangle + langle bary_2 2 sum_n=1^N x_n dotx_n rangle nonumber \n        = langle 2x odot bary_1 dotx rangle + langle 2 bary_2 x dotx rangle nonumber \n        = langle 2 (x odot bary_1 + bary_2 x) dotx rangle nonumber\nendalign","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"So we can read off the adjoint to be","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D phi_textf x^ast (bary) = 2 (x odot bary_1 + bary_2 x)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Reverse-Mode-AD:-*how*-does-it-do-it?","page":"Algorithmic Differentiation","title":"Reverse-Mode AD: how does it do it?","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Now that we know what it is that AD computes, we need a rough understanding of how it computes it.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In short: reverse-mode AD breaks down a \"complicated\" function f into the composition of a collection of \"simple\" functions f_1 dots f_N, applies the chain rule, and takes the adjoint.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Specifically, we assume that we can express any function f as f = f_N circ dots circ f_1, and that we can compute the adjoint of the derivative for each f_n. From this, we can obtain the adjoint of f by applying the chain rule to the derivatives and taking the adjoint:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign\nD f x^ast = (D f_N x_N circ dots circ D f_1 x_1)^ast nonumber \n    = D f_1 x_1^ast circ dots circ D f_N x_N^ast nonumber\nendalign","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"For example, suppose that f(x) = sin(cos(texttr(X^top X))). One option to compute its adjoint is to figure it out by hand directly (probably using the chain rule somewhere). Instead, we could notice that f = f_4 circ f_3 circ f_2 circ f_1 where f_4 = sin, f_3 = cos, f_2 = texttr and f_1(X) = X^top X. We could derive the adjoint for each of these functions (a fairly straightforward task), and then compute","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x^ast (bary) = (D f_1 x_1^ast circ D f_2 x_2^ast circ D f_3 x_3^ast circ D f_4 x_4^ast)(1)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"in order to obtain the gradient of f. Reverse-mode AD essentially just does this. Modern systems have hand-written adjoints for (hopefully!) all of the \"simple\" functions you may wish to build a function such as f from (often there are hundreds of these), and composes them to compute the adjoint of f. A sketch of a more generic algorithm is as follows.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Forwards-Pass:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"x_1 = x, n = 1\nconstruct D f_n x_n^ast\nlet x_n+1 = f_n (x_n)\nlet n = n + 1\nif n  N + 1 then go to step 2.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Reverse-Pass:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"let barx_N+1 = bary\nlet n = n - 1\nlet barx_n = D f_n x_n^ast (barx_n+1)\nif n = 1 return barx_1 else go to step 2.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"How does this relate to vector-Jacobian products?","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In Euclidean space, each derivative D f_n x_n(dotx_n) = J_nx_n dotx_n. Applying the chain rule to D f x and substituting this in yields","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Jx = J_Nx_N dots J_1x_1 ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Taking the transpose and multiplying from the left by bary yields","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Jx^top bary = Jx_1^top_1 dots Jx_N^top_N bary ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Comparing this with the expression in terms of adjoints and operators, we see that composition of adjoints of derivatives has been replaced with multiplying by transposed Jacobian matrices. This \"vector-Jacobian product\" expression is commonly used to explain AD, and is likely familiar to many readers.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Directional-Derivatives-and-Gradients","page":"Algorithmic Differentiation","title":"Directional Derivatives and Gradients","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Now we turn to using forwards- and reverse-mode AD to compute the gradient of a function.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Recall that if D fx  mathcalX to mathbbR is the Frechet derivative discussed here then D fx(dotx) is the directional derivative in the dotx direction.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The gradient of f  mathcalX to mathbbR at x is defined to be the vector nabla f (x) in mathcalX such that","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"langle nabla f (x) dotx rangle = D fx(dotx)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"for any direction dotx. In other words, the vector nabla f encodes all the information about the directional derivatives of f, and we use the inner product to retrieve that information.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"An alternative characterisation is that nabla f(x) is the vector pointing in the direction of steepest ascent whose magnitude is given by the slope in that direction. In other words, if hatn coloneqq argmax_u=1 D fx(u) is the unit vector in the direction of steepest ascent, then nabla f = nabla f  hatn and D fx(hatn) = nabla f(x). (That this follows from the implicit definition above is a good exercise.)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Aside: The choice of inner product","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Notice that the value of the gradient depends on how the inner product on mathcalX is defined. Indeed, different choices of inner product result in different values of nabla f. Adjoints such as D fx^* are also inner product dependent. However, the actual derivative D fx is of course invariant – it does not depend on the inner product or norm.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"In practice, Mooncake uses the Euclidean inner product, extended in the \"obvious way\" to other composite data types (that is, as if everything is flattened and embedded in mathbbR^N), but we endeavour to keep the discussion general in order to make the role of the inner product explicit.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Computing-the-gradient-from-forwards-mode","page":"Algorithmic Differentiation","title":"Computing the gradient from forwards-mode","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"To compute the gradient in forwards-mode, we need to evaluate the forwards pass dim mathcalX times. We also need to refer to a basis mathbfe_i of mathcalX and its reciprocal basis[reciprocal_bases] mathbfe^i. Equipped with such a pair of bases, we can always decompose a vector x = sum_i x^i mathbfe_i into its components x^i = langle x mathbfe^i rangle. Hence, the gradient is given by","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"nabla f(x)\n\t= sum_i langle nabla f(x) mathbfe^i rangle mathbfe_i\n\t= sum_i D fx(mathbfe^i)  mathbfe_i","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"where the second equality follows from the gradient's definition.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"[reciprocal_bases]: For any basis mathbfe_i there exists a reciprocal reciprocal basis mathbfe^i such that langle mathbfe_i mathbfe^j rangle = delta_i^j. If the basis is orthonormal with respect to the inner product, then the original basis and its reciprocal are equal and mathbfe_i = mathbfe^i. We will always implicitly use orthonormal bases in Mooncake, so the position of indices can usually be ignored safely.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"If the inner product is Euclidean, then mathbfe^i = mathbfe_i and we can interpret the ith component of nabla f as the directional derivative when moving in the ith direction.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Example","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Consider again the Julia function","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"f(x::Float64, y::Tuple{Float64, Float64}) = x + y[1] * y[2]","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"corresponding to f(x y) = x + y_1 y_2. An orthonormal basis for the function's domain mathbbR times mathbbR^2 is","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"mathbfe_1 = mathbfe^1 = (1 (0 0)) quad\nmathbfe_2 = mathbfe^2 = (0 (1 0)) quad\nmathbfe_3 = mathbfe^3 = (0 (0 1)) quad","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"so the gradient is","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign*\nnabla f(x y)\n\t= sum_i D fx y(mathbfe^i) mathbfe_i \n\t= Big(D fx y(1 (0 0)) big(D fx y(0 (1 0)) D fx y(0 (0 1))big)Big) \n\t= (1 (y_2 y_1))\nendalign*","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"referring back to Step 2 above for the values of D fx y(dotx doty).","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Computing-the-gradient-from-reverse-mode","page":"Algorithmic Differentiation","title":"Computing the gradient from reverse-mode","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"If we perform a single reverse-pass on a function f  mathcalX to RR to obtain D fx^ast, then the gradient is simply","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"nabla f (x) = D fx^ast (1) ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"To show this, note that D f x (dotx) = langle 1 D fx (dotx) rangle = langle D fx^ast (1) dotx rangle using the definition of the adjoint. Then, the definition of the gradient gives","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"langle nabla f (x) dotx rangle = langle D fx^ast (1) dotx rangle","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"which implies nabla f (x) = D fx^ast (1) since dotx is arbitrary.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Example","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The adjoint of the derivative of f(x y) = x + y_1 y_2 (see above) immediately gives","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"nabla f(x y) = D fx y^ast (1) = (1 (y_2 y_1)) ","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Aside: Adjoints of Derivatives as Gradients","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"It is interesting to note that value of D fx^ast (bary) returned by performing reverse-mode on a function f  mathcalX to mathcalY can always be viewed as the gradient of another function F  mathcalX to mathbbR.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Let F coloneqq h_bary circ f where h_bary(y) = langle y baryrangle. One can show D h_baryy^ast (1) = bary. Then, since","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"beginalign*\nlangle nabla F(x) dotx rangle\n\t= langle D Fx^ast (1) dotx rangle \n\t= langle D fx^ast (D h_baryf(x)^ast (1)) dotx rangle \n\t= langle D fx^ast (bary) dotx rangle \nendalign*","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"we have that nabla F(x) = D fx^ast (bary).","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"The consequence is that we can always view the computation performed by reverse-mode AD as computing the gradient of the composition of the function in question and an inner product with the argument to the adjoint.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Summary","page":"Algorithmic Differentiation","title":"Summary","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"This document explains the core mathematical foundations of AD. It explains separately what is does, and how it goes about it. Some basic examples are given which show how these mathematical foundations can be applied to differentiate functions of matrices, and Julia functions.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Subsequent sections will build on these foundations, to provide a more general explanation of what AD looks like for a Julia programme.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/#Asides","page":"Algorithmic Differentiation","title":"Asides","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/#*How*-does-Forwards-Mode-AD-work?","page":"Algorithmic Differentiation","title":"How does Forwards-Mode AD work?","text":"","category":"section"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"Forwards-mode AD achieves this by breaking down f into the composition f = f_N circ dots circ f_1, where each f_n is a simple function whose derivative (function) D f_n x_n we know for any given x_n. By the chain rule, we have that","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"D f x (dotx) = D f_N x_N circ dots circ D f_1 x_1 (dotx)","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"which suggests the following algorithm:","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"let x_1 = x, dotx_1 = dotx, and n = 1\nlet dotx_n+1 = D f_n x_n (dotx_n)\nlet x_n+1 = f(x_n)\nlet n = n + 1\nif n = N+1 then return dotx_N+1, otherwise go to 2.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"When each function f_n maps between Euclidean spaces, the applications of derivatives D f_n x_n (dotx_n) are given by J_n dotx_n where J_n is the Jacobian of f_n at x_n.","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"M. Giles. An extended collection of matrix derivative results for forward and reverse mode automatic differentiation. Unpublished (2008).\n\n\n\nT. P. Minka. Old and new matrix algebra useful for statistics. See www. stat. cmu. edu/minka/papers/matrix. html 4 (2000).\n\n\n\n","category":"page"},{"location":"understanding_mooncake/algorithmic_differentiation/","page":"Algorithmic Differentiation","title":"Algorithmic Differentiation","text":"[note_for_geometers]: in AD we only really need to discuss differentiatiable functions between vector spaces that are isomorphic to Euclidean space. Consequently, a variety of considerations which are usually required in differential geometry are not required here. Notably, the tangent space is assumed to be the same everywhere, and to be the same as the domain of the function. Avoiding these additional considerations helps keep the mathematics as simple as possible.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Forwards-Mode-Design","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Disclaimer: this document refers to an as-yet-unimplemented forwards-mode AD. This will disclaimer will be removed once it has been implemented.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The purpose of this document is to explain how forwards-mode AD in Mooncake.jl is implemented. It should do so to a sufficient level of depth to enable the interested reader to read to the forwards-mode AD code in Mooncake.jl and understand what is going on.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"This document","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"specifies the semantics of a \"rule\" for forwards-mode AD,\nspecifies how to implement rules by-hand for primitives,\nspecifies how to derive rules from IRCode algorithmically in general,\ndiscusses batched forwards-mode,\ndiscusses some notable technical differences between our forwards-mode AD implementation details and reverse-mode AD implementation details, and\nconcludes with a brief comparison with ForwardDiff.jl.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Forwards-Rule-Interface","page":"Forwards-Mode Design","title":"Forwards-Rule Interface","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Loosely, a rule for a function simultaneously","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"performs the same computation as the original function, and\ncomputes the Frechet derivative.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"This is best explained through a worked example. Consider a function call","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"z = f(x, y)","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"where f itself may contain data / state which is modified by executing f. rule_for_f is some callable which claims to be a forwards-rule for f. For rule_for_f to be a valid forwards-rule for f, it must be applicable to Duals as follows:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"z_dz = rule_for_f(Dual(f, df), Dual(x, dx), Dual(y, dy))::Dual","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"where:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"rule_for_f is a callable. It might be written by-hand, or derived algorithmically.\ndf, dx, and dy are tangents for f, x, and y respectively. Before executing rule_for_f, they are inputs to the derivative of (f, x, y). After executing they are outputs of this derivative.\nz_dz is a Dual containing the primal and the component of the derivative of (f, x, y) to (df, dx, dy) associated to z.\nrunning rule_for_f leaves f, x, and y in the same state that running f does.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"We refer readers to Algorithmic Differentiation to explain what we mean when we talk about the \"derivative\" above. We also discussed some worked examples shortly.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Note that rule_for_f is an as-yet-unspecified callable which we introduced purely to specify the interface that a forwards-rule must satisfy. In Hand-Written Rules and Derived Rules below, we introduce two concrete ways to produce rules for f.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Tangent-Types","page":"Forwards-Mode Design","title":"Tangent Types","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"We will use the type system documented in Representing Gradients. This means that every primal type has a unique tangent type. Moreover, if a Dual is defined as follows:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"struct Dual{P, T}\n    primal::P\n    tangent::T\nend","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"it must always hold that T = tangent_type(P).","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Testing","page":"Forwards-Mode Design","title":"Testing","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Suppose that we have (somehow) produced a supposed forwards-rule. To check that it is correctly implemented, we must ensure that","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"all primal state after running the rule is approximately the same as all primal state after running the primal, and\nthe inner product between all tangents (both output and input) and a random tangent vector after running the rule is approximately the same as the estimate of the same quantity produced by finite differencing or reverse-mode AD.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"We already have the functionality to do this in a very general way (see Mooncake.TestUtils.test_rule).","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Hand-Written-Rules","page":"Forwards-Mode Design","title":"Hand-Written Rules","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Hand-written rules are implemented by writing methods of two functions: is_primitive and frule!!.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#is_primitive","page":"Forwards-Mode Design","title":"is_primitive","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"is_primitive(::Type{<:Union{MinimalForwardsCtx, DefaultForwardsCtx}}, signature::Type{<:Tuple}) should return true if AD must attempt to differentiate a call by passing the arguments to frule!!, and false otherwise. The Mooncake.@is_primitive macro helps makes implementing this very easy.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#frule!!","page":"Forwards-Mode Design","title":"frule!!","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Methods of frule!! do the actual differentiation, and must satisfy the Forwards-Rule Interface discussed above.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"In what follows, we will refer to frule!!s for signatures. For example, the frule!! for signature Tuple{typeof(sin), Float64} is the rule which would differentiate calls like sin(5.0).","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Simple-Scalar-Function","page":"Forwards-Mode Design","title":"Simple Scalar Function","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Recall that for y = sin(x) we have that doty = cos(x) dotx. So the frule!! for signature Tuple{typeof(sin), Float64} is:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"function frule!!(::Dual{typeof(sin)}, x::Dual{Float64})\n    return Dual(sin(x.primal), cos(x.primal) * x.tangent)\nend","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Pre-allocated-Matrix-Matrix-Multiply","page":"Forwards-Mode Design","title":"Pre-allocated Matrix-Matrix Multiply","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Recall that for Z = X Y we have that dotZ = X dotY + dotX Y. So the frule!! for signature Tuple{typeof(mul!), Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} is:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"function frule!!(\n    ::Dual{typeof(LinearAlgebra.mul!)}, Z::Dual{P}, X::Dual{P}, Y::Dual{P}\n) where {P<:Matrix{Float64}}\n\n    # Primal computation.\n    mul!(Z.primal, X.primal, Y.primal)\n\n    # Overwrite tangent of `z` to contain propagated tangent.\n    mul!(Z.tangent, X.primal, Y.tangent)\n\n    # Add the result of x.tangent * y.primal to `z.tangent`.\n    mul!(Z.tangent, X.tangent, Y.primal, 0.0, 1.0) \n    return Z\nend","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"(In practice we would probably implement a rule for a lower-level function like LinearAlgebra.BLAS.gemm!, rather than mul!).","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Derived-Rules","page":"Forwards-Mode Design","title":"Derived Rules","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"This is the \"automatic\" / \"algorithmic\" bit of AD! This is the second way of producing concrete callable objects which satisfy the Forwards-Rule Interface discussed above. The object which we will ultimately construct is an instance Mooncake.DerivedFRule.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Worked-Example:-Julia-Function","page":"Forwards-Mode Design","title":"Worked Example: Julia Function","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Before explaining how derived rules are produced algorithmically, we explain by way of example what a derived rule should look like if we work things through by hand.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"A derived rule for a function such as","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"function f(x)\n    y = g(x)\n    z = h(x, y)\n    return z\nend","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"should be something of the form","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"function rule_for_f(::Dual{typeof(f)}, x::Dual)\n    y = rule_for_g(zero_dual(g), x)\n    z = rule_for_h(zero_dual(h), x, y)\n    return z\nend","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Observe that the transformation is simply","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"replace all variables with Dual variables,\nreplace all constants (e.g. g and h) with constant Duals,\nreplace all calls with calls to rules.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"In general, all control flow should be identical between primal and rule.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Worked-Example:-IRCode","page":"Forwards-Mode Design","title":"Worked Example: IRCode","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The above example is expressed in terms of Julia code, but we will be operating on Julia Compiler.IRCode, so it is helpful to consider how the above example translates into this form. If we call f on a Float64, and suppose that g and h both return Float64s, the primal Compiler.IRCode will look something like the following:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"julia> Base.code_ircode_by_type(Tuple{typeof(f), Float64})\n1-element Vector{Any}:\n2 1 ─ %1 = invoke Main.g(_2::Float64)::Float64\n3 │   %2 = invoke Main.h(_2::Float64, %1::Float64)::Float64\n4 └──      return %2\n   => Float64","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Recall that _2 is the second argument, in this case a Float64, and %1 and %2 are SSAValues. Roughly speaking, the forwards-mode IR for the (ficiticious) function rule_for_f should look something like:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"julia> Base.code_ircode_by_type(Tuple{typeof(rule_for_f), Dual{typeof(f), NoTangent}, Dual{Float64, Float64}})\n1-element Vector{Any}:\n2 1 ─ %1 = invoke rule_for_g($(Dual(Main.g, NoTangent())), _3::Dual{Float64, Float64})::Dual{Float64, Float64}\n3 │   %2 = invoke rule_for_h($(Dual(Main.h, NoTangent())), _3::Dual{Float64, Float64}, %1::Dual{Float64, Float64})::Dual{Float64, Float64}\n4 └──      return %2\n   => Dual{Float64, Float64}","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Observe that:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"All Arguments have been incremented by 1. i.e. _2 has been replaced with _3. This corresponds to the fact that the arguments to the rule have all been shuffled along by one, and the rule itself is now the first argument.\nEverything has been turned into a Dual.\nConstants such as Dual(Main.g, NoTangent()) appear directly in the code (here as QuoteNodes).","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"(In practice it might be that we actually construct the Dualed constants on the lines immediately preceding a call and rely on the compiler to optimise them back into the call directly).","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Here, as before, we have not specified exactly what rule_for_f, rule_for_g, and rule_for_h are. This is intentional – they are just callables satisfying the Forwards-Rule Interface. In the following we show how to derive rule_for_f, and show how rule_for_g and rule_for_h might be methods of Mooncake.frule!!, or themselves derived rules.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Rule-Derivation-Outline","page":"Forwards-Mode Design","title":"Rule Derivation Outline","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Equipped with some intuition about what a derived rule ought to look like, we examine how we go about producing it algorithmically.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Rule derivation is implemented via the function Mooncake.build_frule. This function accepts as arguments a context and a signature / Base.MethodInstance / MistyClosure and, roughly speaking, does the following:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Look up the optimised Compiler.IRCode.\nApply a series of standardising transformations to the IRCode.\nTransform each statement according to a set of rules to produce a new IRCode.\nApply standard Julia optimisations to this new IRCode.\nPut this code inside a MistyClosure in order to produce an executable object.\nWrap this MistyClosure in a DerivedFRule to handle various bits of book-keeping around varargs.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"In order:","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Looking-up-the-Compiler.IRCode.","page":"Forwards-Mode Design","title":"Looking up the Compiler.IRCode.","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"This is done using Mooncake.lookup_ir. This function has methods with will return the IRCode associated to:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"signatures (e.g. Tuple{typeof(f), Float64})\nBase.MethodInstances (relevant for :invoke expressions – see Statement Transformation below)\nMistyClosures.MistyClosure objects, which is essential when computing higher order derivatives and Hessians by applying Mooncake.jl to itself.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Standardisation","page":"Forwards-Mode Design","title":"Standardisation","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"We apply the following transformations to the Julia IR. They can all be found in ir_normalisation.jl:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Mooncake.foreigncall_to_call: convert Expr(:foreigncall, ...) expressions into Expr(:call, Mooncake._foreigncall_, ...) expressions.\nMooncake.new_to_call: convert Expr(:new, ...) expressions to Expr(:call, Mooncake._new_, ...) expressions.\nMooncake.splatnew_to_call: convert Expr(:splatnew, ...) expressions to Expr(:call, Mooncake._splat_new_...) expressions.\nMooncake.intrinsic_to_function: convert Expr(:call, ::IntrinsicFunction, ...) to calls to the corresponding function in Mooncake.IntrinsicsWrappers.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The purpose of converting Expr(:foreigncall...), Expr(:new, ...) and Expr(:splatnew, ...) into Expr(:call, ...)s is to enable us to differentiate such expressions by adding methods to frule!!(::Dual{typeof(Mooncake._foreigncall_)}), frule!!(::Dual{typeof(Mooncake._new_)}), and frule!!(::Dual{typeof(Mooncake._splat_new_)}), in exactly the same way that we would for any other regular Julia function.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The purpose of translating Expr(:call, ::IntrinsicFunction, ...) is to do with type stability – see the docstring for the Mooncake.IntrinsicsWrappers module for more info.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Statement-Transformation","page":"Forwards-Mode Design","title":"Statement Transformation","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Each statment which can appear in the Julia IR is transformed by a method of Mooncake.make_fwds_ad_stmts. Consequently, this transformation phase simply corresponds to iterating through all of the expressions in the IRCode, applying Mooncake.make_fwd_ad_stmts to each to produce new IRCode. To understand how to modify IRCode and insert new instructions, see Oxinabox's Gist.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"We provide here a high-level summary of the transformations for the most important Julia IR statements, and refer readers to the methods of Mooncake.make_fwds_ad_stmts for the definitive explanation of what transformation is applied, and the rationale for applying it. In particular there are quite a number more statements which can appear in Julia IR than those listed here and, for those we do list here, there are typically a few edge cases left out.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Expr(:invoke, method_instance, f, x...) and Expr(:call, f, x...)","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":":call expressions correspond to dynamic dispatch, while :invoke expressions correspond to static dispatch. That is, if you see an :invoke expression, you know for sure that the compiler knows enough information about the types of f and x to prove exactly which specialisation of which method to call. This specialisation is method_instance. This typically happens when the compiler is able to prove the types of f and x. Conversely, a :call expression typically occurs when the compiler has not been able to deduce the exact types of f and x, and therefore not been able to figure out what to call. It therefore has to wait until runtime to figure out what to call, resulting in dynamic dispatch.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"As we saw earlier, the idea is to translate these kinds of expressions into something vaguely along the lines of","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Expr(:call, rule_for_f, f, x...)","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"There are three cases to consider, in order of preference:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Primitives:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"If is_primitive returns true when applied to the signature constructed from the static types of f and x, then we simply replace the expression with Expr(:call, frule!!, f, x...), regardless whether we have an :invoke or :call expression. (Due to the Standardisation steps, it regularly happens that we see :call expressions in which we actually do know enough type information to do this, e.g. for Mooncake._new_ :call expressions).","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Static Dispatch:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"In the case of :invoke nodes we know for sure at rule compilation time what rule_for_f must be. We derive a rule for the call by passing method_instance to Mooncake.build_frule. (In practice, we might do this lazily, but while retaining enough information to maintain type stability. See the Mooncake.LazyDerivedRule for how this is handled in reverse-mode).","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Dynamic Dispatch:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"If we have a :call expression and are not able to prove that is_primitive will return true, we must defer dispatch until runtime. We do this by replacing the :call expression with a call to a DynamicFRule, which simply constructs (or retrieves from a cache) the rule at runtime. Reverse-mode utilises a similar strategy via Mooncake.DynamicDerivedRule.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The above was written in terms of f and x. In practice, of course, we encounter various kinds of constants (e.g. Base.sin), Arguments (e.g. _3), and Core.SSAValues (e.g. %5). The translation rules for these are:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"constants are turned into constant duals in which the tangent is zero,\nArguments are incremented by 1.\nSSAValues are left as-is.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.GotoNodes","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"These remain entirely unchanged.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.GotoIfNot","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"These require minor modification. Suppose that a Core.GotoIfNot of the form Core.GotoIfNot(%5, 4) is encountered in the primal. Since %5 will be a Dual in the derived rule, we must pull out the primal field, and pass that to the conditional instead. Therefore, these statments get lowered to two lines in the derived rule. For example, Core.GotoIfNot(%5, 4) would be translated to:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"%n = getfield(%5, :primal)\nCore.GotoIfNot(%n, 4)","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.PhiNode","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.PhiNode looks something like the following in the general case:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"φ (#1 => %3, #2 => _2, #3 => 4, #4 => #undef)","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"They map from a collection of basic block numbers (#1, #2, etc) to values. The values can be Core.Arguments, Core.SSAValues, constants (literals and QuoteNodes), or undefined.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.PhiNodes in the primal are mapped to Core.PhiNodes in the rule. They contain exactly the same basic block numbers, and apply the following translation rules to the values:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Core.SSAValues are unchanged.\nCore.Arguments are incremented by 1 (as always).\nconstants are translated into constant duals.\nundefined values remain undefined.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"So the above example would be translated into something like","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"φ (#1 => %3, #2 => _3, #3 => $(CoDual(4, NoTangent())), #4 => #undef)","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Optimisation","page":"Forwards-Mode Design","title":"Optimisation","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The IR generated in the previous step will typically be uninferred, and suboptimal in a variety of ways. We fix this up by running inference and optimisation on the generated IRCode. This is implemented by Mooncake.optimise_ir!.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Put-IRCode-in-MistyClosure","page":"Forwards-Mode Design","title":"Put IRCode in MistyClosure","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"Now that we have an optimised IRCode object, we need to turn it into something that can actually be run. This can, in general, be straightforwardly achieved by putting it inside a Core.OpaqueClosure. This works, but Core.OpaqueClosures have the disadvantage that once you've constructed a Core.OpaqueClosure using an IRCode, it is not possible to get it back out. Consequently, we use MistyClosures, in order to keep the IRCode readily accessible if we want to access it later.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Put-the-MistyClosure-in-a-DerivedFRule","page":"Forwards-Mode Design","title":"Put the MistyClosure in a DerivedFRule","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"See the implementation of DerivedRule (used in reverse-mode) for more context on this. This is the \"rule\" that users get.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Batch-Mode","page":"Forwards-Mode Design","title":"Batch Mode","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"So far, we have assumed that we would only apply forwards-mode to a single tangent vector at a time. However, in practice, it is typically best to pass a collection of tangents through at a time.","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"In order to do this, all of the transformation code listed above can remain the same, we will just need to devise a system of \"batched tangents\". Then, instead of propagating a \"primal-tangent\" pairs via Duals, we propagate primal-tangent_batch pairs (perhaps also via Duals).","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Forwards-vs-Reverse-Implementation","page":"Forwards-Mode Design","title":"Forwards vs Reverse Implementation","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"The implementation of forwards-mode AD is quite dramatically simpler than that of reverse-mode AD. Some notable technical differences include:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"forwards-mode AD only makes use of the tangent system, whereas reverse-mode also makes use of the fdata / rdata system.\nforwards-mode AD comprises only line-by-line transformations of the IRCode. In particular, it does not require the insertion of additional basic blocks, nor the modification of the successors / predecessors of any given basic block. Consequently, there is no need to make use of the BBCode infrastructure built up for reverse-mode AD – everything can be straightforwardly done at the Compiler.IRCode level.","category":"page"},{"location":"developer_documentation/forwards_mode_design/#Comparison-with-ForwardDiff.jl","page":"Forwards-Mode Design","title":"Comparison with ForwardDiff.jl","text":"","category":"section"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":"With reference to the limitations of ForwardDiff.jl, there are a few noteworthy differences between ForwardDiff.jl and this implementation:","category":"page"},{"location":"developer_documentation/forwards_mode_design/","page":"Forwards-Mode Design","title":"Forwards-Mode Design","text":":foreigncalls pose much less of a problem for Mooncake's forward-mode than for ForwardDiff.jl, because we can write a rule for any method of any function. In essence, you can only (reliably) write rules for ForwardDiff.jl via dispatch on ForwardDiff.Dual.\nthe target function can be of any arity in Mooncake.jl, but must be unary in ForwardDiff.jl.\nthere are no limitations on the argument type constraints that Mooncake.jl can handle, while ForwardDiff.jl requires that argument type constraints be <:Real or arrays of <:Real.\nNo special storage types are required with Mooncake.jl, while ForwardDiff.jl requires that any container you write to is able to contain ForwardDiff.Duals.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"This is the public interface that day-to-day users of AD are expected to interact with if for some reason DifferentiationInterface.jl does not suffice. If you have not tried using Mooncake.jl via DifferentiationInterface.jl, please do so. See Tutorial for more info.","category":"page"},{"location":"interface/#Mooncake.Config","page":"Interface","title":"Mooncake.Config","text":"Config(; debug_mode::Bool=false, silence_debug_messages::Bool=false)\n\nConfiguration struct for use with ADTypes.AutoMooncake.\n\nKeyword Arguments\n\ndebug_mode::Bool=false: whether or not to run additional type checks when   differentiating a function. This has considerable runtime overhead, and should only be   switched on if you are trying to debug something that has gone wrong in Mooncake.\nsilence_debug_messages::Bool=false: if false and debug_mode is true, Mooncake will   display some warnings that debug mode is enabled, in order to help prevent accidentally   leaving debug mode on. If you wish to disable these messages, set this to true.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Mooncake.value_and_gradient!!-Union{Tuple{N}, Tuple{F}, Tuple{Mooncake.Cache, F, Vararg{Any, N}}} where {F, N}","page":"Interface","title":"Mooncake.value_and_gradient!!","text":"value_and_gradient!!(cache::Cache, f, x...)\n\nComputes a 2-tuple. The first element is f(x...), and the second is a tuple containing the gradient of f w.r.t. each argument. The first element is the gradient w.r.t any differentiable fields of f, the second w.r.t the first element of x, etc.\n\nAssumes that f returns a Union{Float16, Float32, Float64}.\n\nAs with all functionality in Mooncake, if f modifes itself or x, value_and_gradient!! will return both to their original state as part of the process of computing the gradient.\n\ninfo: Info\ncache must be the output of prepare_gradient_cache, and (fields of) f and x must be of the same size and shape as those used to construct the cache. This is to ensure that the gradient can be written to the memory allocated when the cache was built.\n\nwarning: Warning\ncache owns any mutable state returned by this function, meaning that mutable components of values returned by it will be mutated if you run this function again with different arguments. Therefore, if you need to keep the values returned by this function around over multiple calls to this function with the same cache, you should take a copy (using copy or deepcopy) of them before calling again.\n\nExample Usage\n\nf(x, y) = sum(x .* y)\nx = [2.0, 2.0]\ny = [1.0, 1.0]\ncache = prepare_gradient_cache(f, x, y)\nvalue_and_gradient!!(cache, f, x, y)\n\n# output\n\n(4.0, (NoTangent(), [1.0, 1.0], [2.0, 2.0]))\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mooncake.value_and_pullback!!-Union{Tuple{N}, Tuple{F}, Tuple{Mooncake.Cache, Any, F, Vararg{Any, N}}} where {F, N}","page":"Interface","title":"Mooncake.value_and_pullback!!","text":"value_and_pullback!!(cache::Cache, ȳ, f, x...)\n\ninfo: Info\nIf f(x...) returns a scalar, you should use value_and_gradient!!, not this function.\n\nComputes a 2-tuple. The first element is f(x...), and the second is a tuple containing the pullback of f applied to ȳ. The first element is the component of the pullback associated to any fields of f, the second w.r.t the first element of x, etc.\n\nThere are no restrictions on what y = f(x...) is permitted to return. However, ȳ must be an acceptable tangent for y. This means that, for example, it must be true that tangent_type(typeof(y)) == typeof(ȳ).\n\nAs with all functionality in Mooncake, if f modifes itself or x, value_and_gradient!! will return both to their original state as part of the process of computing the gradient.\n\ninfo: Info\ncache must be the output of prepare_pullback_cache, and (fields of) f and x must be of the same size and shape as those used to construct the cache. This is to ensure that the gradient can be written to the memory allocated when the cache was built.\n\nwarning: Warning\ncache owns any mutable state returned by this function, meaning that mutable components of values returned by it will be mutated if you run this function again with different arguments. Therefore, if you need to keep the values returned by this function around over multiple calls to this function with the same cache, you should take a copy (using copy or deepcopy) of them before calling again.\n\nExample Usage\n\nf(x, y) = sum(x .* y)\nx = [2.0, 2.0]\ny = [1.0, 1.0]\ncache = Mooncake.prepare_pullback_cache(f, x, y)\nMooncake.value_and_pullback!!(cache, 1.0, f, x, y)\n\n# output\n\n(4.0, (NoTangent(), [1.0, 1.0], [2.0, 2.0]))\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mooncake.prepare_gradient_cache","page":"Interface","title":"Mooncake.prepare_gradient_cache","text":"prepare_gradient_cache(f, x...)\n\nReturns a cache used with value_and_gradient!!. See that function for more info.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mooncake.prepare_pullback_cache","page":"Interface","title":"Mooncake.prepare_pullback_cache","text":"prepare_pullback_cache(f, x...)\n\nReturns a cache used with value_and_pullback!!. See that function for more info.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/reverse_mode_design/#Reverse-Mode-Design","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"","category":"section"},{"location":"developer_documentation/reverse_mode_design/#Compilation-process","page":"Reverse-Mode Design","title":"Compilation process","text":"","category":"section"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Last checked: 09/02/2025, Julia v1.10.8 / v1.11.3, Mooncake 0.4.83.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"This brief informal note was largely written by Guillaume Dalle while learning how Mooncake's internals operate for reverse-mode, in order to be able to add forwards-mode AD. It should help readers orient themselves when first trying to understand Mooncake's internals.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Rule building is done statically, based on types. Some methods accept values, e.g.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"build_rrule(args...; debug_mode=false)","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"but these simply extract the types of all the arguments and call the main method (non Helper) for build_rrule.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The action happens in s2s_reverse_mode_ad.jl, in particular the following method:","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"build_rrule(interp::MooncakeInterpreter{C}, sig_or_mi; debug_mode=false)","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"sig_or_mi is either a signature, such as Tuple{typeof(foo), Float64}, or a Core.MethodInstance. Signatures are extracted from Core.MethodInstances as necessary.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"If a signature has a custom rule (Mooncake.is_primitive returns true), we take it, otherwise we generate the IR and differentiate it.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The forward and reverse pass IRs are created by the generate_ir method. The OpaqueClosure allows going back from the IR to a callable object. More precisely we use MistyClosure to store the associated IR.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The Pullback and DerivedRule structs are convenience wrappers for MistyClosures with some bookkeeping.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Diving one level deeper, in the following method:","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"generate_ir(\n    interp::MooncakeInterpreter, sig_or_mi; debug_mode=false, do_inline=true\n)","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The function lookup_ir calls Core.Compiler.typeinf_ircode on a method instance, which is a lower-level version of Base.code_ircode.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The IR considered is of type IRCode, which is different from the CodeInfo returned by @code_typed. This format is obtained from CodeInfo, used to perform most optimizations in the Julia IR in the evaluation pipeline, then converted back to CodeInfo.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The function normalise! is a custom pass to modify IRCode and make some expressions nicer to work with. The possible expressions one can encountered in lowered ASTs are documented here.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Reverse-mode specific stuff: return type retrieval, ADInfo, bbcode.jl, zero_like_rdata.jl. The BBCode structure was a convenience for IR transformation.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Beyond the interpreter folder, check out tangents.jl for forward mode.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Tangent is the correct representation required for Forward mode AD. FData and RData are not representations needed directly.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"For testing, all the tests got via the generate_test_functions method (defined in test_resources.jl) must pass. Recycle the functionality from reverse mode test utils.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"To manipulate IRCode, check out the fields:","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"ir.argtypes is the signature. Some are annotated with Core.Const to facilitate constant propagation for instance. Other annotations are PartialStruct, Conditional, PartialTypeVar. Core.Compiler.widenconst is used to extract types from these.\nir.stmts is a Core.Compiler.InstructionStream. This represents a sequence of instructions via 5 vectors of the same length:\nstmts.stmt is a vector of expressions (or other IR node types), see AST docs\nstmts.type is a vector of types for the left-hand side of the assignment\nthree others\nir.cfg is the Control Flow Graph of type Core.Compiler.CFG\nir.meta is metadata, not important\nir.new_nodes is an optimization buffer, not important\nir.sptypes is for type parameters of the called function","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"We must maintain coherence between the various components of IRCode (especially ir.stmts and ir.cfg). That is the reason behind BBCode, to make coherence easier. We can deduce the CFG from the statements but not the other way around: it's only composed of blocks of statement indices. In forward mode we shouldn't have to modify anything but ir.stmts. Do line by line transformation of the statements and then possibly refresh the CFG.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Examples of how line-by-line transformations can be done, are defined in Mooncake.make_ad_stmts!. The IRCode nodes are not explicitly documented in https://docs.julialang.org/en/v1/devdocs/ast/#Lowered-form or https://docs.julialang.org/en/v1/devdocs/ssair/#Main-SSA-data-structure. Might need completion of official docs, but Mooncake docs in the meantime.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"Inlining pass can prevent us from using high-level rules by inlining the function (e.g. unrolling a loop). The contexts in interpreter/contexts.jl are MinimalCtx (necessary for AD to work) and DefaultCtx (ensure that we hit all of the rules). Distinction between rules is not well maintained in Mooncake at the moment. The function is_primitive defines whether we should recurse into the function during AD and break it into parts, or look for a rule. If we define a rule we should set is_primitive to true for the corresponding function.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"In interpreter/abstract_interpretation.jl we interact with the Julia compiler. The most important part is preventing the compiler from inlining.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"The MooncakeInterpreter subtypes Core.Compiler.AbstractInterpreter to interpret Julia code. There are also Cthulhu, Enzyme, JET interpreters. Tells you how things get run.","category":"page"},{"location":"developer_documentation/reverse_mode_design/","page":"Reverse-Mode Design","title":"Reverse-Mode Design","text":"For second order we will need to adapt IR lookup to misty closures.","category":"page"},{"location":"developer_documentation/internal_docstrings/#Internal-Docstrings","page":"Internal Docstrings","title":"Internal Docstrings","text":"","category":"section"},{"location":"developer_documentation/internal_docstrings/","page":"Internal Docstrings","title":"Internal Docstrings","text":"Docstrings listed here are not part of the public Mooncake.jl interface. Consequently, they can change between non-breaking changes to Mooncake.jl without warning.","category":"page"},{"location":"developer_documentation/internal_docstrings/","page":"Internal Docstrings","title":"Internal Docstrings","text":"The purpose of this is to make it easy for developers to find docstrings straightforwardly via the docs, as opposed to having to ctrl+f through Mooncake.jl's source code, or looking at the docstrings via the Julia REPL.","category":"page"},{"location":"developer_documentation/internal_docstrings/#Mooncake.GLOBAL_INTERPRETER","page":"Internal Docstrings","title":"Mooncake.GLOBAL_INTERPRETER","text":"const GLOBAL_INTERPRETER\n\nGlobally cached interpreter. Should only be accessed via get_interpreter.\n\n\n\n\n\n","category":"constant"},{"location":"developer_documentation/internal_docstrings/#Mooncake.ADInfo","page":"Internal Docstrings","title":"Mooncake.ADInfo","text":"ADInfo\n\nThis data structure is used to hold \"global\" information associated to a particular call to build_rrule. It is used as a means of communication between make_ad_stmts! and the codegen which produces the forwards- and reverse-passes.\n\ninterp: a MooncakeInterpreter.\nblock_stack_id: the ID associated to the block stack – the stack which keeps track of   which blocks we visited during the forwards-pass, and which is used on the reverse-pass   to determine which blocks to visit.\nblock_stack: the block stack. Can always be found at block_stack_id in the forwards-   and reverse-passes.\nentry_id: ID associated to the block inserted at the start of execution in the the   forwards-pass, and the end of execution in the pullback.\nshared_data_pairs: the SharedDataPairs used to define the captured variables passed   to both the forwards- and reverse-passes.\narg_types: a map from Argument to its static type.\nssa_insts: a map from ID associated to lines to the primal NewInstruction. This   contains the line of code, its static / inferred type, and some other detailss. See   Core.Compiler.NewInstruction for a full list of fields.\narg_rdata_ref_ids: the dict mapping from arguments to the ID which creates and   initialises the Ref which contains the reverse data associated to that argument.   Recall that the heap allocations associated to this Ref are always optimised away in   the final programme.\nssa_rdata_ref_ids: the same as arg_rdata_ref_ids, but for each ID associated to an   ssa rather than each argument.\ndebug_mode: if true, run in \"debug mode\" – wraps all rule calls in DebugRRule. This   is applied recursively, so that debug mode is also switched on in derived rules.\nis_used_dict: for each ID associated to a line of code, is false if line is not used   anywhere in any other line of code.\nlazy_zero_rdata_ref_id: for any arguments whose type doesn't permit the construction of   a zero-valued rdata directly from the type alone (e.g. a struct with an abstractly-   typed field), we need to have a zero-valued rdata available on the reverse-pass so that   this zero-valued rdata can be returned if the argument (or a part of it) is never used   during the forwards-pass and consequently doesn't obtain a value on the reverse-pass.   To achieve this, we construct a LazyZeroRData for each of the arguments on the   forwards-pass, and make use of it on the reverse-pass. This field is the ID that will be   associated to this information.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.ADStmtInfo","page":"Internal Docstrings","title":"Mooncake.ADStmtInfo","text":"ADStmtInfo\n\nData structure which contains the result of make_ad_stmts!. Fields are\n\nline: the ID associated to the primal line from which this is derived\ncomms_id: an ID from one of the lines in fwds, whose value will be made   available on the reverse-pass in the same ID. Nothing is asserted about how this   value is made available on the reverse-pass of AD, so this package is free to do this in   whichever way is most efficient, in particular to group these communication ID on a   per-block basis.\nfwds: the instructions which run the forwards-pass of AD\nrvs: the instructions which run the reverse-pass of AD / the pullback\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.BlockStack","page":"Internal Docstrings","title":"Mooncake.BlockStack","text":"The block stack is the stack used to keep track of which basic blocks are visited on the forwards pass, and therefore which blocks need to be visited on the reverse pass. There is one block stack per derived rule. By using Int32, we assume that there aren't more than typemax(Int32) unique basic blocks in a given function, which ought to be reasonable.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.CannotProduceZeroRDataFromType","page":"Internal Docstrings","title":"Mooncake.CannotProduceZeroRDataFromType","text":"CannotProduceZeroRDataFromType()\n\nReturned by zero_rdata_from_type if is not possible to construct the zero rdata element for a given type. See zero_rdata_from_type for more info.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DebugPullback","page":"Internal Docstrings","title":"Mooncake.DebugPullback","text":"DebugPullback(pb, y, x)\n\nConstruct a callable which is equivalent to pb, but which enforces type-based pre- and post-conditions to pb. Let dx = pb.pb(dy), for some rdata dy, then this function\n\nchecks that dy has the correct rdata type for y, and\nchecks that each element of dx has the correct rdata type for x.\n\nReverse pass counterpart to DebugRRule\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DebugPullback-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.DebugPullback","text":"(pb::DebugPullback)(dy)\n\nApply type checking to enforce pre- and post-conditions on pb.pb. See the docstring for DebugPullback for details.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DebugRRule","page":"Internal Docstrings","title":"Mooncake.DebugRRule","text":"DebugRRule(rule)\n\nConstruct a callable which is equivalent to rule, but inserts additional type checking. In particular:\n\ncheck that the fdata in each argument is of the correct type for the primal\ncheck that the fdata in the CoDual returned from the rule is of the correct type for the   primal.\n\nThis happens recursively. For example, each element of a Vector{Any} is compared against each element of the associated fdata to ensure that its type is correct, as this cannot be guaranteed from the static type alone.\n\nSome additional dynamic checks are also performed (e.g. that an fdata array of the same size as its primal).\n\nLet rule return y, pb!!, then DebugRRule(rule) returns y, DebugPullback(pb!!). DebugPullback inserts the same kind of checks as DebugRRule, but on the reverse-pass. See the docstring for details.\n\nNote: at any given point in time, the checks performed by this function constitute a necessary but insufficient set of conditions to ensure correctness. If you find that an error isn't being caught by these tests, but you believe it ought to be, please open an issue or (better still) a PR.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DebugRRule-Union{NTuple{N, Mooncake.CoDual}, Tuple{N}} where N","page":"Internal Docstrings","title":"Mooncake.DebugRRule","text":"(rule::DebugRRule)(x::CoDual...)\n\nApply type checking to enforce pre- and post-conditions on rule.rule. See the docstring for DebugRRule for details.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DefaultCtx","page":"Internal Docstrings","title":"Mooncake.DefaultCtx","text":"struct DefaultCtx end\n\nContext for all usually used AD primitives. Anything which is a primitive in a MinimalCtx is a primitive in the DefaultCtx automatically. If you are adding a rule for the sake of performance, it should be a primitive in the DefaultCtx, but not the MinimalCtx.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.DynamicDerivedRule","page":"Internal Docstrings","title":"Mooncake.DynamicDerivedRule","text":"DynamicDerivedRule(interp::MooncakeInterpreter, debug_mode::Bool)\n\nFor internal use only.\n\nA callable data structure which, when invoked, calls an rrule specific to the dynamic types of its arguments. Stores rules in an internal cache to avoid re-deriving.\n\nThis is used to implement dynamic dispatch.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.FData","page":"Internal Docstrings","title":"Mooncake.FData","text":"FData(data::NamedTuple)\n\nThe component of a struct which is propagated alongside the primal on the forwards-pass of AD. For example, the tangents for Float64s do not need to be propagated on the forwards- pass of reverse-mode AD, so any Float64 fields of Tangent do not need to appear in the associated FData.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.InvalidFDataException","page":"Internal Docstrings","title":"Mooncake.InvalidFDataException","text":"InvalidFDataException(msg::String)\n\nException indicating that there is a problem with the fdata associated to a primal.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.InvalidRDataException","page":"Internal Docstrings","title":"Mooncake.InvalidRDataException","text":"InvalidRDataException(msg::String)\n\nException indicating that there is a problem with the rdata associated to a primal.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.LazyDerivedRule","page":"Internal Docstrings","title":"Mooncake.LazyDerivedRule","text":"LazyDerivedRule(interp, mi::Core.MethodInstance, debug_mode::Bool)\n\nFor internal use only.\n\nA type-stable wrapper around a DerivedRule, which only instantiates the DerivedRule when it is first called. This is useful, as it means that if a rule does not get run, it does not have to be derived.\n\nIf debug_mode is true, then the rule constructed will be a DebugRRule. This is useful when debugging, but should usually be switched off for production code as it (in general) incurs some runtime overhead.\n\nNote: the signature of the primal for which this is a rule is stored in the type. The only reason to keep this around is for debugging – it is very helpful to have this type visible in the stack trace when something goes wrong, as it allows you to trivially determine which bit of your code is the culprit.\n\nExtended Help\n\nThere are two main reasons why deferring the construction of a DerivedRule until we need to use it is crucial.\n\nThe first is to do with recursion. Consider the following function:\n\nf(x) = x > 0 ? f(x - 1) : x\n\nIf we generate the IRCode for this function, we will see something like the following:\n\njulia> Base.code_ircode_by_type(Tuple{typeof(f), Float64})[1][1]\n1 1 ─ %1  = Base.lt_float(0.0, _2)::Bool\n  │   %2  = Base.or_int(%1, false)::Bool\n  └──       goto #6 if not %2\n  2 ─ %4  = Base.sub_float(_2, 1.0)::Float64\n  │   %5  = Base.lt_float(0.0, %4)::Bool\n  │   %6  = Base.or_int(%5, false)::Bool\n  └──       goto #4 if not %6\n  3 ─ %8  = Base.sub_float(%4, 1.0)::Float64\n  │   %9  = invoke Main.f(%8::Float64)::Float64\n  └──       goto #5\n  4 ─       goto #5\n  5 ┄ %12 = φ (#3 => %9, #4 => %4)::Float64\n  └──       return %12\n  6 ─       return _2\n\nSuppose that we decide to construct a DerivedRule immediately whenever we find an :invoke statement in a rule that we're currently building a DerivedRule for. In the above example, we produce an infinite recursion when we attempt to produce a DerivedRule for %9, because it has the same signature as the call which generates this IR. By instead adopting a policy of constructing a LazyDerivedRule whenever we encounter an :invoke statement, we avoid this problem.\n\nThe second reason that delaying the construction of a DerivedRule, is essential is that it ensures that we don't derive rules for method instances which aren't run. Suppose that function B contains code for which we can't derive a rule – perhaps it contains an unsupported language feature like a PhiCNode or an UpsilonNode. Suppose that function A contains an :invoke which refers to function B, but that this call is on a branch which deals with error handling, and doesn't get run run unless something goes wrong. By deferring the derivation of the rule for B, we only ever attempt to derive it if we land on this error handling branch. Conversely, if we attempted to derive the rule for B when we derive the rule for A, we would be unable to complete the derivation of the rule for A.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.LazyZeroRData","page":"Internal Docstrings","title":"Mooncake.LazyZeroRData","text":"LazyZeroRData{P, Tdata}()\n\nThis type is a lazy placeholder for zero_like_rdata_from_type. This is used to defer construction of zero data to the reverse pass. Calling instantiate on an instance of this will construct a zero data.\n\nUsers should construct using LazyZeroRData(p), where p is an value of type P. This constructor, and instantiate, are specialised to minimise the amount of data which must be stored. For example, Float64s do not need any data, so LazyZeroRData(0.0) produces an instance of a singleton type, meaning that various important optimisations can be performed in AD.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.MinimalCtx","page":"Internal Docstrings","title":"Mooncake.MinimalCtx","text":"struct MinimalCtx end\n\nFunctions should only be primitives in this context if not making them so would cause AD to fail. In particular, do not add primitives to this context if you are writing them for performance only – instead, make these primitives in the DefaultCtx.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.MutableTangent","page":"Internal Docstrings","title":"Mooncake.MutableTangent","text":"MutableTangent{Tfields<:NamedTuple}\n\nDefault type used to represent the tangent of a mutable struct. See tangent_type for more info.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.NoFData","page":"Internal Docstrings","title":"Mooncake.NoFData","text":"NoFData\n\nSingleton type which indicates that there is nothing to be propagated on the forwards-pass in addition to the primal data.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.NoPullback-Union{NTuple{N, Mooncake.CoDual}, Tuple{N}} where N","page":"Internal Docstrings","title":"Mooncake.NoPullback","text":"NoPullback(args::CoDual...)\n\nConstruct a NoPullback from the arguments passed to an rrule!!. For each argument, extracts the primal value, and constructs a LazyZeroRData. These are stored in a NoPullback which, in the reverse-pass of AD, instantiates these LazyZeroRDatas and returns them in order to perform the reverse-pass of AD.\n\nThe advantage of this approach is that if it is possible to construct the zero rdata element for each of the arguments lazily, the NoPullback generated will be a singleton type. This means that AD can avoid generating a stack to store this pullback, which can result in significant performance improvements.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.NoRData","page":"Internal Docstrings","title":"Mooncake.NoRData","text":"NoRData()\n\nNothing to propagate backwards on the reverse-pass.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.NoTangent","page":"Internal Docstrings","title":"Mooncake.NoTangent","text":"NoTangent\n\nThe type in question has no meaningful notion of a tangent space. Generally, you shouldn't use this – just let the default recursive tangent construction work. You might need to use this for primitive types though.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.PossiblyUninitTangent","page":"Internal Docstrings","title":"Mooncake.PossiblyUninitTangent","text":"PossiblyUninitTangent{T}\n\nRepresents a T which maybe or may not be present. Does not distinguish between 0 and not being present.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.RRuleZeroWrapper","page":"Internal Docstrings","title":"Mooncake.RRuleZeroWrapper","text":"RRuleZeroWrapper(rule)\n\nThis struct is used to ensure that ZeroRDatas, which are used as placeholder zero elements whenever an actual instance of a zero rdata for a particular primal type cannot be constructed without also having an instance of said type, never reach rules. On the pullback, we increment the cotangent dy by an amount equal to zero. This ensures that if it is a ZeroRData, we instead get an actual zero of the correct type. If it is not a zero rdata, the computation should be elided via inlining + constant prop.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.SharedDataPairs","page":"Internal Docstrings","title":"Mooncake.SharedDataPairs","text":"SharedDataPairs()\n\nA data structure used to manage the captured data in the OpaqueClosures which implement the bulk of the forwards- and reverse-passes of AD. An entry (id, data) at element n of the pairs field of this data structure means that data will be available at register id during the forwards- and reverse-passes of AD.\n\nThis is achieved by storing all of the data in the pairs field in the captured tuple which is passed to an OpaqueClosure, and extracting this data into registers associated to the corresponding IDs.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.Stack","page":"Internal Docstrings","title":"Mooncake.Stack","text":"Stack{T}()\n\nA stack specialised for reverse-mode AD.\n\nSemantically equivalent to a usual stack, but never de-allocates memory once allocated.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.Tangent","page":"Internal Docstrings","title":"Mooncake.Tangent","text":"Tangent{Tfields<:NamedTuple}\n\nDefault type used to represent the tangent of a struct. See tangent_type for more info.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.UnhandledLanguageFeatureException","page":"Internal Docstrings","title":"Mooncake.UnhandledLanguageFeatureException","text":"UnhandledLanguageFeatureException(message::String)\n\nAn exception used to indicate that some aspect of the Julia language which AD cannot handle has been encountered.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.ZeroRData","page":"Internal Docstrings","title":"Mooncake.ZeroRData","text":"ZeroRData()\n\nSingleton type indicating zero-valued rdata. This should only ever appear as an intermediate quantity in the reverse-pass of AD when the type of the primal is not fully inferable, or a field of a type is abstractly typed.\n\nIf you see this anywhere in actual code, or if it appears in a hand-written rule, this is an error – please open an issue in such a situation.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__exclude_unsupported_output-Tuple{T} where T","page":"Internal Docstrings","title":"Mooncake.__exclude_unsupported_output","text":"__exclude_unsupported_output(y)\n\nRequired for the robust design of value_and_pullback, prepare_pullback_cache.   Ensures that y contains no aliasing, circular references, Ptrs or non differentiable datatypes.  In the forward pass f(args...) output can only return a \"Tree\" like datastructure with leaf nodes as primitive types.   Refer https://github.com/chalk-lab/Mooncake.jl/issues/517#issuecomment-2715202789 and related issue for details.   Internally calls __exclude_unsupported_output_internal!. The design is modelled after zero_tangent.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__exclude_unsupported_output_internal!-Union{Tuple{T}, Tuple{T, Set{UInt64}}} where T","page":"Internal Docstrings","title":"Mooncake.__exclude_unsupported_output_internal!","text":"__exclude_unsupported_output_internal(y::T, address_set::Set{UInt}) where {T}\n\nFor checking if outputy is a valid Mutable/immutable composite or a primitive type. Performs a recursive depth first search over the function output y with an isbitstype() check base case. The visited memory addresses are stored inside address_set. If the set already contains a newly visited address, it errors out indicating an Alais or Circular reference. Also errors out if y is or contains a Pointer. It is called internally by __exclude_unsupported_output(y).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__flatten_varargs-Union{Tuple{nvargs}, Tuple{Bool, Any, Val{nvargs}}} where nvargs","page":"Internal Docstrings","title":"Mooncake.__flatten_varargs","text":"__flatten_varargs(isva::Bool, args, ::Val{nvargs}) where {nvargs}\n\nIf isva, inputs (5.0, (4.0, 3.0)) are transformed into (5.0, 4.0, 3.0).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__get_value-Tuple{Mooncake.BasicBlockCode.ID, Mooncake.BasicBlockCode.IDPhiNode}","page":"Internal Docstrings","title":"Mooncake.__get_value","text":"__get_value(edge::ID, x::IDPhiNode)\n\nHelper functionality for concludervsblock.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__insts_to_instruction_stream-Tuple{Vector{Any}}","page":"Internal Docstrings","title":"Mooncake.__insts_to_instruction_stream","text":"__insts_to_instruction_stream(insts::Vector{Any})\n\nProduces an instruction stream whose\n\nstmt (v1.11 and up) / inst (v1.10) field is insts,\ntype field is all Any,\ninfo field is all Core.Compiler.NoCallInfo,\nline field is all Int32(1), and\nflag field is all Core.Compiler.IR_FLAG_REFINED.\n\nAs such, if you wish to ensure that your IRCode prints nicely, you should ensure that its linetable field has at least one element.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__pop_blk_stack!-Tuple{Mooncake.Stack{Int32}}","page":"Internal Docstrings","title":"Mooncake.__pop_blk_stack!","text":"__pop_blk_stack!(block_stack::BlockStack)\n\nEquivalent to pop!(block_stack). Going via this function, rather than just calling pop! directly, makes it easy to figure out how much time is spent popping the block stack when profiling performance, and to know that this function was hit when debugging.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__push_blk_stack!-Tuple{Mooncake.Stack{Int32}, Int32}","page":"Internal Docstrings","title":"Mooncake.__push_blk_stack!","text":"__push_blk_stack!(block_stack::BlockStack, id::Int32)\n\nEquivalent to push!(block_stack, id). Going via this function, rather than just calling push! directly, is helpful for debugging and performance analysis – it makes it very straightforward to figure out much time is spent pushing to the block stack when profiling.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__switch_case-Tuple{Int32, Int32}","page":"Internal Docstrings","title":"Mooncake.__switch_case","text":"__switch_case(id::Int32, predecessor_id::Int32)\n\nHelper function emitted by make_switch_stmts.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__unflatten_codual_varargs-Union{Tuple{nargs}, Tuple{Bool, Any, Val{nargs}}} where nargs","page":"Internal Docstrings","title":"Mooncake.__unflatten_codual_varargs","text":"__unflatten_codual_varargs(isva::Bool, args, ::Val{nargs}) where {nargs}\n\nIf isva and nargs=2, then inputs (CoDual(5.0, 0.0), CoDual(4.0, 0.0), CoDual(3.0, 0.0)) are transformed into (CoDual(5.0, 0.0), CoDual((5.0, 4.0), (0.0, 0.0))).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__value_and_gradient!!-Union{Tuple{N}, Tuple{R}, Tuple{R, Vararg{Mooncake.CoDual, N}}} where {R, N}","page":"Internal Docstrings","title":"Mooncake.__value_and_gradient!!","text":"__value_and_gradient!!(rule, f::CoDual, x::CoDual...)\n\nNote: this is not part of the public Mooncake.jl interface, and may change without warning.\n\nEquivalent to __value_and_pullback!!(rule, 1.0, f, x...) – assumes f returns a Float64.\n\n# Set up the problem.\nf(x, y) = sum(x .* y)\nx = [2.0, 2.0]\ny = [1.0, 1.0]\nrule = build_rrule(f, x, y)\n\n# Allocate tangents. These will be written to in-place. You are free to re-use these if you\n# compute gradients multiple times.\ntf = zero_tangent(f)\ntx = zero_tangent(x)\nty = zero_tangent(y)\n\n# Do AD.\nMooncake.__value_and_gradient!!(\n    rule, Mooncake.CoDual(f, tf), Mooncake.CoDual(x, tx), Mooncake.CoDual(y, ty)\n)\n# output\n\n(4.0, (NoTangent(), [1.0, 1.0], [2.0, 2.0]))\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.__value_and_pullback!!-Union{Tuple{T}, Tuple{N}, Tuple{R}, Tuple{R, T, Vararg{Mooncake.CoDual, N}}} where {R, N, T}","page":"Internal Docstrings","title":"Mooncake.__value_and_pullback!!","text":"__value_and_pullback!!(rule, ȳ, f::CoDual, x::CoDual...; y_cache=nothing)\n\nNote: this is not part of the public Mooncake.jl interface, and may change without warning.\n\nIn-place version of value_and_pullback!! in which the arguments have been wrapped in CoDuals. Note that any mutable data in f and x will be incremented in-place. As such, if calling this function multiple times with different values of x, should be careful to ensure that you zero-out the tangent fields of x each time.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._add_to_primal","page":"Internal Docstrings","title":"Mooncake._add_to_primal","text":"_add_to_primal(p::P, t::T, unsafe::Bool=false) where {P, T}\n\nAdds t to p, returning a P. It must be the case that tangent_type(P) == T.\n\nIf unsafe is true and P is a composite type, then _add_to_primal will construct a new instance of P by directly invoking the :new instruction for P, rather than attempting to use the default constructor for P. This is fine if you are confident that the new P constructed by adding t to p will always be a valid instance of P, but could cause problems if you are not confident of this.\n\nThis is, for example, fine for the following type:\n\nstruct Foo{T}\n    x::Vector{T}\n    y::Vector{T}\n    function Foo(x::Vector{T}, y::Vector{T}) where {T}\n        @assert length(x) == length(y)\n        return new{T}(x, y)\n    end\nend\n\nHere, the value returned by _add_to_primal will satisfy the invariant asserted in the inner constructor for Foo.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/internal_docstrings/#Mooncake._add_to_primal_internal-Tuple{Union{Mooncake.NoCache, IdDict{Any, Any}}, Any, Mooncake.NoTangent, Bool}","page":"Internal Docstrings","title":"Mooncake._add_to_primal_internal","text":"_add_to_primal_internal(c::MaybeCache, x, t, ::Bool)\n\nImplementation for _add_to_primal. Use c to handle circular referencing and aliasing correctly. If c is a NoCache, assume there is no circular references or aliasing in either x or t.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._copy_output-Tuple{Core.SimpleVector}","page":"Internal Docstrings","title":"Mooncake._copy_output","text":"_copy_output(x::T)\n\nReturns a copy of x, of the same type T. Allocates new memory for the copy. Required as Base.copy() does not work for all supported primal types. For example, Base.copy does not work for Core.svec.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._copy_to_output!!-Tuple{Number, Number}","page":"Internal Docstrings","title":"Mooncake._copy_to_output!!","text":"_copy_to_output!!(dst::T, src::T)\n\nCopy the contents of src to dst, with zero or minimal new memory allocation. The type of dst and src must be the same. Required as Base.copy!() does not work for all supported primal types. For example, Base.copy! does not work for Core.svec.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._diff-Union{Tuple{P}, Tuple{P, P}} where P","page":"Internal Docstrings","title":"Mooncake._diff","text":"_diff(p::P, q::P) where {P}\n\nRequired for testing.\n\nComputes the difference between p and q, which must be of the same type, P. Returns a tangent of type tangent_type(P).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._diff_internal-Union{Tuple{P}, Tuple{Union{Mooncake.NoCache, IdDict{Any, Any}}, P, P}} where P","page":"Internal Docstrings","title":"Mooncake._diff_internal","text":"_diff_internal(c::MaybeCache, p::P, q::P) where {P}\n\nImplmentation for _diff. Use c to correctly handle circular references and aliasing. If c is a NoCache then assume no circular references or aliasing in either p or q.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._dot-Union{Tuple{T}, Tuple{T, T}} where T","page":"Internal Docstrings","title":"Mooncake._dot","text":"_dot(t::T, s::T)::Float64 where {T}\n\nRequired for testing. Should be defined for all standard tangent types.\n\nInner product between tangents t and s. Must return a Float64. Always available because all tangent types correspond to finite-dimensional vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._dot_internal-Tuple{Union{Mooncake.NoCache, IdDict{Any, Any}}, Mooncake.NoTangent, Mooncake.NoTangent}","page":"Internal Docstrings","title":"Mooncake._dot_internal","text":"_dot_internal(c::MaybeCache, t::T, s::T) where {T}\n\nImplementation for _dot. Use c to handle circular references and aliasing. If c is a NoCache, assume that neither t nor s contain either circular references or aliasing.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._findall-Tuple{Any, Tuple}","page":"Internal Docstrings","title":"Mooncake._findall","text":"_findall(cond, x::Tuple)\n\nType-stable version of findall for Tuples. Should constant-fold if cond can be determined from the type of x.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._foreigncall_-Union{Tuple{N}, Tuple{calling_convention}, Tuple{nreq}, Tuple{RT}, Tuple{name}, Tuple{Val{name}, Val{RT}, Tuple, Val{nreq}, Val{calling_convention}, Vararg{Any, N}}} where {name, RT, nreq, calling_convention, N}","page":"Internal Docstrings","title":"Mooncake._foreigncall_","text":"function _foreigncall_(\n    ::Val{name}, ::Val{RT}, AT::Tuple, ::Val{nreq}, ::Val{calling_convention}, x...\n) where {name, RT, nreq, calling_convention}\n\n:foreigncall nodes get translated into calls to this function. For example,\n\nExpr(:foreigncall, :foo, Tout, (A, B), nreq, :ccall, args...)\n\nbecomes\n\n_foreigncall_(Val(:foo), Val(Tout), (Val(A), Val(B)), Val(nreq), Val(:ccall), args...)\n\nPlease consult the Julia documentation for more information on how foreigncall nodes work, and consult this package's tests for examples.\n\nCredit: Umlaut.jl has the original implementation of this function. This is largely copied over from there.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._map-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F, N}","page":"Internal Docstrings","title":"Mooncake._map","text":"_map(f, x...)\n\nSame as map but requires all elements of x to have equal length. The usual function map doesn't enforce this for Arrays.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._map_if_assigned!-Union{Tuple{P}, Tuple{F}, Tuple{F, DenseArray, DenseArray{P}, DenseArray}} where {F, P}","page":"Internal Docstrings","title":"Mooncake._map_if_assigned!","text":"_map_if_assigned!(f::F, y::DenseArray, x1::DenseArray{P}, x2::DenseArray)\n\nSimilar to the other method of _map_if_assigned! – for all n, if x1[n] is assigned, writes f(x1[n], x2[n]) to y[n], otherwise leaves y[n] unchanged.\n\nRequires that y, x1, and x2 have the same size.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._map_if_assigned!-Union{Tuple{P}, Tuple{F}, Tuple{F, DenseArray, DenseArray{P}}} where {F, P}","page":"Internal Docstrings","title":"Mooncake._map_if_assigned!","text":"_map_if_assigned!(f, y::DenseArray, x::DenseArray{P}) where {P}\n\nFor all n, if x[n] is assigned, then writes the value returned by f(x[n]) to y[n], otherwise leaves y[n] unchanged.\n\nEquivalent to map!(f, y, x) if P is a bits type as element will always be assigned.\n\nRequires that y and x have the same size.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._new_-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Any, N}}} where {T, N}","page":"Internal Docstrings","title":"Mooncake._new_","text":"_new_(::Type{T}, x::Vararg{Any, N}) where {T, N}\n\nOne-liner which calls the :new instruction with type T with arguments x.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._scale-Tuple{Float64, Any}","page":"Internal Docstrings","title":"Mooncake._scale","text":"_scale(a::Float64, t::T) where {T}\n\nRequired for testing. Should be defined for all standard tangent types.\n\nMultiply tangent t by scalar a. Always possible because any given tangent type must correspond to a vector field. Not using * in order to avoid piracy.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._scale_internal-Tuple{Union{Mooncake.NoCache, IdDict{Any, Any}}, Float64, Mooncake.NoTangent}","page":"Internal Docstrings","title":"Mooncake._scale_internal","text":"_scale_internal(c::MaybeCache, a::Float64, t)\n\nImplementation for _scale. Use c to handle circular references and aliasing in t. If c is a NoCache assume no circular references or aliasing in c.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._splat_new_-Union{Tuple{P}, Tuple{Type{P}, Tuple}} where P","page":"Internal Docstrings","title":"Mooncake._splat_new_","text":"_splat_new_(::Type{P}, x::Tuple) where {P}\n\nFunction which replaces instances of :splatnew.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake._typeof-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake._typeof","text":"_typeof(x)\n\nCentral definition of typeof, which is specific to the use-required in this package.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.ad_stmt_info-Tuple{Mooncake.BasicBlockCode.ID, Union{Nothing, Mooncake.BasicBlockCode.ID}, Any, Any}","page":"Internal Docstrings","title":"Mooncake.ad_stmt_info","text":"ad_stmt_info(line::ID, comms_id::Union{ID, Nothing}, fwds, rvs)\n\nConvenient constructor for ADStmtInfo. If either fwds or rvs is not a vector, __vec promotes it to a single-element Vector.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.add_data!-Tuple{Mooncake.ADInfo, Any}","page":"Internal Docstrings","title":"Mooncake.add_data!","text":"add_data!(info::ADInfo, data)::ID\n\nEquivalent to add_data!(info.shared_data_pairs, data).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.add_data!-Tuple{Mooncake.SharedDataPairs, Any}","page":"Internal Docstrings","title":"Mooncake.add_data!","text":"add_data!(p::SharedDataPairs, data)::ID\n\nPuts data into p, and returns the id associated to it. This id should be assumed to be available during the forwards- and reverse-passes of AD, and it should further be assumed that the value associated to this id is always data.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.add_data_if_not_singleton!-Tuple{Union{Mooncake.ADInfo, Mooncake.SharedDataPairs}, Any}","page":"Internal Docstrings","title":"Mooncake.add_data_if_not_singleton!","text":"add_data_if_not_singleton!(p::Union{ADInfo, SharedDataPairs}, x)\n\nReturns x if it is a singleton, or the ID of the ssa which will contain it on the forwards- and reverse-passes. The reason for this is that if something is a singleton, it can be inserted directly into the IR.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.always_initialised-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.always_initialised","text":"always_initialised(::Type{P}) where {P}\n\nReturns a tuple with number of fields equal to the number of fields in P. The nth field is set to true if the nth field of P is initialised, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.arrayify-Union{Tuple{Mooncake.CoDual{A}}, Tuple{A}} where A<:(AbstractArray{<:Union{Float32, Float64, ComplexF64, ComplexF32}})","page":"Internal Docstrings","title":"Mooncake.arrayify","text":"arrayify(x::CoDual{<:AbstractArray{<:BlasFloat}})\n\nReturn the primal field of x, and convert its fdata into an array of the same type as the primal. This operation is not guaranteed to be possible for all array types, but seems to be possible for all array types of interest so far.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.build_primitive_rrule-Tuple{Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.build_primitive_rrule","text":"build_primitive_rrule(sig::Type{<:Tuple})\n\nConstruct an rrule for signature sig. For this function to be called in build_rrule, you must also ensure that is_primitive(context_type, sig) is true. The callable returned by this must obey the rrule interface, but there are no restrictions on the type of callable itself. For example, you might return a callable struct. By default, this function returns rrule!! so, most of the time, you should just implement a method of rrule!!.\n\nExtended Help\n\nThe purpose of this function is to permit computation at rule construction time, which can be re-used at runtime. For example, you might wish to derive some information from sig which you use at runtime (e.g. the fdata type of one of the arguments). While constant propagation will often optimise this kind of computation away, it will sometimes fail to do so in hard-to-predict circumstances. Consequently, if you need certain computations not to happen at runtime in order to guarantee good performance, you might wish to e.g. emit a callable struct with type parameters which are the result of this computation. In this context, the motivation for using this function is the same as that of using staged programming (e.g. via @generated functions) more generally.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.build_rrule-Tuple","page":"Internal Docstrings","title":"Mooncake.build_rrule","text":"build_rrule(args...; kwargs...)\n\nHelper method: equivalent to extracting the signature from args and calling build_rrule(sig; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.build_rrule-Tuple{Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.build_rrule","text":"build_rrule(sig::Type{<:Tuple}; kwargs...)\n\nHelper method: Equivalent to build_rrule(Mooncake.get_interpreter(), sig; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.build_rrule-Union{Tuple{C}, Tuple{Mooncake.MooncakeInterpreter{C}, Any}} where C","page":"Internal Docstrings","title":"Mooncake.build_rrule","text":"build_rrule(interp::MooncakeInterpreter{C}, sig_or_mi; debug_mode=false) where {C}\n\nReturns a DerivedRule which is an rrule!! for sig_or_mi in context C. See the docstring for rrule!! for more info.\n\nIf debug_mode is true, then all calls to rules are replaced with calls to DebugRRules.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.can_produce_zero_rdata_from_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.can_produce_zero_rdata_from_type","text":"can_produce_zero_rdata_from_type(::Type{P}) where {P}\n\nReturns whether or not the zero element of the rdata type for primal type P can be obtained from P alone.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.codual_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.codual_type","text":"codual_type(P::Type)\n\nThe type of the CoDual which contains instances of P and associated tangents.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.comms_channel-Tuple{Mooncake.ADStmtInfo}","page":"Internal Docstrings","title":"Mooncake.comms_channel","text":"comms_channel(info::ADStmtInfo)\n\nReturn the element of fwds whose ID is the communcation ID. Returns Nothing if comms_id is nothing.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.conclude_rvs_block-Tuple{Mooncake.BasicBlockCode.BBlock, Vector{Mooncake.BasicBlockCode.ID}, Bool, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.conclude_rvs_block","text":"conclude_rvs_block(\n    blk::BBlock, pred_ids::Vector{ID}, pred_is_unique_pred::Bool, info::ADInfo\n)\n\nGenerates code which is inserted at the end of each counterpart block in the reverse-pass. Handles phi nodes, and choosing the correct next block to switch to.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.const_ad_stmt-Tuple{Any, Mooncake.BasicBlockCode.ID, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.const_ad_stmt","text":"const_ad_stmt(stmt, line::ID, info::ADInfo)\n\nImplementation of make_ad_stmts! used for constants.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.const_codual-Tuple{Any, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.const_codual","text":"const_codual(stmt, info::ADInfo)\n\nBuild a CoDual from stmt, with zero / uninitialised fdata. If the resulting CoDual is a bits type, then it is returned. If it is not, then the CoDual is put into shared data, and the ID associated to it in the forwards- and reverse-passes returned.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.const_codual_stmt-Tuple{Any, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.const_codual_stmt","text":"const_codual_stmt(stmt, info::ADInfo)\n\nReturns a :call expression which will return a CoDual whose primal is stmt, and whose tangent is whatever uninit_tangent returns.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.const_prop_gotoifnots!-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.const_prop_gotoifnots!","text":"const_prop_gotoifnots(ir::IRCode)\n\nReplace all occurences in ir of goto %n if not true in block b with a goto b + 1, and all occurences of goto %n if not false with goto n, and make the adjustments to ir that this necessitates.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.create_comms_insts!-Tuple{Vector{Tuple{Mooncake.BasicBlockCode.ID, Vector{Mooncake.ADStmtInfo}}}, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.create_comms_insts!","text":"create_comms_insts!(ad_stmts_blocks::ADStmts, info::ADInfo)\n\nThis function produces code which can be inserted into the forwards-pass and reverse-pass at specific locations to implement the promise associated to the comms_id field of the ADStmtInfo type – namely that if you assign a value to comms_id on the forwards-pass, the same value will be available at comms_id on the reverse-pass.\n\nFor each basic block represented in ADStmts:\n\ncreate a stack containing a Tuple which can hold all of the values associated to the  comms_ids for each statement. Put this stack in shared data.\ncreate instructions which can be inserted at the end of the block generated to perform  the forwards-pass (in forwards_pass_ir) which will put all of the data associated to  the comms_ids into shared data, and\ncreate instruction which can be inserted at the start of the block generated to perform  the reverse-pass (in pullback_ir), which will extract all of the data put into  shared data by the instructions generated by the previous point, and assigned them to  the comms_ids.\n\nReturns two a Tuple{Vector{IDInstPair}, Vector{IDInstPair}. The nth element of each Vector corresponds to the instructions to be inserted into the forwards- and reverse passes resp. for the nth block in ad_stmts_blocks.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.deref_and_zero_stmts-Tuple{Any, Any, Any}","page":"Internal Docstrings","title":"Mooncake.deref_and_zero_stmts","text":"deref_and_zero_stmts(P, ref_id, val_id)\n\nEquivalent to something like\n\nval = ref[]\nref[] = zero_rdata_from_type(P)\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fcodual_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.fcodual_type","text":"fcodual_type(P::Type)\n\nThe type of the CoDual which contains instances of P and its fdata.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fdata-Tuple{T} where T","page":"Internal Docstrings","title":"Mooncake.fdata","text":"fdata(t)::fdata_type(typeof(t))\n\nExtract the forwards data from tangent t.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fdata_field_type-Union{Tuple{P}, Tuple{Type{P}, Int64}} where P","page":"Internal Docstrings","title":"Mooncake.fdata_field_type","text":"fdata_field_type(::Type{P}, n::Int) where {P}\n\nReturns the type of to the nth field of the fdata type associated to P. Will be a PossiblyUninitTangent if said field can be undefined.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fdata_type-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.fdata_type","text":"fdata_type(T)\n\nReturns the type of the forwards data associated to a tangent of type T.\n\nExtended help\n\nRules in Mooncake.jl do not operate on tangents directly. Rather, functionality is defined to split each tangent into two components, that we call fdata (forwards-pass data) and rdata (reverse-pass data). In short, any component of a tangent which is identified by its address (e.g. a mutable structs or an Array) gets passed around on the forwards-pass of AD and is incremented in-place on the reverse-pass, while components of tangents identified by their value get propagated and accumulated only on the reverse-pass.\n\nGiven a tangent type T, you can find out what type its fdata and rdata must be with fdata_type(T) and rdata_type(T) respectively. A consequence of this is that there is exactly one valid fdata type and rdata type for each primal type.\n\nGiven a tangent t, you can get its fdata and rdata using f = fdata(t) and r = rdata(t) respectively. f and r can be re-combined to recover the original tangent using the binary version of tangent: tangent(f, r). It must always hold that\n\ntangent(fdata(t), rdata(t)) === t\n\nThe need for all of this is explained in the docs, but for now it suffices to consider our running examples again, and to see what their fdata and rdata look like.\n\nInt\n\nInts are non-differentiable types, so there is nothing to pass around on the forwards- or reverse-pass. Therefore\n\njulia> fdata_type(tangent_type(Int)), rdata_type(tangent_type(Int))\n(NoFData, NoRData)\n\nFloat64\n\nThe tangent type of Float64 is Float64. Float64s are identified by their value / have no fixed address, so\n\njulia> (fdata_type(Float64), rdata_type(Float64))\n(NoFData, Float64)\n\nVector{Float64}\n\nThe tangent type of Vector{Float64} is Vector{Float64}. A Vector{Float64} is identified by its address, so\n\njulia> (fdata_type(Vector{Float64}), rdata_type(Vector{Float64}))\n(Vector{Float64}, NoRData)\n\nTuple{Float64, Vector{Float64}, Int}\n\nThis is an example of a type which has both fdata and rdata. The tangent type for Tuple{Float64, Vector{Float64}, Int} is Tuple{Float64, Vector{Float64}, NoTangent}. Tuples have no fixed memory address, so we interogate each field on its own. We have already established the fdata and rdata types for each element, so we recurse to obtain:\n\njulia> T = tangent_type(Tuple{Float64, Vector{Float64}, Int})\nTuple{Float64, Vector{Float64}, NoTangent}\n\njulia> (fdata_type(T), rdata_type(T))\n(Tuple{NoFData, Vector{Float64}, NoFData}, Tuple{Float64, NoRData, NoRData})\n\nThe zero tangent for (5.0, [5.0]) is t = (0.0, [0.0]). fdata(t) returns (NoFData(), [0.0]), where the second element is === to the second element of t. rdata(t) returns (0.0, NoRData()). In this example, t contains a mixture of data, some of which is identified by its value, and some of which is identified by its address, so there is some fdata and some rdata.\n\nStructs\n\nStructs are handled in more-or-less the same way as Tuples, albeit with the possibility of undefined fields needing to be explicitly handled. For example, a struct such as\n\njulia> struct Foo\n           x::Float64\n           y\n           z::Int\n       end\n\nhas tangent type\n\njulia> tangent_type(Foo)\nTangent{@NamedTuple{x::Float64, y, z::NoTangent}}\n\nIts fdata and rdata are given by special FData and RData types:\n\njulia> (fdata_type(tangent_type(Foo)), rdata_type(tangent_type(Foo)))\n(Mooncake.FData{@NamedTuple{x::NoFData, y, z::NoFData}}, Mooncake.RData{@NamedTuple{x::Float64, y, z::NoRData}})\n\nPractically speaking, FData and RData both have the same structure as Tangents and are just used in different contexts.\n\nMutable Structs\n\nThe fdata for a mutable structs is its tangent, and it has no rdata. This is because mutable structs have fixed memory addresses, and can therefore be incremented in-place. For example,\n\njulia> mutable struct Bar\n           x::Float64\n           y\n           z::Int\n       end\n\nhas tangent type\n\njulia> tangent_type(Bar)\nMutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}\n\nand fdata / rdata types\n\njulia> (fdata_type(tangent_type(Bar)), rdata_type(tangent_type(Bar)))\n(MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}, NoRData)\n\nPrimitive Types\n\nAs with tangents, each primitive type must specify what its fdata and rdata is. See specific examples for details.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fix_up_invoke_inference!-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.fix_up_invoke_inference!","text":"fix_up_invoke_inference!(ir::IRCode)\n\nThe Problem\n\nConsider the following:\n\n@noinline function bar!(x)\n    x .*= 2\nend\n\nfunction foo!(x)\n    bar!(x)\n    return nothing\nend\n\nIn this case, the IR associated to Tuple{typeof(foo), Vector{Float64}} will be something along the lines of\n\njulia> Base.code_ircode_by_type(Tuple{typeof(foo), Vector{Float64}})\n1-element Vector{Any}:\n2 1 ─     invoke Main.bar!(_2::Vector{Float64})::Any\n3 └──     return Main.nothing\n   => Nothing\n\nObserve that the type inferred for the first line is Any. Inference is at liberty to do this without any risk of performance problems because the first line is not used anywhere else in the function. Had this line been used elsewhere in the function, inference would have inferred its type to be Vector{Float64}.\n\nThis causes performance problems for Mooncake, because it uses the return type to do various things, including allocating storage for quantities required on the reverse-pass. Consequently, inference infering Any rather than Vector{Float64} causes type instabilities in the code that Mooncake generates, which can have catastrophic conseqeuences for performance.\n\nThe Solution\n\n:invoke expressions contain the Core.MethodInstance associated to them, which contains a Core.CodeCache, which contains the return type of the :invoke. This function looks for :invoke statements whose return type is inferred to be Any in ir, and modifies it to be the return type given by the code cache.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.flat_product-Tuple","page":"Internal Docstrings","title":"Mooncake.flat_product","text":"flat_product(xs...)\n\nEquivalent to vec(collect(Iterators.product(xs...))).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.foreigncall_to_call-Tuple{Any, Dict{Symbol, Core.Compiler.VarState}}","page":"Internal Docstrings","title":"Mooncake.foreigncall_to_call","text":"foreigncall_to_call(inst, sp_map::Dict{Symbol, CC.VarState})\n\nIf inst is a :foreigncall expression translate it into an equivalent :call expression. If anything else, just return inst. See Mooncake._foreigncall_ for details.\n\nsp_map maps the names of the static parameters to their values. This function is intended to be called in the context of an IRCode, in which case the values of sp_map are given by the sptypes field of said IRCode. The keys should generally be obtained from the Method from which the IRCode is derived. See Mooncake.normalise! for more details.\n\nThe purpose of this transformation is to make it possible to differentiate :foreigncall expressions in the same way as a primitive :call expression, i.e. via an rrule!!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.forwards_pass_ir-Tuple{Mooncake.BasicBlockCode.BBCode, Vector{Tuple{Mooncake.BasicBlockCode.ID, Vector{Mooncake.ADStmtInfo}}}, Any, Mooncake.ADInfo, Any}","page":"Internal Docstrings","title":"Mooncake.forwards_pass_ir","text":"forwards_pass_ir(ir::BBCode, ad_stmts_blocks::ADStmts, info::ADInfo, Tshared_data)\n\nProduce the IR associated to the OpaqueClosure which runs most of the forwards-pass.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.fwd_ir-Tuple{Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.fwd_ir","text":"fwd_ir(\n    sig::Type{<:Tuple};\n    interp=get_interpreter(), debug_mode::Bool=false, do_inline::Bool=true\n)::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as part of a non-breaking release of the package.\n\nGenerate the Core.Compiler.IRCode used to construct the forwards-pass of AD. Take a look at how build_rrule makes use of generate_ir to see exactly how this is used in practice.\n\nFor example, if you wanted to get the IR associated to the forwards pass for the call map(sin, randn(10)), you could do either of the following:\n\njulia> Mooncake.fwd_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.fwd_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\nArguments\n\nsig::Type{<:Tuple}: the signature of the call to be differentiated.\n\nKeyword Arguments\n\ninterp: the interpreter to use to obtain the primal IR.\ndebug_mode::Bool: whether the generated IR should make use of Mooncake's debug mode.\ndo_inline::Bool: whether to apply an inlining pass prior to returning the ir generated   by this function. This is true by default, but setting it to false can sometimes be   helpful if you need to understand what function calls are generated in order to perform   AD, before lots of it gets inlined away.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.gc_preserve-Tuple","page":"Internal Docstrings","title":"Mooncake.gc_preserve","text":"gc_preserve(xs...)\n\nA no-op function. Its rrule!! ensures that the memory associated to xs is not freed until the pullback that it returns is run.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.generate_ir-Tuple{Mooncake.MooncakeInterpreter, Any}","page":"Internal Docstrings","title":"Mooncake.generate_ir","text":"generate_ir(\n    interp::MooncakeInterpreter, sig_or_mi; debug_mode=false, do_inline=true\n)\n\nUsed by build_rrule, and the various debugging tools: primalir, fwdsir, adjoint_ir.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.get_const_primal_value-Tuple{GlobalRef}","page":"Internal Docstrings","title":"Mooncake.get_const_primal_value","text":"get_const_primal_value(x::GlobalRef)\n\nGet the value associated to x. For GlobalRefs, verify that x is indeed a constant.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.get_interpreter-Tuple{}","page":"Internal Docstrings","title":"Mooncake.get_interpreter","text":"get_interpreter()\n\nReturns a MooncakeInterpreter appropriate for the current world age. Will use a cached interpreter if one already exists for the current world age, otherwise creates a new one.\n\nThis should be prefered over constructing a MooncakeInterpreter directly.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.get_primal_type-Tuple{Mooncake.ADInfo, Core.Argument}","page":"Internal Docstrings","title":"Mooncake.get_primal_type","text":"get_primal_type(info::ADInfo, x)\n\nReturns the static / inferred type associated to x.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.get_rev_data_id-Tuple{Mooncake.ADInfo, Core.Argument}","page":"Internal Docstrings","title":"Mooncake.get_rev_data_id","text":"get_rev_data_id(info::ADInfo, x)\n\nReturns the ID associated to the line in the reverse pass which will contain the reverse data for x. If x is not an Argument or ID, then nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.get_tangent_field-Tuple{Union{Mooncake.MutableTangent{T}, Mooncake.Tangent{T}} where T, Int64}","page":"Internal Docstrings","title":"Mooncake.get_tangent_field","text":"get_tangent_field(t::Union{MutableTangent, Tangent}, i::Int)\n\nGets the ith field of data in t.\n\nHas the same semantics that getfield! would have if the data in the fields field of t were actually fields of t. This is the moral equivalent of getfield for MutableTangent.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.inc_args-Tuple{Expr}","page":"Internal Docstrings","title":"Mooncake.inc_args","text":"inc_args(stmt)\n\nIncrement by 1 the n field of any Arguments present in stmt. Used in make_ad_stmts!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment!!-Union{Tuple{T}, Tuple{T, T}} where T","page":"Internal Docstrings","title":"Mooncake.increment!!","text":"increment!!(x::T, y::T) where {T}\n\nAdd x to y. If ismutabletype(T), then increment!!(x, y) === x must hold. That is, increment!! will mutate x. This must apply recursively if T is a composite type whose fields are mutable.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment_and_get_rdata!-Union{Tuple{T}, Tuple{Mooncake.NoFData, T, T}} where T<:Union{Float16, Float32, Float64}","page":"Internal Docstrings","title":"Mooncake.increment_and_get_rdata!","text":"increment_and_get_rdata!(fdata, zero_rdata, cr_tangent)\n\nIncrement fdata by the fdata component of the ChainRules.jl-style tangent, cr_tangent, and return the rdata component of cr_tangent by adding it to zero_rdata.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment_field!!-Union{Tuple{i}, Tuple{Tuple, Any, Val{i}}} where i","page":"Internal Docstrings","title":"Mooncake.increment_field!!","text":"increment_field!!(x::T, y::V, f) where {T, V}\n\nincrement!! the field f of x by y, and return the updated x.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment_internal!!-Tuple{Union{Mooncake.NoCache, IdDict{Any, Bool}}, Mooncake.NoTangent, Mooncake.NoTangent}","page":"Internal Docstrings","title":"Mooncake.increment_internal!!","text":"increment_internal!!(c::IncCache, x::T, y::T) where {T}\n\nImplementation of Mooncake.increment!!. Make use the cache c to avoid \"double counting\". If c is a NoCache, assume no aliasing or circular referencing.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment_rdata!!-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Internal Docstrings","title":"Mooncake.increment_rdata!!","text":"increment_rdata!!(t::T, r)::T where {T}\n\nIncrement the rdata component of tangent t by r, and return the updated tangent. Useful for implementation getfield-like rules for mutable structs, pointers, dicts, etc.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.increment_ref_stmts-Tuple{Mooncake.BasicBlockCode.ID, Any}","page":"Internal Docstrings","title":"Mooncake.increment_ref_stmts","text":"increment_ref_stmts(ref_id::ID, inc_data)::Vector{IDInstPair}\n\nEquivalent to ref[] = increment!!(ref[], inc_data), where ref and inc_data are the values associated to ref_id and inc_data respectively.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.infer_ir!-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.infer_ir!","text":"infer_ir!(ir::IRCode) -> IRCode\n\nRuns type inference on ir, which mutates ir, and returns it.\n\nNote: the compiler will not infer the types of anything where the corrsponding element of ir.stmts.flag is not set to Core.Compiler.IR_FLAG_REFINED. Nor will it attempt to refine the type of the value returned by a :invoke expressions. Consequently, if you find that the types in your IR are not being refined, you may wish to check that neither of these things are happening.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.interpolate_boundschecks!-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.interpolate_boundschecks!","text":"interpolate_boundschecks!(ir::IRCode)\n\nFor every x = Expr(:boundscheck, value) in ir, interpolate value into all uses of x. This is only required in order to ensure that literal versions of memoryrefget, memoryrefset!, getfield, and setfield! work effectively. If they are removed through improvements to the way that we handle constant propagation inside Mooncake, then this functionality can be removed.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.intrinsic_to_function-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.intrinsic_to_function","text":"intrinsic_to_function(inst)\n\nIf inst is a :call expression to a Core.IntrinsicFunction, replace it with a call to the corresponding function from Mooncake.IntrinsicsWrappers, else return inst.\n\ncglobal is a special case – it requires that its first argument be static in exactly the same way as :foreigncall. See IntrinsicsWrappers.__cglobal for more info.\n\nThe purpose of this transformation is to make it possible to use dispatch to write rules for intrinsic calls using dispatch in a type-stable way. See IntrinsicsWrappers for more context.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.ircode","page":"Internal Docstrings","title":"Mooncake.ircode","text":"ircode(\n    inst::Vector{Any},\n    argtypes::Vector{Any},\n    sptypes::Vector{CC.VarState}=CC.VarState[],\n) -> IRCode\n\nConstructs an instance of an IRCode. This is useful for constructing test cases with known properties.\n\nNo optimisations or type inference are performed on the resulting IRCode, so that the IRCode contains exactly what is intended by the caller. Please make use of infer_types! if you require the types to be inferred.\n\nEdges in PhiNodes, GotoIfNots, and GotoNodes found in inst must refer to lines (as in CodeInfo). In the IRCode returned by this function, these line references are translated into block references.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_always_fully_initialised-Tuple{DataType}","page":"Internal Docstrings","title":"Mooncake.is_always_fully_initialised","text":"is_always_fully_initialised(P::DataType)::Bool\n\nTrue if all fields in P are always initialised. Put differently, there are no inner constructors which permit partial initialisation.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_always_initialised-Tuple{DataType, Int64}","page":"Internal Docstrings","title":"Mooncake.is_always_initialised","text":"is_always_initialised(P::DataType, n::Int)::Bool\n\nTrue if the nth field of P is always initialised. If the nth fieldtype of P isbitstype, then this is distinct from asking whether the nth field is always defined. An isbits field is always defined, but is not always explicitly initialised.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_primitive-Tuple{Type{Mooncake.MinimalCtx}, Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.is_primitive","text":"is_primitive(::Type{Ctx}, sig) where {Ctx}\n\nReturns a Bool specifying whether the methods specified by sig are considered primitives in the context of contexts of type Ctx.\n\nis_primitive(DefaultCtx, Tuple{typeof(sin), Float64})\n\nwill return if calling sin(5.0) should be treated as primitive when the context is a DefaultCtx.\n\nObserve that this information means that whether or not something is a primitive in a particular context depends only on static information, not any run-time information that might live in a particular instance of Ctx.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_unreachable_return_node-Tuple{Core.ReturnNode}","page":"Internal Docstrings","title":"Mooncake.is_unreachable_return_node","text":"is_unreachable_return_node(x::ReturnNode)\n\nDetermine whehter x is a ReturnNode, and if it is, if it is also unreachable. This is purely a function of whether or not its val field is defined or not.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_used-Tuple{Mooncake.ADInfo, Mooncake.BasicBlockCode.ID}","page":"Internal Docstrings","title":"Mooncake.is_used","text":"is_used(info::ADInfo, id::ID)::Bool\n\nReturns true if id is used by any of the lines in the ir, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_vararg_and_sparam_names-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.is_vararg_and_sparam_names","text":"is_vararg_and_sparam_names(sig)::Tuple{Bool, Vector{Symbol}}\n\nFinds the method associated to sig, and calls is_vararg_and_sparam_names on it.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_vararg_and_sparam_names-Tuple{Core.MethodInstance}","page":"Internal Docstrings","title":"Mooncake.is_vararg_and_sparam_names","text":"is_vararg_and_sparam_names(mi::Core.MethodInstance)\n\nCalls is_vararg_and_sparam_names on mi.def::Method.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.is_vararg_and_sparam_names-Tuple{Method}","page":"Internal Docstrings","title":"Mooncake.is_vararg_and_sparam_names","text":"is_vararg_and_sparam_names(m::Method)\n\nReturns a 2-tuple. The first element is true if m is a vararg method, and false if not. The second element contains the names of the static parameters associated to m.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lgetfield-Union{Tuple{f}, Tuple{Any, Val{f}}} where f","page":"Internal Docstrings","title":"Mooncake.lgetfield","text":"lgetfield(x, f::Val)\n\nAn implementation of getfield in which the the field f is specified statically via a Val. This enables the implementation to be type-stable even when it is not possible to constant-propagate f. Moreover, it enable the pullback to also be type-stable.\n\nIt will always be the case that\n\ngetfield(x, :f) === lgetfield(x, Val(:f))\ngetfield(x, 2) === lgetfield(x, Val(2))\n\nThis approach is identical to the one taken by Zygote.jl to circumvent the same problem. Zygote.jl calls the function literal_getfield, while we call it lgetfield.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lgetfield-Union{Tuple{order}, Tuple{f}, Tuple{Any, Val{f}, Val{order}}} where {f, order}","page":"Internal Docstrings","title":"Mooncake.lgetfield","text":"lgetfield(x, ::Val{f}, ::Val{order}) where {f, order}\n\nLike getfield, but with the field and access order encoded as types.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lift_gc_preservation-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.lift_gc_preservation","text":"lift_gc_preserve(inst)\n\nExpressions of the form\n\ny = GC.@preserve x1 x2 foo(args...)\n\nget lowered to\n\ntoken = Expr(:gc_preserve_begin, x1, x2)\ny = expr\nExpr(:gc_preserve_end, token)\n\nThese expressions guarantee that any memory associated x1 and x2 not be freed until the :gc_preserve_end expression is reached.\n\nIn the context of reverse-mode AD, we must ensure that the memory associated to x1, x2 and their fdata is available during the reverse pass code associated to expr. We do this by preventing the memory from being freed until the :gc_preserve_begin is reached on the reverse pass.\n\nTo achieve this, we replace the primal code with\n\n# store `x` in `pb_gc_preserve` to prevent it from being freed.\n_, pb_gc_preserve = rrule!!(zero_fcodual(gc_preserve), x1, x2)\n\n# Differentiate the `:call` expression in the usual way.\ny, foo_pb = rrule!!(zero_fcodual(foo), args...)\n\n# Do not permit the GC to free `x` here.\nnothing\n\nThe pullback should be something along the lines of\n\n# no pullback associated to `nothing`.\nnothing\n\n# Run the pullback associated to `foo` in the usual manner. `x` must be available.\n_, dargs... = foo_pb(dy)\n\n# No-op pullback associated to `gc_preserve`.\npb_gc_preserve(NoRData())\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lift_getfield_and_others-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.lift_getfield_and_others","text":"lift_getfield_and_others(inst)\n\nConverts expressions of the form getfield(x, :a) into lgetfield(x, Val(:a)). This has identical semantics, but is performant in the absence of proper constant propagation.\n\nDoes the same for...\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lookup_ir-Tuple{Core.Compiler.AbstractInterpreter, Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.lookup_ir","text":"lookup_ir(\n    interp::AbstractInterpreter,\n    sig_or_mi::Union{Type{<:Tuple}, Core.MethodInstance},\n)::Tuple{IRCode, T}\n\nGet the unique IR associated to sig_or_mi under interp. Throws ArgumentErrors if there is no code found, or if more than one IRCode instance returned.\n\nReturns a tuple containing the IRCode and its return type.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.lsetfield!-Union{Tuple{name}, Tuple{Any, Val{name}, Any}} where name","page":"Internal Docstrings","title":"Mooncake.lsetfield!","text":"lsetfield!(value, name::Val, x, [order::Val])\n\nThis function is to setfield! what lgetfield is to getfield. It will always hold that\n\nsetfield!(copy(x), :f, v) == lsetfield!(copy(x), Val(:f), v)\nsetfield!(copy(x), 2, v) == lsetfield(copy(x), Val(2), v)\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.make_ad_stmts!","page":"Internal Docstrings","title":"Mooncake.make_ad_stmts!","text":"make_ad_stmts!(inst::NewInstruction, line::ID, info::ADInfo)::ADStmtInfo\n\nEvery line in the primal code is associated to one or more lines in the forwards-pass of AD, and one or more lines in the pullback. This function has method specific to every node type in the Julia SSAIR.\n\nTranslates the instruction inst, associated to line in the primal, into a specification of what should happen for this instruction in the forwards- and reverse-passes of AD, and what data should be shared between the forwards- and reverse-passes. Returns this in the form of an ADStmtInfo.\n\ninfo is a data structure containing various bits of global information that certain types of nodes need access to.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/internal_docstrings/#Mooncake.make_switch_stmts-Tuple{Vector{Mooncake.BasicBlockCode.ID}, Vector{Mooncake.BasicBlockCode.ID}, Bool, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.make_switch_stmts","text":"make_switch_stmts(\n    pred_ids::Vector{ID}, target_ids::Vector{ID}, pred_is_unique_pred::Bool, info::ADInfo\n)\n\npreds_ids comprises the IDs associated to all possible predecessor blocks to the primal block under consideration. Suppose its value is [ID(1), ID(2), ID(3)], then make_switch_stmts emits code along the lines of\n\nprev_block = pop!(block_stack)\nnot_pred_was_1 = !(prev_block == ID(1))\nnot_pred_was_2 = !(prev_block == ID(2))\nswitch(\n    not_pred_was_1 => ID(1),\n    not_pred_was_2 => ID(2),\n    ID(3)\n)\n\nIn words: make_switch_stmts emits code which jumps to whichever block preceded the current block during the forwards-pass.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.map_prod-Tuple{Any, Vararg{Any}}","page":"Internal Docstrings","title":"Mooncake.map_prod","text":"map_prod(f, xs...)\n\nEquivalent to map(f, flat_product(xs...)).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.misty_closure-Tuple{Type, Core.Compiler.IRCode, Vararg{Any}}","page":"Internal Docstrings","title":"Mooncake.misty_closure","text":"misty_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)\n\nIdentical to Mooncake.opaque_closure, but returns a MistyClosure closure rather than a Core.OpaqueClosure.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.new_to_call-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.new_to_call","text":"new_to_call(x)\n\nIf instruction x is a :new expression, replace it with a :call to Mooncake._new_. Otherwise, return x.\n\nThe purpose of this transformation is to make it possible to differentiate :new expressions in the same way as a primitive :call expression, i.e. via an rrule!!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.normalise!-Tuple{Core.Compiler.IRCode, Vector{Symbol}}","page":"Internal Docstrings","title":"Mooncake.normalise!","text":"normalise!(ir::IRCode, spnames::Vector{Symbol})\n\nApply a sequence of standardising transformations to ir which leaves its semantics unchanged, but makes AD more straightforward. In particular, replace\n\n:foreigncall Exprs with :calls to Mooncake._foreigncall_,\n:new Exprs with :calls to Mooncake._new_,\n:splatnew Exprs with:calls toMooncake.splatnew_`,\nCore.IntrinsicFunctions with counterparts from Mooncake.IntrinsicWrappers,\ngetfield(x, 1) with lgetfield(x, Val(1)), and related transformations,\nmemoryrefget calls to lmemoryrefget calls, and related transformations,\ngc_preserve_begin / gc_preserve_end exprs so that memory release is delayed.\n\nspnames are the names associated to the static parameters of ir. These are needed when handling :foreigncall expressions, in which it is not necessarily the case that all static parameter names have been translated into either types, or :static_parameter expressions.\n\nUnfortunately, the static parameter names are not retained in IRCode, and the Method from which the IRCode is derived must be consulted. Mooncake.is_vararg_and_sparam_names provides a convenient way to do this.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.opaque_closure-Tuple{Type, Core.Compiler.IRCode, Vararg{Any}}","page":"Internal Docstrings","title":"Mooncake.opaque_closure","text":"opaque_closure(\n    ret_type::Type,\n    ir::IRCode,\n    @nospecialize env...;\n    isva::Bool=false,\n    do_compile::Bool=true,\n)::Core.OpaqueClosure{<:Tuple, ret_type}\n\nConstruct a Core.OpaqueClosure. Almost equivalent to Core.OpaqueClosure(ir, env...; isva, do_compile), but instead of letting Core.compute_oc_rettype figure out the return type from ir, impose ret_type as the return type.\n\nWarning\n\nUser beware: if the Core.OpaqueClosure produced by this function ever returns anything which is not an instance of a subtype of ret_type, you should expect all kinds of awful things to happen, such as segfaults. You have been warned!\n\nExtended Help\n\nThis is needed in Mooncake.jl because make extensive use of our ability to know the return type of a couple of specific OpaqueClosures without actually having constructed them – see LazyDerivedRule. Without the capability to specify the return type, we have to guess what type compute_ir_rettype will return for a given IRCode before we have constructed the IRCode and run type inference on it. This exposes us to details of type inference, which are not part of the public interface of the language, and can therefore vary from Julia version to Julia version (including patch versions). Moreover, even for a fixed Julia version it can be extremely hard to predict exactly what type inference will infer to be the return type of a function.\n\nFailing to correctly guess the return type can happen for a number of reasons, and the kinds of errors that tend to be generated when this fails tell you very little about the underlying cause of the problem.\n\nBy specifying the return type ourselves, we remove this dependence. The price we pay for this is the potential for segfaults etc if we fail to specify ret_type correctly.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.optimise_ir!-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.optimise_ir!","text":"optimise_ir!(ir::IRCode, show_ir=false)\n\nRun a fairly standard optimisation pass on ir. If show_ir is true, displays the IR to stdout at various points in the pipeline – this is sometimes useful for debugging.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.primal_ir-Tuple{Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.primal_ir","text":"primal_ir(sig::Type{<:Tuple}; interp=get_interpreter())::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as  part of a non-breaking release of the package.\n\nGet the Core.Compiler.IRCode associated to sig from which the a rule can be derived. Roughly equivalent to Base.code_ircode_by_type(sig; interp).\n\nFor example, if you wanted to get the IR associated to the call map(sin, randn(10)), you could do one of the following calls:\n\njulia> Mooncake.primal_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.primal_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.pullback_ir-Tuple{Mooncake.BasicBlockCode.BBCode, Any, Vector{Tuple{Mooncake.BasicBlockCode.ID, Vector{Mooncake.ADStmtInfo}}}, Any, Mooncake.ADInfo, Any}","page":"Internal Docstrings","title":"Mooncake.pullback_ir","text":"pullback_ir(ir::BBCode, Tret, ad_stmts_blocks::ADStmts, info::ADInfo, Tshared_data)\n\nProduce the IR associated to the OpaqueClosure which runs most of the pullback.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.pullback_type-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.pullback_type","text":"pullback_type(Trule, arg_types)\n\nGet a bound on the pullback type, given a rule and associated primal types.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.randn_tangent-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.randn_tangent","text":"randn_tangent(rng::AbstractRNG, x::P) where {P}\n\nRequired for testing. Generate a randomly-chosen tangent to x. Very similar to Mooncake.zero_tangent, except that the elements are randomly chosen, rather than being equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.randn_tangent_internal-Union{Tuple{P}, Tuple{Random.AbstractRNG, P, Union{Mooncake.NoCache, IdDict{Any, Any}}}} where P<:Union{Float16, Float32, Float64}","page":"Internal Docstrings","title":"Mooncake.randn_tangent_internal","text":"randn_tangent_internal(rng::AbstractRNG, x, dict::MaybeCache)\n\nImplementation for Mooncake.randn_tangent. Please consult the docstring for zero_tangent_internal for more information on how this implementation works, As the same implementation strategy is adopted for both this function and that one.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rdata-Tuple{T} where T","page":"Internal Docstrings","title":"Mooncake.rdata","text":"rdata(t)::rdata_type(typeof(t))\n\nExtract the reverse data from tangent t.\n\nExtended help\n\nSee extended help section of fdata_type.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rdata_backing_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.rdata_backing_type","text":"rdata_backing_type(::Type{P}) where {P}\n\nThe type of the field of RData for P.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rdata_field_type-Union{Tuple{P}, Tuple{Type{P}, Int64}} where P","page":"Internal Docstrings","title":"Mooncake.rdata_field_type","text":"rdata_field_type(::Type{P}, n::Int) where {P}\n\nReturns the type of to the nth field of the rdata type associated to P. Will be a PossiblyUninitTangent if said field can be undefined.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rdata_field_types_exprs-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.rdata_field_types_exprs","text":"rdata_field_types_exprs(::Type{P}) where {P}\n\nTuple of expressions. The nth computes the rdata backing type of the nth field of P.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rdata_type-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.rdata_type","text":"rdata_type(T)\n\nReturns the type of the reverse data of a tangent of type T.\n\nExtended help\n\nSee extended help in fdata_type docstring.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.remove_edge!-Tuple{Core.Compiler.IRCode, Int64, Int64}","page":"Internal Docstrings","title":"Mooncake.remove_edge!","text":"remove_edge!(ir::IRCode, from::Int, to::Int)\n\nRemoves an edge in ir from from to to. See implementation for what this entails.\n\nNote: this is slightly different from Core.Compiler.kill_edge!, in that it also updates PhiNodes in the to block. Moreover, the available methods of remove_edge! differ between 1.10 and 1.11, so we need something which is stable across both.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.replace_captures-Union{Tuple{Tmc}, Tuple{Tmc, Any}} where Tmc<:MistyClosures.MistyClosure","page":"Internal Docstrings","title":"Mooncake.replace_captures","text":"replace_captures(mc::Tmc, new_captures) where {Tmc<:MistyClosure}\n\nSame as replace_captures for Core.OpaqueClosures, but returns a new MistyClosure.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.replace_captures-Union{Tuple{Toc}, Tuple{Toc, Any}} where Toc<:Core.OpaqueClosure","page":"Internal Docstrings","title":"Mooncake.replace_captures","text":"replace_captures(oc::Toc, new_captures) where {Toc<:OpaqueClosure}\n\nGiven an OpaqueClosure oc, create a new OpaqueClosure of the same type, but with new captured variables. This is needed for efficiency reasons – if build_rrule is called repeatedly with the same signature and intepreter, it is important to avoid recompiling the OpaqueClosures that it produces multiple times, because it can be quite expensive to do so.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.replace_uses_with!-Tuple{Any, Union{Core.Argument, Core.SSAValue}, Any}","page":"Internal Docstrings","title":"Mooncake.replace_uses_with!","text":"replace_uses_with!(stmt, def::Union{Argument, SSAValue}, val)\n\nReplace all uses of def with val in the single statement stmt. Note: this function is highly incomplete, really only working correctly for a specific function in ir_normalisation.jl. You probably do not want to use it.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.reverse_data_ref_stmts-Tuple{Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.reverse_data_ref_stmts","text":"reverse_data_ref_stmts(info::ADInfo)\n\nCreate the :new statements which initialise the reverse-data Refs. Interpolates the initial rdata directly into the statement, which is safe because it is always a bits type.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rrule!!","page":"Internal Docstrings","title":"Mooncake.rrule!!","text":"rrule!!(f::CoDual, x::CoDual...)\n\nPerforms the forwards-pass of AD. The tangent field of f and each x should contain the forwards tangent data (fdata) associated to each corresponding primal field.\n\nReturns a 2-tuple. The first element, y, is a CoDual whose primal field is the value associated to running f.primal(map(x -> x.primal, x)...), and whose tangent field is its associated fdata. The second element contains the pullback, which runs the reverse-pass. It maps from the rdata associated to y to the rdata associated to f and each x.\n\nusing Mooncake: zero_fcodual, CoDual, NoFData, rrule!!\ny, pb!! = rrule!!(zero_fcodual(sin), CoDual(5.0, NoFData()))\npb!!(1.0)\n\n# output\n\n(NoRData(), 0.28366218546322625)\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rrule_wrapper-Union{NTuple{N, Mooncake.CoDual}, Tuple{N}} where N","page":"Internal Docstrings","title":"Mooncake.rrule_wrapper","text":"rrule_wrapper(f::CoDual, args::CoDual...)\n\nUsed to implement rrule!!s via ChainRulesCore.rrule.\n\nGiven a function foo, argument types arg_types, and a method of ChainRulesCore.rrule which applies to these, you can make use of this function as follows:\n\nMooncake.@is_primitive DefaultCtx Tuple{typeof(foo), arg_types...}\nfunction Mooncake.rrule!!(f::CoDual{typeof(foo)}, args::CoDual...)\n    return rrule_wrapper(f, args...)\nend\n\nAssumes that methods of to_cr_tangent and to_mooncake_tangent are defined such that you can convert between the different representations of tangents that Mooncake and ChainRulesCore expect.\n\nFurthermore, it is essential that\n\nf(args) does not mutate f or args, and\nthe result of f(args) does not alias any data stored in f or args.\n\nSubject to some constraints, you can use the @from_rrule macro to reduce the amount of boilerplate code that you are required to write even further.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rule_type-Union{Tuple{C}, Tuple{Mooncake.MooncakeInterpreter{C}, Any}} where C","page":"Internal Docstrings","title":"Mooncake.rule_type","text":"rule_type(interp::MooncakeInterpreter{C}, sig_or_mi; debug_mode) where {C}\n\nCompute the concrete type of the rule that will be returned from build_rrule. This is important for performance in dynamic dispatch, and to ensure that recursion works properly.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rvs_ir-Tuple{Type{<:Tuple}}","page":"Internal Docstrings","title":"Mooncake.rvs_ir","text":"rvs_ir(\n    sig::Type{<:Tuple};\n    interp=get_interpreter(), debug_mode::Bool=false, do_inline::Bool=true\n)::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as part of a non-breaking release of the package.\n\nGenerate the Core.Compiler.IRCode used to construct the reverse-pass of AD. Take a look at how build_rrule makes use of generate_ir to see exactly how this is used in practice.\n\nFor example, if you wanted to get the IR associated to the reverse pass for the call map(sin, randn(10)), you could do either of the following:\n\njulia> Mooncake.rvs_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.rvs_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\nArguments\n\nsig::Type{<:Tuple}: the signature of the call to be differentiated.\n\nKeyword Arguments\n\ninterp: the interpreter to use to obtain the primal IR.\ndebug_mode::Bool: whether the generated IR should make use of Mooncake's debug mode.\ndo_inline::Bool: whether to apply an inlining pass prior to returning the ir generated   by this function. This is true by default, but setting it to false can sometimes be   helpful if you need to understand what function calls are generated in order to perform   AD, before lots of it gets inlined away.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.rvs_phi_block-Tuple{Mooncake.BasicBlockCode.ID, Vector{Mooncake.BasicBlockCode.ID}, Vector{Any}, Mooncake.ADInfo}","page":"Internal Docstrings","title":"Mooncake.rvs_phi_block","text":"rvs_phi_block(pred_id::ID, rdata_ids::Vector{ID}, values::Vector{Any}, info::ADInfo)\n\nProduces a BBlock which runs the reverse-pass for the edge associated to pred_id in a collection of IDPhiNodes, and then goes to the block associated to pred_id.\n\nFor example, suppose that we encounter the following collection of PhiNodes at the start of some block:\n\n%6 = φ (#2 => _1, #3 => %5)\n%7 = φ (#2 => 5., #3 => _2)\n\nLet the rdata refs associated to %6, %7, and _1be denotedr%6,r%7, andr1resp., and letpredidbe#2, andincrement_ref!` be the following function,\n\nincrement_ref!(ref, x) = ref[] = increment!!(ref[], x)\n\nthen this rvs_phi_block will produce a basic block of the form\n\nincrement_ref!(r_1, r%6)\nnothing\ngoto #2\n\nThe call to increment_ref! appears because _1 is the value associated to%6 when the primal code comes from #2. Similarly, the goto #2 statement appears because we came from #2 on the forwards-pass. There is no increment_ref! associated to %7 because 5. is a constant. We emit a nothing statement, which the compiler will happily optimise away later on.\n\nThe same ideas apply if pred_id were #3. The block would end with #3, and there would be two increment_ref! calls because both %5 and _2 are not constants.\n\nIn practice, code which is equivalent to increment_ref! is created directly, rather than inserting a call to a generic Julia function. This is because we need to be certain that the getfield and setfield! calls applied to any references are visible to the SROA optimisation pass. If we insert a call to a function like increment_ref!, it might not be inlined away, making such references opaque.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.set_tangent_field!-Union{Tuple{Tfields}, Tuple{Mooncake.MutableTangent{Tfields}, Int64, Any}} where Tfields","page":"Internal Docstrings","title":"Mooncake.set_tangent_field!","text":"set_tangent_field!(t::MutableTangent{Tfields}, i::Int, x) where {Tfields}\n\nSets the value of the ith field of the data in t to value x.\n\nHas the same semantics that setfield! would have if the data in the fields field of t were actually fields of t. This is the moral equivalent of setfield! for MutableTangent.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.set_to_zero!!-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.set_to_zero!!","text":"set_to_zero!!(x)\n\nSet x to its zero element (x should be a tangent, so the zero must exist).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.set_to_zero_internal!!-Tuple{Union{Mooncake.NoCache, IdDict{Any, Bool}}, Mooncake.NoTangent}","page":"Internal Docstrings","title":"Mooncake.set_to_zero_internal!!","text":"set_to_zero_internal!!(c::IncCache, x)\n\nImplementation for Mooncake.set_to_zero!!. Use c to ensure that circular references are correctly handled. If c is a NoCache, assume no circular references.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.shared_data_stmts-Tuple{Mooncake.SharedDataPairs}","page":"Internal Docstrings","title":"Mooncake.shared_data_stmts","text":"shared_data_stmts(p::SharedDataPairs)::Vector{IDInstPair}\n\nProduce a sequence of id-statment pairs which will extract the data from shared_data_tuple(p) such that the correct value is associated to the correct ID.\n\nFor example, if p.pairs is\n\n[(ID(5), 5.0), (ID(3), \"hello\")]\n\nthen the output of this function is\n\nIDInstPair[\n    (ID(5), new_inst(:(getfield(_1, 1)))),\n    (ID(3), new_inst(:(getfield(_1, 2)))),\n]\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.shared_data_tuple-Tuple{Mooncake.SharedDataPairs}","page":"Internal Docstrings","title":"Mooncake.shared_data_tuple","text":"shared_data_tuple(p::SharedDataPairs)::Tuple\n\nCreate the tuple that will constitute the captured variables in the forwards- and reverse- pass OpaqueClosures.\n\nFor example, if p.pairs is\n\n[(ID(5), 5.0), (ID(3), \"hello\")]\n\nthen the output of this function is\n\n(5.0, \"hello\")\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.sparam_names-Tuple{Method}","page":"Internal Docstrings","title":"Mooncake.sparam_names","text":"sparam_names(m::Core.Method)::Vector{Symbol}\n\nReturns the names of all of the static parameters in m.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.splatnew_to_call-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.splatnew_to_call","text":"splatnew_to_call(x)\n\nIf instruction x is a :splatnew expression, replace it with a :call to Mooncake._splat_new_. Otherwise return x.\n\nThe purpose of this transformation is to make it possible to differentiate :splatnew expressions in the same way as a primitive :call expression, i.e. via an rrule!!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.stable_all-Union{Tuple{NTuple{N, Bool}}, Tuple{N}} where N","page":"Internal Docstrings","title":"Mooncake.stable_all","text":"stable_all(x::NTuple{N, Bool}) where {N}\n\nall(x::NTuple{N, Bool}) does not constant-fold nicely on 1.10 if the values of x are known statically. This implementation constant-folds nicely on both 1.10 and 1.11, so can be used in its place in situations where this is important.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.stmt-Tuple{Core.Compiler.InstructionStream}","page":"Internal Docstrings","title":"Mooncake.stmt","text":"stmt(ir::CC.InstructionStream)\n\nGet the field containing the instructions in ir. This changed name in 1.11 from inst to stmt.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.tangent-Tuple{Mooncake.NoFData, Mooncake.NoRData}","page":"Internal Docstrings","title":"Mooncake.tangent","text":"tangent(f, r)\n\nReconstruct the tangent t for which fdata(t) == f and rdata(t) == r.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.tangent_test_cases-Tuple{}","page":"Internal Docstrings","title":"Mooncake.tangent_test_cases","text":"tangent_test_cases()\n\nConstructs a Vector of Tuples containing test cases for the tangent infrastructure.\n\nIf the returned tuple has 2 elements, the elements should be interpreted as follows: 1 - interface_only 2 - primal value\n\ninterface_only is a Bool which will be used to determine which subset of tests to run.\n\nIf the returned tuple has 5 elements, then the elements are interpreted as follows: 1 - interface_only 2 - primal value 3, 4, 5 - tangents, where <5> == increment!!(<3>, <4>).\n\nTest cases in the first format make use of zero_tangent / randn_tangent etc to generate tangents, but they're unable to check that increment!! is correct in an absolute sense.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.tangent_type-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.tangent_type","text":"tangent_type(P)\n\nThere must be a single type used to represents tangents of primals of type P, and it must be given by tangent_type(P).\n\nWarning: this function assumes the effects :removable and :consistent. This is necessary to ensure good performance, but imposes precise constraints on your implementation. If adding new methods to tangent_type, you should consult the extended help of Base.@assume_effects to see what this imposes upon your implementation.\n\nExtended help\n\nThe tangent types which Mooncake.jl uses are quite similar in spirit to ChainRules.jl. For example, tangent \"vectors\" for\n\nFloat64s are Float64s,\nVector{Float64}s are Vector{Float64}s, and\nstructs are other another (special) struct with field types specified recursively.\n\nThere are, however, some major differences. Firstly, while it is certainly true that the above tangent types are permissible in ChainRules.jl, they are not the uniquely permissible types. For example, ZeroTangent is also a permissible type of tangent for any of them, and Float32 is permissible for Float64. This is a general theme in ChainRules.jl – it intentionally declines to place restrictions on what type can be used to represent the tangent of a given type.\n\nMooncake.jl differs from this. It insists that each primal type is associated to a single tangent type. Furthermore, this type is always given by the function Mooncake.tangent_type(primal_type).\n\nConsider some more worked examples.\n\nInt\n\nInt is not a differentiable type, so its tangent type is NoTangent:\n\njulia> tangent_type(Int)\nNoTangent\n\nTuples\n\nThe tangent type of a Tuple is defined recursively based on its field types. For example\n\njulia> tangent_type(Tuple{Float64, Vector{Float64}, Int})\nTuple{Float64, Vector{Float64}, NoTangent}\n\nThere is one edge case to be aware of: if all of the field of a Tuple are non-differentiable, then the tangent type is NoTangent. For example,\n\njulia> tangent_type(Tuple{Int, Int})\nNoTangent\n\nStructs\n\nAs with Tuples, the tangent type of a struct is, by default, given recursively. In particular, the tangent type of a struct type is Tangent. This type contains a NamedTuple containing the tangent to each field in the primal struct.\n\nAs with Tuples, if all field types are non-differentiable, the tangent type of the entire struct is NoTangent.\n\nThere are a couple of additional subtleties to consider over Tuples though. Firstly, not all fields of a struct have to be defined. Fortunately, Julia makes it easy to determine how many of the fields might possibly not be defined. The tangent associated to any field which might possibly not be defined is wrapped in a PossiblyUninitTangent.\n\nFurthermore, structs can have fields whose static type is abstract. For example\n\njulia> struct Foo\n           x\n       end\n\nIf you ask for the tangent type of Foo, you will see that it is\n\njulia> tangent_type(Foo)\nTangent{@NamedTuple{x}}\n\nObserve that the field type associated to x is Any. The way to understand this result is to observe that\n\nx could have literally any type at runtime, so we know nothing about what its tangent  type must be until runtime, and\nwe require that the tangent type of Foo be unique.\n\nThe consequence of these two considerations is that the tangent type of Foo must be able to contain any type of tangent in its x field. It follows that the fieldtype of the x field of Foos tangent must be Any.\n\nMutable Structs\n\nThe tangent type for mutable structs have the same set of considerations as structs. The only difference is that they must themselves be mutable. Consequently, we use a type called MutableTangent to represent their tangents. It is a mutable struct with the same structure as Tangent.\n\nFor example, if you ask for the tangent_type of\n\njulia> mutable struct Bar\n           x::Float64\n       end\n\nyou will find that it is\n\njulia> tangent_type(Bar)\nMutableTangent{@NamedTuple{x::Float64}}\n\nPrimitive Types\n\nWe've already seen a couple of primitive types (Float64 and Int). The basic story here is that all primitive types require an explicit specification of what their tangent type must be.\n\nOne interesting case are Ptr types. The tangent type of a Ptr{P} is Ptr{T}, where T = tangent_type(P). For example\n\njulia> tangent_type(Ptr{Float64})\nPtr{Float64}\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.tangent_type-Tuple{Type{Mooncake.NoFData}, Type{Mooncake.NoRData}}","page":"Internal Docstrings","title":"Mooncake.tangent_type","text":"tangent_type(F::Type, R::Type)::Type\n\nGiven the type of the fdata and rdata, F and R resp., for some primal type, compute its tangent type. This method must be equivalent to tangent_type(_typeof(primal)).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.to_cr_tangent-Tuple{Union{Float16, Float32, Float64}}","page":"Internal Docstrings","title":"Mooncake.to_cr_tangent","text":"to_cr_tangent(t)\n\nConvert a Mooncake tangent into a type that ChainRules.jl rrules expect to see.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.tuple_map-Union{Tuple{F}, Tuple{F, Tuple}} where F","page":"Internal Docstrings","title":"Mooncake.tuple_map","text":"tuple_map(f::F, x::Tuple) where {F}\n\nThis function is largely equivalent to map(f, x), but always specialises on all of the element types of x, regardless the length of x. This contrasts with map, in which the number of element types specialised upon is a fixed constant in the compiler.\n\nAs a consequence, if x is very long, this function may have very large compile times.\n\ntuple_map(f::F, x::Tuple, y::Tuple) where {F}\n\nBinary extension of tuple_map. Nearly equivalent to map(f, x, y), but guaranteed to specialise on all element types of x and y. Furthermore, errors if x and y aren't the same length, while map will just produce a new tuple whose length is equal to the shorter of x and y.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.unhandled_feature-Tuple{String}","page":"Internal Docstrings","title":"Mooncake.unhandled_feature","text":"unhandled_feature(msg::String)\n\nThrow an UnhandledLanguageFeatureException with message msg.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.uninit_codual-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.uninit_codual","text":"uninit_codual(x)\n\nEquivalent to CoDual(x, uninit_tangent(x)).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.uninit_fcodual-Tuple{P} where P","page":"Internal Docstrings","title":"Mooncake.uninit_fcodual","text":"uninit_fcodual(x)\n\nLike zero_fcodual, but doesn't guarantee that the value of the fdata is initialised. See implementation for details, as this function is subject to change.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.uninit_fdata-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.uninit_fdata","text":"uninit_fdata(p)\n\nEquivalent to fdata(uninit_tangent(p)).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.uninit_tangent-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.uninit_tangent","text":"uninit_tangent(x)\n\nRelated to zero_tangent, but a bit different. Check current implementation for details – this docstring is intentionally non-specific in order to avoid becoming outdated.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.verify_fdata_type-Tuple{Type, Type}","page":"Internal Docstrings","title":"Mooncake.verify_fdata_type","text":"verify_fdata_type(P::Type, F::Type)::Nothing\n\nCheck that F is a valid type for fdata associated to a primal of type P. Returns nothing if valid, throws an InvalidFDataException if a problem is found.\n\nThis applies to both concrete and non-concrete P. For example, if P is the type inferred for a primal q::Q, such that Q <: P, then this method is still applicable.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.verify_fdata_value-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.verify_fdata_value","text":"verify_fdata_value(p, f)::Nothing\n\nCheck that f cannot be proven to be invalid fdata for p.\n\nThis method attempts to provide some confidence that f is valid fdata for p by checking a collection of necessary conditions. We do not guarantee that these amount to a sufficient condition, just that they rule out a variety of common problems.\n\nPut differently, we cannot prove that f is valid fdata, only that it is not obviously invalid.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.verify_no_constant_gotoifnots-Tuple{Core.Compiler.IRCode}","page":"Internal Docstrings","title":"Mooncake.verify_no_constant_gotoifnots","text":"verify_no_constant_gotoifnots(ir::IRCode)\n\nVerify that we have successfully removed all instances of goto %n if not true and goto %n if not false, as these can be reduced to simpler nodes (namely, GotoNodes or \"fallthrough\"s). Moreover, removing them tends to yield performance improvements by reducing the amount of information Mooncake must keep in its block stacks.\n\nThis is essentially just testing functionality for const_prop_constant_gotoifnots. This is usually run each time a rule is compiled, as it is cheap, and because it is hard to construct a convincing set of test cases which, if passed at test-time, would indicate we were done.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.verify_rdata_type-Tuple{Type, Type}","page":"Internal Docstrings","title":"Mooncake.verify_rdata_type","text":"verify_rdata_type(P::Type, R::Type)::Nothing\n\nCheck that R is a valid type for rdata associated to a primal of type P. Returns nothing if valid, throws an InvalidRDataException if a problem is found.\n\nThis applies to both concrete and non-concrete P. For example, if P is the type inferred for a primal q::Q, such that Q <: P, then this method is still applicable.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.verify_rdata_value-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.verify_rdata_value","text":"verify_rdata_value(p, r)::Nothing\n\nCheck that r cannot be proven to be invalid rdata for p.\n\nThis method attempts to provide some confidence that r is valid rdata for p by checking a collection of necessary conditions. We do not guarantee that these amount to a sufficient condition, just that they rule out a variety of common problems.\n\nPut differently, we cannot prove that r is valid rdata, only that it is not obviously invalid.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_adjoint-Union{Tuple{N}, Tuple{Mooncake.CoDual, Vararg{Mooncake.CoDual, N}}} where N","page":"Internal Docstrings","title":"Mooncake.zero_adjoint","text":"zero_adjoint(f::CoDual, x::Vararg{CoDual, N}) where {N}\n\nUtility functionality for constructing rrule!!s for functions which produce adjoints which always return zero.\n\nNOTE: you should only make use of this function if you cannot make use of the @zero_adjoint macro.\n\nYou make use of this functionality by writing a method of Mooncake.rrule!!, and passing all of its arguments (including the function itself) to this function. For example:\n\njulia> import Mooncake: zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive, CoDual\n\njulia> foo(x::Vararg{Int}) = 5\nfoo (generic function with 1 method)\n\njulia> is_primitive(::Type{DefaultCtx}, ::Type{<:Tuple{typeof(foo), Vararg{Int}}}) = true;\n\njulia> rrule!!(f::CoDual{typeof(foo)}, x::Vararg{CoDual{Int}}) = zero_adjoint(f, x...);\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(3), zero_fcodual(2))[2](NoRData())\n(NoRData(), NoRData(), NoRData())\n\nWARNING: this is only correct if the output of primal(f)(map(primal, x)...) does not alias anything in f or x. This is always the case if the result is a bits type, but more care may be required if it is not. ```\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_codual-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.zero_codual","text":"zero_codual(x)\n\nEquivalent to CoDual(x, zero_tangent(x)).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_like_rdata_from_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.zero_like_rdata_from_type","text":"zero_like_rdata_from_type(::Type{P}) where {P}\n\nThis is an internal implementation detail – you should generally not use this function.\n\nReturns either the zero element of type rdata_type(tangent_type(P)), or a ZeroRData. It is always valid to return a ZeroRData, \n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_like_rdata_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.zero_like_rdata_type","text":"zero_like_rdata_type(::Type{P}) where {P}\n\nIndicates the type which will be returned by zero_like_rdata_from_type. Will be the rdata type for P if we can produce the zero rdata element given only P, and will be the union of R and ZeroRData if an instance of P is needed.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_rdata-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.zero_rdata","text":"zero_rdata(p)\n\nGiven value p, return the zero element associated to its reverse data type.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_rdata_from_type-Union{Tuple{Type{P}}, Tuple{P}} where P","page":"Internal Docstrings","title":"Mooncake.zero_rdata_from_type","text":"zero_rdata_from_type(::Type{P}) where {P}\n\nReturns the zero element of rdata_type(tangent_type(P)) if this is possible given only P. If not possible, returns an instance of CannotProduceZeroRDataFromType.\n\nFor example, the zero rdata associated to any primal of type Float64 is 0.0, so for Float64s this function is simple. Similarly, if the rdata type for P is NoRData, that can simply be returned.\n\nHowever, it is not possible to return the zero rdata element for abstract types e.g. Real as the type does not uniquely determine the zero element – the rdata type for Real is Any.\n\nThese considerations apply recursively to tuples / namedtuples / structs, etc.\n\nIf you encounter a type which this function returns CannotProduceZeroRDataFromType, but you believe this is done in error, please open an issue. This kind of problem does not constitute a correctness problem, but can be detrimental to performance, so should be dealt with.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_tangent-Tuple{Any, Mooncake.NoFData}","page":"Internal Docstrings","title":"Mooncake.zero_tangent","text":"zero_tangent(primal, fdata)\n\nEquivalent to tangent(fdata, rdata(zero_tangent(primal))).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_tangent-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.zero_tangent","text":"zero_tangent(x)\n\nReturns the unique zero element of the tangent space of x. It is an error for the zero element of the tangent space of x to be represented by anything other than that which this function returns.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.zero_tangent_internal-Tuple{Union{Int128, Int16, Int32, Int64, Int8}, Union{Mooncake.NoCache, IdDict{Any, Any}}}","page":"Internal Docstrings","title":"Mooncake.zero_tangent_internal","text":"zero_tangent_internal(x, d::MaybeCache)\n\nImplementation of zero_tangent. Makes use of d in the same way that Base.deepcopy_internal makes use of an IdDict (see the docstring for Base.deepcopy for information).\n\nIn particular, it should be used to ensure that aliasing relationships are respected, meaning that if in the tuple x = (a, b), a === b, then in (da, db) = zero_tangent((a, b)) it must hold that should have that da === db. You may want to consult the method of zero_tangent_internal for struct and mutable struct types for inspiration if implementing this for your own type.\n\nSimilarly, if x contains a one or more circular, its tangent will probably need to contain similar circular references (unless it is something trivial like NoTangent). Again, consult existing implementations for inspiration.\n\nIf d is a NoCache assume that x contains neither aliasing nor circular references.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.@foldable-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.@foldable","text":"macro foldable def\n\nShorthand for Base.@assume_effects :foldable function f(x)....\n\n\n\n\n\n","category":"macro"},{"location":"developer_documentation/internal_docstrings/#Mooncake.@from_rrule","page":"Internal Docstrings","title":"Mooncake.@from_rrule","text":"@from_rrule ctx sig [has_kwargs=false]\n\nConvenience functionality to assist in using ChainRulesCore.rrules to write rrule!!s.\n\nArguments\n\nctx: A Mooncake context type\nsig: the signature which you wish to assert should be a primitive in Mooncake.jl, and   use an existing ChainRulesCore.rrule to implement this functionality.\nhas_kwargs: a Bool state whether or not the function has keyword arguments. This   feature has the same limitations as ChainRulesCore.rrule – the derivative w.r.t. all   kwargs must be zero.\n\nExample Usage\n\nA Basic Example\n\njulia> using Mooncake: @from_rrule, DefaultCtx, rrule!!, zero_fcodual, TestUtils\n\njulia> import ChainRulesCore\n\njulia> foo(x::Real) = 5x;\n\njulia> function ChainRulesCore.rrule(::typeof(foo), x::Real)\n           foo_pb(Ω::Real) = ChainRulesCore.NoTangent(), 5Ω\n           return foo(x), foo_pb\n       end;\n\njulia> @from_rrule DefaultCtx Tuple{typeof(foo), Base.IEEEFloat}\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(5.0))[2](1.0)\n(NoRData(), 5.0)\n\njulia> # Check that the rule works as intended.\n       TestUtils.test_rule(Xoshiro(123), foo, 5.0; is_primitive=true)\nTest Passed\n\nAn Example with Keyword Arguments\n\njulia> using Mooncake: @from_rrule, DefaultCtx, rrule!!, zero_fcodual, TestUtils\n\njulia> import ChainRulesCore\n\njulia> foo(x::Real; cond::Bool) = cond ? 5x : 4x;\n\njulia> function ChainRulesCore.rrule(::typeof(foo), x::Real; cond::Bool)\n           foo_pb(Ω::Real) = ChainRulesCore.NoTangent(), cond ? 5Ω : 4Ω\n           return foo(x; cond), foo_pb\n       end;\n\njulia> @from_rrule DefaultCtx Tuple{typeof(foo), Base.IEEEFloat} true\n\njulia> _, pb = rrule!!(\n           zero_fcodual(Core.kwcall),\n           zero_fcodual((cond=false, )),\n           zero_fcodual(foo),\n           zero_fcodual(5.0),\n       );\n\njulia> pb(3.0)\n(NoRData(), NoRData(), NoRData(), 12.0)\n\njulia> # Check that the rule works as intended.\n       TestUtils.test_rule(\n           Xoshiro(123), Core.kwcall, (cond=false, ), foo, 5.0; is_primitive=true\n       )\nTest Passed\n\nNotice that, in order to access the kwarg method we must call the method of Core.kwcall, as Mooncake's rrule!! does not itself permit the use of kwargs.\n\nLimitations\n\nIt is your responsibility to ensure that\n\ncalls with signature sig do not mutate their arguments,\nthe output of calls with signature sig does not alias any of the inputs.\n\nAs with all hand-written rules, you should definitely make use of TestUtils.test_rule to verify correctness on some test cases.\n\nArgument Type Constraints\n\nMany methods of ChainRuleCore.rrule are implemented with very loose type constraints. For example, it would not be surprising to see a method of rrule with the signature\n\nTuple{typeof(rrule), typeof(foo), Real, AbstractVector{<:Real}}\n\nThere are a variety of reasons for this way of doing things, and whether it is a good idea to write rules for such generic objects has been debated at length.\n\nSuffice it to say, you should not write rules for this package which are so generically typed. Rather, you should create rules for the subset of types for which you believe that the ChainRulesCore.rrule will work correctly, and leave this package to derive rules for the rest. For example, it is quite common to be confident that a given rule will work correctly for any Base.IEEEFloat argument, i.e. Union{Float16, Float32, Float64}, but it is usually not possible to know that the rule is correct for all possible subtypes of Real that someone might define.\n\nConversions Between Different Tangent Type Systems\n\nUnder the hood, this functionality relies on two functions: Mooncake.to_cr_tangent, and Mooncake.increment_and_get_rdata!. These two functions handle conversion to / from Mooncake tangent types and ChainRulesCore tangent types. This functionality is known to work well for simple types, but has not been tested to a great extent on complicated composite types. If @from_rrule does not work in your case because the required method of either of these functions does not exist, please open an issue.\n\n\n\n\n\n","category":"macro"},{"location":"developer_documentation/internal_docstrings/#Mooncake.@is_primitive-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.@is_primitive","text":"@is_primitive context_type signature\n\nCreates a method of is_primitive which always returns true for the context_type and signature provided. For example\n\n@is_primitive MinimalCtx Tuple{typeof(foo), Float64}\n\nis equivalent to\n\nis_primitive(::Type{MinimalCtx}, ::Type{<:Tuple{typeof(foo), Float64}}) = true\n\nYou should implemented more complicated method of is_primitive in the usual way.\n\n\n\n\n\n","category":"macro"},{"location":"developer_documentation/internal_docstrings/#Mooncake.@mooncake_overlay-Tuple{Any}","page":"Internal Docstrings","title":"Mooncake.@mooncake_overlay","text":"@mooncake_overlay method_expr\n\nDefine a method of a function which only Mooncake can see. This can be used to write versions of methods which can be successfully differentiated by Mooncake if the original cannot be.\n\nFor example, suppose that you have a function\n\njulia> foo(x::Float64) = bar(x)\nfoo (generic function with 1 method)\n\nwhere Mooncake.jl fails to differentiate bar for some reason. If you have access to another function baz, which does the same thing as bar, but does     so in a way which Mooncake.jl can differentiate, you can simply write:\n\njulia> Mooncake.@mooncake_overlay foo(x::Float64) = baz(x)\n\n\nWhen looking up the code for foo(::Float64), Mooncake.jl will see this method, rather than the original, and differentiate it instead.\n\nA Worked Example\n\nTo demonstrate how to use @mooncake_overlays in practice, we here demonstrate how the answer that Mooncake.jl gives changes if you change the definition of a function using a @mooncake_overlay. Do not do this in practice – this is just a simple way to demonostrate how to use overlays!\n\nFirst, consider a simple example:\n\njulia> scale(x) = 2x\nscale (generic function with 1 method)\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(10.0, (NoTangent(), 2.0))\n\nWe can use @mooncake_overlay to change the definition which Mooncake.jl sees:\n\njulia> Mooncake.@mooncake_overlay scale(x) = 3x\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(15.0, (NoTangent(), 3.0))\n\nAs can be seen from the output, the result of differentiating using Mooncake.jl has changed to reflect the overlay-ed definition of the method.\n\nAdditionally, it is possible to use the usual multi-line syntax to declare an overlay:\n\njulia> Mooncake.@mooncake_overlay function scale(x)\n           return 4x\n       end\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(20.0, (NoTangent(), 4.0))\n\n\n\n\n\n","category":"macro"},{"location":"developer_documentation/internal_docstrings/#Mooncake.@zero_adjoint-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.@zero_adjoint","text":"@zero_adjoint ctx sig\n\nDefines is_primitive(context_type, sig) = true, and defines a method of Mooncake.rrule!! which returns zero for all inputs. Users of ChainRules.jl should be familiar with this functionality – it is morally the same as ChainRulesCore.@non_differentiable.\n\nFor example:\n\njulia> using Mooncake: @zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive\n\njulia> foo(x) = 5\nfoo (generic function with 1 method)\n\njulia> @zero_adjoint DefaultCtx Tuple{typeof(foo), Any}\n\njulia> is_primitive(DefaultCtx, Tuple{typeof(foo), Any})\ntrue\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(3.0))[2](NoRData())\n(NoRData(), 0.0)\n\nLimited support for Varargs is also available. For example\n\njulia> using Mooncake: @zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive\n\njulia> foo_varargs(x...) = 5\nfoo_varargs (generic function with 1 method)\n\njulia> @zero_adjoint DefaultCtx Tuple{typeof(foo_varargs), Vararg}\n\njulia> is_primitive(DefaultCtx, Tuple{typeof(foo_varargs), Any, Float64, Int})\ntrue\n\njulia> rrule!!(zero_fcodual(foo_varargs), zero_fcodual(3.0), zero_fcodual(5))[2](NoRData())\n(NoRData(), 0.0, NoRData())\n\nBe aware that it is not currently possible to specify any of the type parameters of the Vararg. For example, the signature Tuple{typeof(foo), Vararg{Float64, 5}} will not work with this macro.\n\nWARNING: this is only correct if the output of the function does not alias any fields of the function, or any of its arguments. For example, applying this macro to the function x -> x will yield incorrect results.\n\nAs always, you should use TestUtils.test_rule to ensure that you've not made a mistake.\n\nSignatures Unsupported By This Macro\n\nIf the signature you wish to apply @zero_adjoint to is not supported, for example because it uses a Vararg with a type parameter, you can still make use of zero_adjoint.\n\n\n\n\n\n","category":"macro"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.address_maps_are_consistent-Tuple{Dict{Ptr{Nothing}, Ptr{Nothing}}, Dict{Ptr{Nothing}, Ptr{Nothing}}}","page":"Internal Docstrings","title":"Mooncake.TestUtils.address_maps_are_consistent","text":"address_maps_are_consistent(x::AddressMap, y::AddressMap)\n\ntrue if all keys in both x and y map to the same values. i.e. if any key appears in both x and y, and the corresponding value is not the same in both x and y, return false.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.has_equal_data-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.TestUtils.has_equal_data","text":"has_equal_data(x, y; equal_undefs=true)\n\nDetermine if two objects x and y have equivalent data. If equal_undefs  is true, undefined elements in arrays or unassigned fields in structs are  considered equal.\n\nThe main logic is implemented in has_equal_data_internal, which is a recursive function that takes an additional visited dictionary to track visited objects and avoid infinite recursion in cases of circular references.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.is_foldable-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.TestUtils.is_foldable","text":"is_foldable(f, types)::Bool\n\ntrue if the effects inferred for the application of f to arguments of type types indicate that the compiler believes such a call can be constant-folded.\n\nSee the docstrings for Base.@infer_effects and Base.infer_effects for more information on the effects system in Julia.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.populate_address_map-Tuple{Any, Any}","page":"Internal Docstrings","title":"Mooncake.TestUtils.populate_address_map","text":"populate_address_map(primal, tangent)\n\nConstructs an empty AddressMap and calls populate_address_map_internal.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.populate_address_map_internal-Union{Tuple{T}, Tuple{P}, Tuple{Dict{Ptr{Nothing}, Ptr{Nothing}}, P, T}} where {P, T}","page":"Internal Docstrings","title":"Mooncake.TestUtils.populate_address_map_internal","text":"populate_address_map_internal(m::AddressMap, primal, tangent)\n\nFills m with pairs mapping from memory addresses in primal to corresponding memory addresses in tangent. If the same memory address appears multiple times in primal, throws an AssertionError if the same address is not mapped to in tangent each time.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_data-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_data","text":"test_data(rng::AbstractRNG, p::P)\n\nVerify that all tangent / fdata / rdata functionality work properly for p. Furthermore, verify that all primitives listed in TestUtils.test_rule_and_type_interactions work correctly on p. This functionality is particularly useful if you are writing your own custom tangent / fdata / rdata types and want to be confident that you have implemented the functionality that you need in order to make these custom types work with all the rules written in Mooncake itself.\n\nYou should consult the docstrings for test_tangent_interface, test_tangent_splitting, and test_rule_and_type_interactions, in order to see what is required to satisfy the full tangent interface for p.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_rule-Tuple{Random.AbstractRNG, Vararg{Any}}","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_rule","text":"test_rule(\n    rng, x...;\n    interface_only=false,\n    is_primitive::Bool=true,\n    perf_flag::Symbol=:none,\n    interp::Mooncake.MooncakeInterpreter=Mooncake.get_interpreter(),\n    debug_mode::Bool=false,\n    unsafe_perturb::Bool=false,\n)\n\nRun standardised tests on the rule for x. The first element of x should be the primal function to test, and each other element a positional argument. In most cases, elements of x can just be the primal values, and randn_tangent can be relied upon to generate an appropriate tangent to test. Some notable exceptions exist though, in partcular Ptrs. In this case, the argument for which randn_tangent cannot be readily defined should be a CoDual containing the primal, and a manually constructed tangent field.\n\nThis function uses Mooncake.build_rrule to construct a rule. This will use an rrule!! if one exists, and derive a rule otherwise.\n\nArguments\n\nrng::AbstractRNG: a random number generator\nx...: the function (first element) and its arguments (the remainder)\n\nKeyword Arguments\n\ninterface_only::Bool=false: test only that the interface is satisfied, without testing   correctness. This should generally be set to false (the default value), and only   enabled if the testing infrastructure is unable to test correctness for some reason   e.g. the returned value of the function is a Ptr, and appropriate tangents cannot,   therefore, be generated for it automatically.\nis_primitive::Bool=true: check whether the thing that you are testing has a hand-written   rrule!!. This option is helpful if you are testing a new rrule!!, as it enables you   to verify that your method of is_primitive has returned the correct value, and that   you are actually testing a method of the rrule!! function – a common mistake when   authoring a new rrule!! is to implement is_primitive incorrectly and to accidentally   wind up testing a rule which Mooncake has derived, as opposed to the one that you have   written. If you are testing something for which you have not   hand-written an rrule!!, or which you do not care whether it has a hand-written   rrule!! or not, you should set it to false.\nperf_flag::Symbol=:none: the value of this symbol determines what kind of performance   tests should be performed. By default, none are performed. If you believe that a rule   should be allocation-free (iff the primal is allocation free), set this to :allocs. If   you hand-write an rrule!! and believe that your test case should be type stable, set   this to :stability (at present we cannot verify whether a derived rule is type stable   for technical reasons). If you believe that a hand-written rule should be both   allocation-free and type-stable, set this to :stability_and_allocs.\ninterp::Mooncake.MooncakeInterpreter=Mooncake.get_interpreter(): the abstract   interpreter to be used when testing this rule. The default should generally be used.\ndebug_mode::Bool=false: whether or not the rule should be tested in debug mode.   Typically this should be left at its default false value, but if you are finding that   the tests are failing for a given rule, you may wish to temporarily set it to true in   order to get access to additional information and automated testing.\nunsafe_perturb::Bool=false: value passed as the third argument to _add_to_primal.   Should usually be left false – consult the docstring for _add_to_primal for more   info on when you might wish to set it to true.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_rule_and_type_interactions-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_rule_and_type_interactions","text":"test_rule_and_type_interactions(rng::AbstractRNG, p)\n\nCheck that a collection of standard functions for which we ought to have a working rrule for p work, and produce the correct answer. For example, the rrule!! for typeof should work correctly on any type, we should have a working rule for getfield for any struct-type, and we should have a rule for setfield! for any mutable struct type. See extended help for more info.\n\nExtended Help\n\nThe purpose of this test is to ensure that, for any given p, the full range of primitive functions that ought to work on it, do indeed work on it.\n\nThis is one part of the interface where some care might be required. If, for some reason, it should never be the case that e.g. for a particular p, getfield should be called, then it may make no sense at all to run these tests. In such cases, the author of the type is responsible for knowing what they are doing. Please open an issue to discuss for your type if you are at all unsure what to do.\n\nWhen defining a custom tangent type for P, the functions that you will need to pay attention to writing rules for are\n\nMooncake._new_\nMooncake.lgetfield\nMooncake.lsetfield!\n\nIn all cases, you may wish to consult the current implementations of rrule!! for these functions for inspiration regarding how you might implement them for your type.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent-Tuple{Random.AbstractRNG, Any, Any}","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent","text":"test_tangent(rng::AbstractRNG, p, T; interface_only=false, perf=true)\n\nLike test_tangent(rng, p), but also checks that tangent_type(typeof(p)) == T.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent-Tuple{Random.AbstractRNG, Any}","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent","text":"test_tangent(rng::AbstractRNG, p; interface_only=false, perf=true)\n\nTest that standard tangent-related functionality works for p.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent_interface-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent_interface","text":"test_tangent_interface(rng::AbstractRNG, p; interface_only=false)\n\nVerify that standard functionality for tangents runs, and is consistent. This function is the defacto formal definition of the \"tangent interface\" – if this function runs without error for a given value of p, then that p satisfies the tangent interface.\n\nExtended Help\n\nVerifies that the following functions are implemented correctly (as far as possible) for p / its type, and its tangents / their type:\n\nMooncake.tangent_type\nMooncake.zero_tangent_internal\nMooncake.randn_tangent_internal\nMooncake.TestUtils.has_equal_data\nMooncake.increment_internal!!\nMooncake.set_to_zero_internal!!\nMooncake._add_to_primal_internal\nMooncake._diff_internal\nMooncake._dot_internal\nMooncake._scale_internal\nMooncake.TestUtils.populate_address_map_internal\n\nIn conjunction with the functions tested by test_tangent_splitting, these functions constitute a complete set of functions which must be applicable to p in order to ensure that it operates correctly in the context of reverse-mode AD. This list should be up to date at any given point in time, but the best way to verify that you've implemented everything is simply to run this function, and see whether it errors / produces a failing test.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent_performance-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent_performance","text":"test_tangent_performance(rng::AbstractRNG, p::P) where {P}\n\nRuns a variety of performance-related tests on tangents. These tests constitute a set of necessary conditions for good overall performance.\n\nThe performance model in a few cases is a little bit complicated, because it depends on various properties of the type in question (is it mutable, are its fields mutable, are all of its fields necessarily defined, etc), so the source code should be consulted for precise details.\n\nNote: this function assumes that the tangent interface is implemented correctly for p. To verify that this is the case, ensure that all tests in test_tangent_interface pass.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent_splitting-Union{Tuple{P}, Tuple{Random.AbstractRNG, P}} where P","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent_splitting","text":"test_tangent_splitting(rng::AbstractRNG, p::P) where {P}\n\nVerify that tangent splitting functionality associated to primal p works correctly. Ensure that test_tangent_interface runs for p before running these tests.\n\nExtended Help\n\nVerifies that the following functionality work correctly for p / its type / tangents:\n\nMooncake.fdata_type\nMooncake.rdata_type\nMooncake.fdata\nMooncake.rdata\nMooncake.uninit_fdata\nMooncake.tangent_type (binary method)\nMooncake.tangent (binary method)\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.TestUtils.test_tangent_type-Tuple{Type, Type}","page":"Internal Docstrings","title":"Mooncake.TestUtils.test_tangent_type","text":"test_tangent_type(primal_type, expected_tangent_type)\n\nChecks that tangent_type(primal_type) yields expected_tangent_type, and that everything infers / optimises away, and that the effects are as expected.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/internal_docstrings/#Mooncake.IntrinsicsWrappers","page":"Internal Docstrings","title":"Mooncake.IntrinsicsWrappers","text":"module IntrinsicsWrappers\n\nThe purpose of this module is to associate to each function in Core.Intrinsics a regular Julia function.\n\nTo understand the rationale for this observe that, unlike regular Julia functions, each Core.IntrinsicFunction in Core.Intrinsics does not have its own type. Rather, they are instances of Core.IntrinsicFunction. To see this, observe that\n\njulia> typeof(Core.Intrinsics.add_float)\nCore.IntrinsicFunction\n\njulia> typeof(Core.Intrinsics.sub_float)\nCore.IntrinsicFunction\n\nWhile we could simply write a rule for Core.IntrinsicFunction, this would (naively) lead to a large list of conditionals of the form\n\nif f === Core.Intrinsics.add_float\n    # return add_float and its pullback\nelseif f === Core.Intrinsics.sub_float\n    # return add_float and its pullback\nelseif\n    ...\nend\n\nwhich has the potential to cause quite substantial type instabilities. (This might not be true anymore – see extended help for more context).\n\nInstead, we map each Core.IntrinsicFunction to one of the regular Julia functions in Mooncake.IntrinsicsWrappers, to which we can dispatch in the usual way.\n\nExtended Help\n\nIt is possible that owing to improvements in constant propagation in the Julia compiler in version 1.10, we actually could get away with just writing a single method of rrule!! to handle all intrinsics, so this dispatch-based mechanism might be unnecessary. Someone should investigate this. Discussed at https://github.com/chalk-lab/Mooncake.jl/issues/387 .\n\n\n\n\n\n","category":"module"},{"location":"developer_documentation/developer_tools/#Developer-Tools","page":"Developer Tools","title":"Developer Tools","text":"","category":"section"},{"location":"developer_documentation/developer_tools/","page":"Developer Tools","title":"Developer Tools","text":"Mooncake.jl offers developers to a few convenience functions which give access to the IR that it generates in order to perform AD. These are lightweight wrappers around internals which save you from having to dig in to the objects created by build_rrule.","category":"page"},{"location":"developer_documentation/developer_tools/","page":"Developer Tools","title":"Developer Tools","text":"Since these provide access to internals, they do not follow the usual rules of semver, and may change without notice!","category":"page"},{"location":"developer_documentation/developer_tools/#Mooncake.primal_ir-developer_documentation-developer_tools","page":"Developer Tools","title":"Mooncake.primal_ir","text":"primal_ir(sig::Type{<:Tuple}; interp=get_interpreter())::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as  part of a non-breaking release of the package.\n\nGet the Core.Compiler.IRCode associated to sig from which the a rule can be derived. Roughly equivalent to Base.code_ircode_by_type(sig; interp).\n\nFor example, if you wanted to get the IR associated to the call map(sin, randn(10)), you could do one of the following calls:\n\njulia> Mooncake.primal_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.primal_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/developer_tools/#Mooncake.fwd_ir-developer_documentation-developer_tools","page":"Developer Tools","title":"Mooncake.fwd_ir","text":"fwd_ir(\n    sig::Type{<:Tuple};\n    interp=get_interpreter(), debug_mode::Bool=false, do_inline::Bool=true\n)::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as part of a non-breaking release of the package.\n\nGenerate the Core.Compiler.IRCode used to construct the forwards-pass of AD. Take a look at how build_rrule makes use of generate_ir to see exactly how this is used in practice.\n\nFor example, if you wanted to get the IR associated to the forwards pass for the call map(sin, randn(10)), you could do either of the following:\n\njulia> Mooncake.fwd_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.fwd_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\nArguments\n\nsig::Type{<:Tuple}: the signature of the call to be differentiated.\n\nKeyword Arguments\n\ninterp: the interpreter to use to obtain the primal IR.\ndebug_mode::Bool: whether the generated IR should make use of Mooncake's debug mode.\ndo_inline::Bool: whether to apply an inlining pass prior to returning the ir generated   by this function. This is true by default, but setting it to false can sometimes be   helpful if you need to understand what function calls are generated in order to perform   AD, before lots of it gets inlined away.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/developer_tools/#Mooncake.rvs_ir-developer_documentation-developer_tools","page":"Developer Tools","title":"Mooncake.rvs_ir","text":"rvs_ir(\n    sig::Type{<:Tuple};\n    interp=get_interpreter(), debug_mode::Bool=false, do_inline::Bool=true\n)::IRCode\n\nwarning: Warning\nThis is not part of the public interface of Mooncake. As such, it may change as part of a non-breaking release of the package.\n\nGenerate the Core.Compiler.IRCode used to construct the reverse-pass of AD. Take a look at how build_rrule makes use of generate_ir to see exactly how this is used in practice.\n\nFor example, if you wanted to get the IR associated to the reverse pass for the call map(sin, randn(10)), you could do either of the following:\n\njulia> Mooncake.rvs_ir(Tuple{typeof(map), typeof(sin), Vector{Float64}}) isa Core.Compiler.IRCode\ntrue\njulia> Mooncake.rvs_ir(typeof((map, sin, randn(10)))) isa Core.Compiler.IRCode\ntrue\n\nArguments\n\nsig::Type{<:Tuple}: the signature of the call to be differentiated.\n\nKeyword Arguments\n\ninterp: the interpreter to use to obtain the primal IR.\ndebug_mode::Bool: whether the generated IR should make use of Mooncake's debug mode.\ndo_inline::Bool: whether to apply an inlining pass prior to returning the ir generated   by this function. This is true by default, but setting it to false can sometimes be   helpful if you need to understand what function calls are generated in order to perform   AD, before lots of it gets inlined away.\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/running_tests_locally/#Running-Tests-Locally","page":"Running Tests Locally","title":"Running Tests Locally","text":"","category":"section"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Mooncake.jl's test suite is fairly extensive. While you can use Pkg.test to run the test suite in the standard manner, this is not usually optimal in Mooncake.jl, and will not run all of the tests. When editing some code, you typically only want to run the tests associated with it, not the entire test suite.","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"There are two workflows for running tests, discussed below.","category":"page"},{"location":"developer_documentation/running_tests_locally/#Main-Testing-Functionality","page":"Running Tests Locally","title":"Main Testing Functionality","text":"","category":"section"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"For all code in src, Mooncake's tests are organised as follows:","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Things that are required for most / all test suites are loaded up in test/front_matter.jl.\nThe tests for something in src are located in an identically-named file in test. e.g. the unit tests for src/rrules/new.jl are located in test/rrules/new.jl.","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Thus, a workflow that I (Will) find works very well is the following:","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Ensure that you have Revise.jl and TestEnv.jl installed in your default environment.\nstart the REPL, dev Mooncake.jl, and navigate to the top level of the Mooncake.jl directory.\nusing TestEnv, Revise. Better still, load both of these in your .julia/config/startup.jl file so that you don't ever forget to load them.\nRun the following: using Pkg; Pkg.activate(\".\"); TestEnv.activate(); include(\"test/front_matter.jl\"); to set up your environment.\ninclude whichever test file you want to run the tests from.\nModify code, and re-include tests to check it has done was you need. Loop this until done.\nMake a PR. This runs the entire test suite – I find that I almost never run the entire test suite locally.","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"The purpose of this approach is to:","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Avoid restarting the REPL each time you make a change, and\nRun the smallest bit of the test suite possible when making changes, in order to make development a fast and enjoyable process.","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"If you find that this strategy leaves you running more of the test suite than you would like, consider copy + pasting specific tests into the REPL, or commenting out a chunk of tests in the file that you are editing during development (try not to commit this). I find this is rather crude strategy effective in practice.","category":"page"},{"location":"developer_documentation/running_tests_locally/#Extension-and-Integration-Testing","page":"Running Tests Locally","title":"Extension and Integration Testing","text":"","category":"section"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"Mooncake now has quite a lot of package extensions, and a large number of integration tests. Unfortunately, these come with a lot of additional dependencies. To avoid these dependencies causing CI to take much longer to run, we locate all tests for extensions and integration testing in their own environments. These can be found in the test/ext and test/integration_testing directories respectively.","category":"page"},{"location":"developer_documentation/running_tests_locally/","page":"Running Tests Locally","title":"Running Tests Locally","text":"These directories comprise a single .jl file, and a Project.toml. You should run these tests by simply includeing the .jl file. Doing so will activate the environemnt, ensure that the correct version of Mooncake is used, and run the tests.","category":"page"},{"location":"utilities/debugging_and_mwes/#Debugging-and-MWEs","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"","category":"section"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"There's a reasonable chance that you'll run into an issue with Mooncake.jl at some point. In order to debug what is going on when this happens, or to produce an MWE, it is helpful to have a convenient way to run Mooncake.jl on whatever function and arguments you have which are causing problems.","category":"page"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"We recommend making use of Mooncake.jl's testing functionality to generate your test cases:","category":"page"},{"location":"utilities/debugging_and_mwes/#Mooncake.TestUtils.test_rule-utilities-debugging_and_mwes","page":"Debugging and MWEs","title":"Mooncake.TestUtils.test_rule","text":"test_rule(\n    rng, x...;\n    interface_only=false,\n    is_primitive::Bool=true,\n    perf_flag::Symbol=:none,\n    interp::Mooncake.MooncakeInterpreter=Mooncake.get_interpreter(),\n    debug_mode::Bool=false,\n    unsafe_perturb::Bool=false,\n)\n\nRun standardised tests on the rule for x. The first element of x should be the primal function to test, and each other element a positional argument. In most cases, elements of x can just be the primal values, and randn_tangent can be relied upon to generate an appropriate tangent to test. Some notable exceptions exist though, in partcular Ptrs. In this case, the argument for which randn_tangent cannot be readily defined should be a CoDual containing the primal, and a manually constructed tangent field.\n\nThis function uses Mooncake.build_rrule to construct a rule. This will use an rrule!! if one exists, and derive a rule otherwise.\n\nArguments\n\nrng::AbstractRNG: a random number generator\nx...: the function (first element) and its arguments (the remainder)\n\nKeyword Arguments\n\ninterface_only::Bool=false: test only that the interface is satisfied, without testing   correctness. This should generally be set to false (the default value), and only   enabled if the testing infrastructure is unable to test correctness for some reason   e.g. the returned value of the function is a Ptr, and appropriate tangents cannot,   therefore, be generated for it automatically.\nis_primitive::Bool=true: check whether the thing that you are testing has a hand-written   rrule!!. This option is helpful if you are testing a new rrule!!, as it enables you   to verify that your method of is_primitive has returned the correct value, and that   you are actually testing a method of the rrule!! function – a common mistake when   authoring a new rrule!! is to implement is_primitive incorrectly and to accidentally   wind up testing a rule which Mooncake has derived, as opposed to the one that you have   written. If you are testing something for which you have not   hand-written an rrule!!, or which you do not care whether it has a hand-written   rrule!! or not, you should set it to false.\nperf_flag::Symbol=:none: the value of this symbol determines what kind of performance   tests should be performed. By default, none are performed. If you believe that a rule   should be allocation-free (iff the primal is allocation free), set this to :allocs. If   you hand-write an rrule!! and believe that your test case should be type stable, set   this to :stability (at present we cannot verify whether a derived rule is type stable   for technical reasons). If you believe that a hand-written rule should be both   allocation-free and type-stable, set this to :stability_and_allocs.\ninterp::Mooncake.MooncakeInterpreter=Mooncake.get_interpreter(): the abstract   interpreter to be used when testing this rule. The default should generally be used.\ndebug_mode::Bool=false: whether or not the rule should be tested in debug mode.   Typically this should be left at its default false value, but if you are finding that   the tests are failing for a given rule, you may wish to temporarily set it to true in   order to get access to additional information and automated testing.\nunsafe_perturb::Bool=false: value passed as the third argument to _add_to_primal.   Should usually be left false – consult the docstring for _add_to_primal for more   info on when you might wish to set it to true.\n\n\n\n\n\n","category":"function"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"This approach is convenient because it can","category":"page"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"check whether AD runs at all,\ncheck whether AD produces the correct answers,\ncheck whether AD is performant, and\ncan be used without having to manually generate tangents.","category":"page"},{"location":"utilities/debugging_and_mwes/#Example","page":"Debugging and MWEs","title":"Example","text":"","category":"section"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"For example","category":"page"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"f(x) = Core.bitcast(Float64, x)\nMooncake.TestUtils.test_rule(Random.Xoshiro(123), f, 3; is_primitive=false)","category":"page"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"will error. (In this particular case, it is caused by Mooncake.jl preventing you from doing (potentially) unsafe casting. In this particular instance, Mooncake.jl just fails to compile, but in other instances other things can happen.)","category":"page"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"In any case, the point here is that Mooncake.TestUtils.test_rule provides a convenient way to produce and report an error.","category":"page"},{"location":"utilities/debugging_and_mwes/#Segfaults","page":"Debugging and MWEs","title":"Segfaults","text":"","category":"section"},{"location":"utilities/debugging_and_mwes/","page":"Debugging and MWEs","title":"Debugging and MWEs","text":"These are everyone's least favourite kind of problem, and they should be extremely rare in Mooncake.jl. However, if you are unfortunate enough to encounter one, please re-run your problem with the debug_mode kwarg set to true. See Debug Mode for more info. In general, this will catch problems before they become segfaults, at which point the above strategy for debugging and error reporting should work well.","category":"page"},{"location":"understanding_mooncake/rule_system/#Mooncake.jl's-Rule-System","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Mooncake.jl's approach to AD is recursive. It has a single specification for what it means to differentiate a Julia callable, and basically two approaches to achieving this. This section of the documentation explains the former.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"We take an iterative approach to this explanation, starting at a high-level and adding more depth as we go.","category":"page"},{"location":"understanding_mooncake/rule_system/#10,000-Foot-View","page":"Mooncake.jl's Rule System","title":"10,000 Foot View","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A rule r(f, x) for a function f(x) \"does reverse mode AD\", and executes in two phases, known as the forwards pass and the reverse pass. In the forwards pass a rule executes the original function, and does some additional book-keeping in preparation for the reverse pass. On the reverse pass it undoes the computation from the forwards pass, \"backpropagates\" the gradient w.r.t. the output of the original function by applying the adjoint of the derivative of the original function to it, and writes the results of this computation to the correct places.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A precise mathematical model for the original function is therefore entirely crucial to this discussion, as it is needed to understand what the adjoint of its derivative is.","category":"page"},{"location":"understanding_mooncake/rule_system/#A-Model-For-A-Julia-Function","page":"Mooncake.jl's Rule System","title":"A Model For A Julia Function","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Since Julia permits the in-place modification / mutation of many data structures, we cannot make a naive translation between a Julia function and a mathematical object. Rather, we will have to model the state of the arguments to a function both before and after execution. Moreover, since a function can allocate new memory as part of execution and return it to the calling scope, we must track that too.","category":"page"},{"location":"understanding_mooncake/rule_system/#Consider-Only-Externally-Visible-Effects-Of-Function-Evaluation","page":"Mooncake.jl's Rule System","title":"Consider Only Externally-Visible Effects Of Function Evaluation","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"We wish to treat a given function as a black box – we care about what a function does, not how it does it – so we consider only the externally-visible results of executing it. There are two ways in which changes can be made externally visible.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Return Value","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"(This point hardly requires explanation, but for the sake of completeness we do so anyway.)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The most obvious way in which a result can be made visible outside of a function is via its return value. For example, letting bar(x) = sin(x), consider the function","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function foo(x)\n    y = bar(x)\n    z = bar(y)\n    return z\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The communication between the two invocations of bar happen via the value it returns.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Modification of arguments","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In contrast to the above, changes made by one function can be made available to another implicitly if it modifies the values of its arguments, even if it doesn't return anything. For example, consider:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function bar(x::Vector{Float64})\n    x .*= 2\n    return nothing\nend\n\nfunction foo(x::Vector{Float64})\n    bar(x)\n    bar(x)\n    return x\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The second call to bar in foo sees the changes made to x by the first call to bar, despite not being explicitly returned.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"No Global Mutable State","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"functions can in principle also communicate via global mutable state. We make the decision to not support this.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"For example, we assume functions of the following form cannot be encountered:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"const a = randn(10)\n\nfunction bar(x)\n    a .+= x\n    return nothing\nend\n\nfunction foo(x)\n    bar(x)\n    return a\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In this example, a is modified by bar, the effect of which is visible to foo.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"For a variety of reasons this is very awkward to handle well. Since it's largely considered poor practice anyway, we explicitly outlaw this mode of communication between functions. See Why Support Closures But Not Mutable Globals for more info.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Note that this does not preclude the use of closed-over values or callable structs. For example, something like","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function foo(x)\n    function bar(y)\n        x .+= y\n        return nothing\n    end\n    return bar(x)\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"is perfectly fine.","category":"page"},{"location":"understanding_mooncake/rule_system/#The-Model","page":"Mooncake.jl's Rule System","title":"The Model","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"It is helpful to have a concrete example which uses both of the permissible methods to make results externally visible. To this end, consider the following function:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function f(x::Vector{Float64}, y::Vector{Float64}, z::Vector{Float64}, s::Ref{Vector{Float64}})\n    z .*= y .* x\n    s[] = 2z\n    return sum(z)\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"We draw your attention to a variety of features of this function:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"z is mutated,\ns is mutated to reference freshly allocated memory,\nthe value previously pointed to by s is unmodified, and\nwe allocate a new value and return it (albeit, it is probably allocated on the stack).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The model we adopt for any Julia function f is a function f  mathcalX to mathcalX times mathcalA where mathcalX is the real finite Hilbert space associated to the arguments to f prior to execution, and mathcalA is the real finite Hilbert space associated to any newly allocated data during execution which is externally visible after execution – any newly allocated data which is not made visible is of no concern.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In this example, mathcalX = RR^D times RR^D times RR^D times RR^S where D is the length of x / y / z, and S the length of s[] prior to running f. mathcalA = RR^D times RR, where the RR^D component corresponds to the freshly allocated memory that s references, and RR to the return value. Observe that we model Float64s as elements of RR, Vector{Float64}s as elements of RR^D (for some value of D), and Refs with whatever the model for their contents is. The keen-eyed reader will note that these choices abstract away several details which could conceivably be included in the model. In particular, Vector{Float64} is implemented via a memory buffer, a pointer to the start of this buffer, and an integer which indicates the length of this buffer – none of these details are exposed in the model.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In this example, some of the memory allocated during execution is made externally visible by modifying one of the arguments, not just via the return value.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The argument to f is the arguments to f before execution, and the output is the 2-tuple comprising the same arguments after execution and the values associated to any newly allocated / created data. Crucially, observe that we distinguish between the state of the arguments before and after execution.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"For our example, the exact form of f is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"f((x y z s)) = ((x y x odot y s) (2 x odot y sum_d=1^D x odot y))","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Observe that f behaves a little like a transition operator, in the that the first element of the tuple returned is the updated state of the arguments.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"This model is good enough for the vast majority of functions. Unfortunately it isn't sufficient to describe a function when arguments alias each other (e.g. consider the way in which this particular model is wrong if y aliases z). Fortunately this is only a problem in a small fraction of all cases of aliasing, so we defer discussion of this until later on.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Consider now how this approach can be used to model several additional Julia functions, and to obtain their derivatives and adjoints.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"sin(x::Float64)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"mathcalX = RR, mathcalA = RR, f(x) = (x sin(x)).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Thus the derivative is D f x (dotx) = (dotx cos(x) dotx), and its adjoint is D f x^ast (bary) = bary_x + bary_a cos(x), where bary = (bary_x bary_a).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Observe that this result is slightly different to the last example we saw involving sin.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"AD With Mutable Data","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Consider again","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function f!(x::Vector{Float64})\n    x .*= x\n    return sum(x)\nend","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Our framework is able to accomodate this function, and has essentially the same solution as the last time we saw this example:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"f(x) = (x odot x sum_n=1^N x_n^2)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Non-Mutating Functions","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A very interesting class of functions are those which do not modify their arguments. These are interesting because they are common, and are all that many AD frameworks like ChainRules.jl / Zygote.jl support – by considering this class of functions, we highlight some key similarities between these distinct rule systems.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"As always we can model these kinds of functions with a function f  mathcalX to mathcalX times mathcalA, but we additionally have that f must have the form","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"f(x) = (x varphi(x))","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"for some function varphi  mathcalX to mathcalA. The derivative is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"D f x (dotx) = (dotx D varphi x(dotx))","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Consider the usual inner product to derive the adjoint:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"beginalign\n    langle bary D f x (dotx) rangle = langle (bary_1 bary_2) (dotx D varphi x(dotx)) rangle nonumber \n        = langle bary_1 dotx rangle + langle bary_2 D varphi x(dotx) rangle nonumber \n        = langle bary_1 dotx rangle + langle D varphi x^ast (bary_2) dotx rangle nonumber quad text(by definition of the adjoint) \n        = langle bary_1 + D varphi x^ast (bary_2) dotx rangle nonumber\nendalign","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"So the adjoint of the derivative is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"D f x^ast (bary) =  bary_1 + D varphi x^ast (bary_2)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"We see the correct thing to do is to increment the gradient of the output – bary_1 – by the result of applying the adjoint of the derivative of varphi to bary_2. In a ChainRules.rrule the bary_1 term is always zero, but the D varphi x^ast (bary_2) term is essentially the same.","category":"page"},{"location":"understanding_mooncake/rule_system/#The-Rule-Interface-(Round-1)","page":"Mooncake.jl's Rule System","title":"The Rule Interface (Round 1)","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Having explained in principle what it is that a rule must do, we now take a first look at the interface we use to achieve this. A rule for a function foo with signature","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Tuple{typeof(foo), Float64} -> Float64","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"must have signature","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Tuple{Trule, CoDual{typeof(foo), NoFData}, CoDual{Float64, NoFData}} ->\n    Tuple{CoDual{Float64, NoFData}, Trvs_pass}","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"For example, if we call foo(5.0), its rules would be called as rule(CoDual(foo, NoFData()), CoDual(5.0, NoFData())). The precise definition and role of NoFData will be explained shortly, but the general scheme is that to a rule for foo you must pass foo itself, its arguments, and some additional data for book-keeping. foo and each of its arguments are paired with this additional book-keeping data via the CoDual type.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The rule returns another CoDual (it propagates book-keeping information forwards), along with a function which runs the reverse pass.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In a little more depth:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Notation: primal","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Throughout the rest of this document, we will refer to the function being differentiated as the \"primal\" computation, and its arguments as the \"primal\" arguments.","category":"page"},{"location":"understanding_mooncake/rule_system/#Forwards-Pass","page":"Mooncake.jl's Rule System","title":"Forwards Pass","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Inputs","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Each piece of each input to the primal is paired with shadow data, if it has a fixed address. For example, a Vector{Float64} argument is paired with another Vector{Float64}. The adjoint of f is accumulated into this shadow vector on the reverse pass. However, a Float64 argument gets paired with NoFData(), since it is a bits type and therefore has no fixed address.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Outputs","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A rule must return a Tuple of two things. The first thing must be a CoDual containing the output of the primal computation and its shadow memory (if it has any). The second must be a function which runs the reverse pass of AD – this will usually be a closure of some kind.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Functionality","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A rule must","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"ensure that the state of the primal components of all inputs / the output are as they would have been had the primal computation been run (up to differences due to finite precision arithmetic),\npropagate / construct the shadow memory associated to the output (initialised to zero), and\nconstruct the function to run the reverse pass – typically this will involve storing some quantities computed during the forwards pass.","category":"page"},{"location":"understanding_mooncake/rule_system/#Reverse-Pass","page":"Mooncake.jl's Rule System","title":"Reverse Pass","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The second element of the output of a rule is a function which runs the reverse pass.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Inputs","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The \"rdata\" associated to the output of the primal.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Outputs","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The \"rdata\" associated to the inputs of the primal.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Functionality","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"undo changes made to primal state on the forwards pass.\napply adjoint of derivative of primal operation, putting the results in the correct place.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"This description should leave you with (at least) a couple of questions. What is \"rdata\", and what is \"the correct place\" to put the results of applying the adjoint of the derivative? In order to address these, we need to discuss the types that Mooncake.jl uses to represent the results of AD, and to propagate results backwards on the reverse pass.","category":"page"},{"location":"understanding_mooncake/rule_system/#Representing-Gradients","page":"Mooncake.jl's Rule System","title":"Representing Gradients","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"We refer to both inputs and outputs of derivatives D f x  mathcalX to mathcalY as tangents, e.g. dotx or doty. Conversely, we refer to both inputs and outputs to the adjoint of this derivative D f x^ast  mathcalY to mathcalX as gradients, e.g. bary and barx.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Note, however, that the sets involved are the same whether dealing with a derivative or its adjoint. Consequently, we use the same type to represent both.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Representing Gradients","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"This package assigns to each type in Julia a unique tangent_type, the purpose of which is to contain the gradients computed during reverse mode AD. The extended docstring for tangent_type provides the best introduction to the types which are used to represent tangents / gradients.","category":"page"},{"location":"understanding_mooncake/rule_system/#Mooncake.tangent_type-Tuple{Any}-understanding_mooncake-rule_system","page":"Mooncake.jl's Rule System","title":"Mooncake.tangent_type","text":"tangent_type(P)\n\nThere must be a single type used to represents tangents of primals of type P, and it must be given by tangent_type(P).\n\nWarning: this function assumes the effects :removable and :consistent. This is necessary to ensure good performance, but imposes precise constraints on your implementation. If adding new methods to tangent_type, you should consult the extended help of Base.@assume_effects to see what this imposes upon your implementation.\n\nExtended help\n\nThe tangent types which Mooncake.jl uses are quite similar in spirit to ChainRules.jl. For example, tangent \"vectors\" for\n\nFloat64s are Float64s,\nVector{Float64}s are Vector{Float64}s, and\nstructs are other another (special) struct with field types specified recursively.\n\nThere are, however, some major differences. Firstly, while it is certainly true that the above tangent types are permissible in ChainRules.jl, they are not the uniquely permissible types. For example, ZeroTangent is also a permissible type of tangent for any of them, and Float32 is permissible for Float64. This is a general theme in ChainRules.jl – it intentionally declines to place restrictions on what type can be used to represent the tangent of a given type.\n\nMooncake.jl differs from this. It insists that each primal type is associated to a single tangent type. Furthermore, this type is always given by the function Mooncake.tangent_type(primal_type).\n\nConsider some more worked examples.\n\nInt\n\nInt is not a differentiable type, so its tangent type is NoTangent:\n\njulia> tangent_type(Int)\nNoTangent\n\nTuples\n\nThe tangent type of a Tuple is defined recursively based on its field types. For example\n\njulia> tangent_type(Tuple{Float64, Vector{Float64}, Int})\nTuple{Float64, Vector{Float64}, NoTangent}\n\nThere is one edge case to be aware of: if all of the field of a Tuple are non-differentiable, then the tangent type is NoTangent. For example,\n\njulia> tangent_type(Tuple{Int, Int})\nNoTangent\n\nStructs\n\nAs with Tuples, the tangent type of a struct is, by default, given recursively. In particular, the tangent type of a struct type is Tangent. This type contains a NamedTuple containing the tangent to each field in the primal struct.\n\nAs with Tuples, if all field types are non-differentiable, the tangent type of the entire struct is NoTangent.\n\nThere are a couple of additional subtleties to consider over Tuples though. Firstly, not all fields of a struct have to be defined. Fortunately, Julia makes it easy to determine how many of the fields might possibly not be defined. The tangent associated to any field which might possibly not be defined is wrapped in a PossiblyUninitTangent.\n\nFurthermore, structs can have fields whose static type is abstract. For example\n\njulia> struct Foo\n           x\n       end\n\nIf you ask for the tangent type of Foo, you will see that it is\n\njulia> tangent_type(Foo)\nTangent{@NamedTuple{x}}\n\nObserve that the field type associated to x is Any. The way to understand this result is to observe that\n\nx could have literally any type at runtime, so we know nothing about what its tangent  type must be until runtime, and\nwe require that the tangent type of Foo be unique.\n\nThe consequence of these two considerations is that the tangent type of Foo must be able to contain any type of tangent in its x field. It follows that the fieldtype of the x field of Foos tangent must be Any.\n\nMutable Structs\n\nThe tangent type for mutable structs have the same set of considerations as structs. The only difference is that they must themselves be mutable. Consequently, we use a type called MutableTangent to represent their tangents. It is a mutable struct with the same structure as Tangent.\n\nFor example, if you ask for the tangent_type of\n\njulia> mutable struct Bar\n           x::Float64\n       end\n\nyou will find that it is\n\njulia> tangent_type(Bar)\nMutableTangent{@NamedTuple{x::Float64}}\n\nPrimitive Types\n\nWe've already seen a couple of primitive types (Float64 and Int). The basic story here is that all primitive types require an explicit specification of what their tangent type must be.\n\nOne interesting case are Ptr types. The tangent type of a Ptr{P} is Ptr{T}, where T = tangent_type(P). For example\n\njulia> tangent_type(Ptr{Float64})\nPtr{Float64}\n\n\n\n\n\n","category":"method"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"FData and RData","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"While tangents are the things used to represent gradients and are what high-level interfaces will return, they are not what gets propagated forwards and backwards by rules during AD.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Rather, during AD, Mooncake.jl makes a fundamental distinction between data which is identified by its address in memory (Arrays, mutable structs, etc), and data which is identified by its value (is-bits types such as Float64, Int, and structs thereof). In particular, memory which is identified by its address gets assigned a unique location in memory in which its gradient lives (that this \"unique gradient address\" system is essential will become apparent when we discuss aliasing later on). Conversely, the gradient w.r.t. a value type resides in another value type.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The following docstring provides the best in-depth explanation.","category":"page"},{"location":"understanding_mooncake/rule_system/#Mooncake.fdata_type-Tuple{Any}-understanding_mooncake-rule_system","page":"Mooncake.jl's Rule System","title":"Mooncake.fdata_type","text":"fdata_type(T)\n\nReturns the type of the forwards data associated to a tangent of type T.\n\nExtended help\n\nRules in Mooncake.jl do not operate on tangents directly. Rather, functionality is defined to split each tangent into two components, that we call fdata (forwards-pass data) and rdata (reverse-pass data). In short, any component of a tangent which is identified by its address (e.g. a mutable structs or an Array) gets passed around on the forwards-pass of AD and is incremented in-place on the reverse-pass, while components of tangents identified by their value get propagated and accumulated only on the reverse-pass.\n\nGiven a tangent type T, you can find out what type its fdata and rdata must be with fdata_type(T) and rdata_type(T) respectively. A consequence of this is that there is exactly one valid fdata type and rdata type for each primal type.\n\nGiven a tangent t, you can get its fdata and rdata using f = fdata(t) and r = rdata(t) respectively. f and r can be re-combined to recover the original tangent using the binary version of tangent: tangent(f, r). It must always hold that\n\ntangent(fdata(t), rdata(t)) === t\n\nThe need for all of this is explained in the docs, but for now it suffices to consider our running examples again, and to see what their fdata and rdata look like.\n\nInt\n\nInts are non-differentiable types, so there is nothing to pass around on the forwards- or reverse-pass. Therefore\n\njulia> fdata_type(tangent_type(Int)), rdata_type(tangent_type(Int))\n(NoFData, NoRData)\n\nFloat64\n\nThe tangent type of Float64 is Float64. Float64s are identified by their value / have no fixed address, so\n\njulia> (fdata_type(Float64), rdata_type(Float64))\n(NoFData, Float64)\n\nVector{Float64}\n\nThe tangent type of Vector{Float64} is Vector{Float64}. A Vector{Float64} is identified by its address, so\n\njulia> (fdata_type(Vector{Float64}), rdata_type(Vector{Float64}))\n(Vector{Float64}, NoRData)\n\nTuple{Float64, Vector{Float64}, Int}\n\nThis is an example of a type which has both fdata and rdata. The tangent type for Tuple{Float64, Vector{Float64}, Int} is Tuple{Float64, Vector{Float64}, NoTangent}. Tuples have no fixed memory address, so we interogate each field on its own. We have already established the fdata and rdata types for each element, so we recurse to obtain:\n\njulia> T = tangent_type(Tuple{Float64, Vector{Float64}, Int})\nTuple{Float64, Vector{Float64}, NoTangent}\n\njulia> (fdata_type(T), rdata_type(T))\n(Tuple{NoFData, Vector{Float64}, NoFData}, Tuple{Float64, NoRData, NoRData})\n\nThe zero tangent for (5.0, [5.0]) is t = (0.0, [0.0]). fdata(t) returns (NoFData(), [0.0]), where the second element is === to the second element of t. rdata(t) returns (0.0, NoRData()). In this example, t contains a mixture of data, some of which is identified by its value, and some of which is identified by its address, so there is some fdata and some rdata.\n\nStructs\n\nStructs are handled in more-or-less the same way as Tuples, albeit with the possibility of undefined fields needing to be explicitly handled. For example, a struct such as\n\njulia> struct Foo\n           x::Float64\n           y\n           z::Int\n       end\n\nhas tangent type\n\njulia> tangent_type(Foo)\nTangent{@NamedTuple{x::Float64, y, z::NoTangent}}\n\nIts fdata and rdata are given by special FData and RData types:\n\njulia> (fdata_type(tangent_type(Foo)), rdata_type(tangent_type(Foo)))\n(Mooncake.FData{@NamedTuple{x::NoFData, y, z::NoFData}}, Mooncake.RData{@NamedTuple{x::Float64, y, z::NoRData}})\n\nPractically speaking, FData and RData both have the same structure as Tangents and are just used in different contexts.\n\nMutable Structs\n\nThe fdata for a mutable structs is its tangent, and it has no rdata. This is because mutable structs have fixed memory addresses, and can therefore be incremented in-place. For example,\n\njulia> mutable struct Bar\n           x::Float64\n           y\n           z::Int\n       end\n\nhas tangent type\n\njulia> tangent_type(Bar)\nMutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}\n\nand fdata / rdata types\n\njulia> (fdata_type(tangent_type(Bar)), rdata_type(tangent_type(Bar)))\n(MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}, NoRData)\n\nPrimitive Types\n\nAs with tangents, each primitive type must specify what its fdata and rdata is. See specific examples for details.\n\n\n\n\n\n","category":"method"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"More Info","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"See Tangents for complete information on what you must do if you wish to implement your own tangent type. (In the vast majority of cases this is unnecessary).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"CoDuals","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"CoDuals are simply used to bundle together a primal and an associated fdata, depending upon context. Occassionally, they are used to pair together a primal and a tangent.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A quick aside: Non-Differentiable Data","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In the introduction to algorithmic differentiation, we assumed that the domain / range of function are the same as that of its derivative. Unfortunately, this story is only partly true. Matters are complicated by the fact that not all data types in Julia can reasonably be thought of as forming a Hilbert space. e.g. the String type.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Consequently we introduce the special type NoTangent, instances of which can be thought of as representing the set containing only a 0 tangent. Morally speaking, for any non-differentiable data x, x + NoTangent() == x.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Other than non-differentiable data, the model of data in Julia as living in a real-valued finite dimensional Hilbert space is quite reasonable. Therefore, we hope readers will forgive us for largely ignoring the distinction between the domain and range of a function and that of its derivative in mathematical discussions, while simultaneously drawing a distinction when discussing code.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"TODO: update this to cast e.g. each possible String as its own vector space containing only the 0 element. This works, even if it seems a little contrived.","category":"page"},{"location":"understanding_mooncake/rule_system/#The-Rule-Interface-(Round-2)","page":"Mooncake.jl's Rule System","title":"The Rule Interface (Round 2)","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Now that you've seen what data structures are used to represent gradients, we can describe in more depth the detail of how fdata and rdata are used to propagate gradients backwards on the reverse pass.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Consider the function","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"julia> foo(x::Tuple{Float64, Vector{Float64}}) = x[1] + sum(x[2])\nfoo (generic function with 1 method)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The fdata for x is a Tuple{NoFData, Vector{Float64}}, and its rdata is a Tuple{Float64, NoRData}. The function returns a Float64, which has no fdata, and whose rdata is Float64. So on the forwards pass there is really nothing that needs to happen with the fdata for x.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Under the framework introduced above, the model for this function is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"f(x) = (x x_1 + sum_n=1^N (x_2)_n)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"where the vector in the second element of x is of length N. Now, following our usual steps, the derivative is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"D f x(dotx) = (dotx dotx_1 + sum_n=1^N (dotx_2)_n)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"A gradient for this is a tuple (bary_x bary_a) where bary_a in RR and bary_x in RR times RR^N. A quick derivation will show that the adjoint is","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"D f x^ast(bary) = ((bary_x)_1 + bary_a (bary_x)_2 + bary_a mathbf1)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"where mathbf1 is the vector of length N in which each element is equal to 1. (Observe that this agrees with the result we derived earlier for functions which don't mutate their arguments).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Now that we know what the adjoint is, we'll write down the rrule!!, and then explain what is going on in terms of the adjoint. This hand-written implementation is to aid your understanding – Mooncake.jl should be relied upon to generate this code automatically in practice.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"julia> function rrule!!(::CoDual{typeof(foo)}, x::CoDual{Tuple{Float64, Vector{Float64}}})\n           dx_fdata = x.dx\n           function dfoo_adjoint(dy::Float64)\n               dx_fdata[2] .+= dy\n               dx_1_rdata = dy\n               dx_rdata = (dx_1_rdata, NoRData())\n               return NoRData(), dx_rdata\n           end\n           x_p = x.x\n           return CoDual(x_p[1] + sum(x_p[2]), NoFData()), dfoo_adjoint\n       end;\n","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"where dy is the rdata for the output to foo. The rrule!! can be called with the appropriate CoDuals:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"julia> out, pb!! = rrule!!(CoDual(foo, NoFData()), CoDual((5.0, [1.0, 2.0]), (NoFData(), [0.0, 0.0])))\n(CoDual{Float64, NoFData}(8.0, NoFData()), var\"#dfoo_adjoint#1\"{Tuple{NoFData, Vector{Float64}}}((NoFData(), [0.0, 0.0])))","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"and the pullback with appropriate rdata:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"julia> pb!!(1.0)\n(NoRData(), (1.0, NoRData()))","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Observe that the forwards pass:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"computes the result of the initial function, and\npulls out the fdata for the Vector{Float64} component of the argument.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"As promised, the forwards pass really has nothing to do with the adjoint. It's just book-keeping and running the primal computation.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The reverse pass:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"increments each element of dx_fdata[2] by dy – this corresponds to (bary_x)_2 + bary_a mathbf1 in the adjoint,\nsets dx_1_rdata to dy – this corresponds (bary_x)_1 + bary_a subject to the constraint that (bary_x)_1 = 0,\nconstructs the rdata for x – this is essentially just book-keeping.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Each of these items serve to demonstrate more general points. The first that, upon entry into the reverse pass, all fdata values correspond to gradients for the arguments / output of f \"upon exit\" (for the components of these which are identified by their address), and once the reverse-pass finishes running, they must contain the gradients w.r.t. the arguments of f \"upon entry\".","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The second that we always assume that the components of bary_x which are identified by their value have zero-rdata.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"The third is that the components of the arguments of f which are identified by their value must have rdata passed back explicitly by a rule, while the components of the arguments to f which are identified by their address get their gradients propagated back implicitly (i.e. via the in-place modification of fdata).","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Reminder: the first element of the tuple returned by dfoo_adjoint is the rdata associated to foo itself, hence it is NoRData.","category":"page"},{"location":"understanding_mooncake/rule_system/#Testing","page":"Mooncake.jl's Rule System","title":"Testing","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Mooncake.jl has an almost entirely automated system for testing rules – Mooncake.TestUtils.test_rule. You should absolutely make use of these when writing rules.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"TODO: improve docstring for testing functionality.","category":"page"},{"location":"understanding_mooncake/rule_system/#Summary","page":"Mooncake.jl's Rule System","title":"Summary","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"In this section we have covered the rule system. Every callable object / function in the Julia language is differentiated using rules with this interface, whether they be hand-written rrule!!s, or rules derived by Mooncake.jl.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"At this point you should be equipped with enough information to understand what a rule in Mooncake.jl does, and how you can write your own ones. Later sections will explain how Mooncake.jl goes about deriving rules itself in a recursive manner, and introduce you to some of the internals.","category":"page"},{"location":"understanding_mooncake/rule_system/#Asides","page":"Mooncake.jl's Rule System","title":"Asides","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/#Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?","page":"Mooncake.jl's Rule System","title":"Why Uniqueness of Type For Tangents / FData / RData?","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Why does Mooncake.jl insist that each primal type P be paired with a single tangent type T, as opposed to being more permissive. There are a few notable reasons:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"To provide a precise interface. Rules pass fdata around on the forwards pass and rdata on the reverse pass – being able to make strong assumptions about the type of the fdata / rdata given the primal type makes implementing rules much easier in practice.\nConditional type stability. We wish to have a high degree of confidence that if the primal code is type-stable, then the AD code will also be. It is straightforward to construct type stable primal codes which have type-unstable forwards and reverse passes if you permit there to be more than one fdata / rdata type for a given primal. So while uniqueness is certainly not sufficient on its own to guarantee conditional type stability, it is probably necessary in general.\nTest-case generation and coverage. There being a unique tangent / fdata / rdata type for each primal makes being confident that a given rule is being tested thoroughly much easier. For a given primal, rather than there being many possible input / output types to consider, there is just one.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"This topic, in particular what goes wrong with permissive tangent type systems like those employed by ChainRules, deserves a more thorough treatment – hopefully someone will write something more expansive on this topic at some point.","category":"page"},{"location":"understanding_mooncake/rule_system/#Why-Support-Closures-But-Not-Mutable-Globals","page":"Mooncake.jl's Rule System","title":"Why Support Closures But Not Mutable Globals","text":"","category":"section"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"First consider why closures are straightforward to support. Look at the type of the closure produced by foo:","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"function foo(x)\n    function bar(y)\n        x .+= y\n        return nothing\n    end\n    return bar\nend\nbar = foo(randn(5))\ntypeof(bar)\n\n# output\nvar\"#bar#1\"{Vector{Float64}}","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Observe that the Vector{Float64} that we passed to foo, and closed over in bar, is present in the type. This alludes to the fact that closures are basically just callable structs whose fields are the closed-over variables. Since the function itself is an argument to its rule, everything enters the rule for bar via its arguments, and the rule system developed in this document applies straightforwardly.","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"On the other hand, globals do not appear in the functions that they are a part of. For example,","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"const a = randn(10)\n\nfunction g(x)\n    a .+= x\n    return nothing\nend\n\ntypeof(g)\n\n# output\ntypeof(g) (singleton type of function g, subtype of Function)","category":"page"},{"location":"understanding_mooncake/rule_system/","page":"Mooncake.jl's Rule System","title":"Mooncake.jl's Rule System","text":"Neither the value nor type of a are present in g. Since a doesn't enter g via its arguments, it is unclear how it should be handled in general.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Writing-Custom-Tangent-Types","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.jl associates each primal type (the original data structure) with a unique tangent type (the type that stores its derivative information). By default, Mooncake can automatically derive tangent types for most Julia structs. However, for recursive types—that is, types that reference themselves (directly or indirectly)—the default mechanism can fail, often resulting in a stack overflow. In such cases, you must manually define a custom tangent type and implement the required interface.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"This guide walks you through the process, from understanding Mooncake’s tangent design to testing your custom tangent type.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#1.-Tangent-Types-and-the-FData/RData-Split","page":"Writing Custom Tangent Types","title":"1. Tangent Types and the FData/RData Split","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Before diving in, let's review how Mooncake represents tangents (gradients) and why it splits them into forward data (fdata) and reverse data (rdata). For more details, see the Mooncake.jl Rule System documentation.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Tangent-Types","page":"Writing Custom Tangent Types","title":"Tangent Types","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"For a given primal type P, Mooncake.tangent_type(P) returns the tangent type associated with P. By default, Mooncake uses generic Tangent{...} structs to hold fieldwise derivatives. For example, a simple struct’s tangent might be Tangent{NamedTuple} with the same field names as the primal. Mutable structs get a MutableTangent type. Each field’s tangent is itself of type tangent_type(field_type).","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Forward-Data-vs.-Reverse-Data","page":"Writing Custom Tangent Types","title":"Forward Data vs. Reverse Data","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake splits a tangent object into two parts:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"fdata: Forward-pass data, typically components identified by address (e.g., arrays or mutable fields), which are carried along and updated in-place.\nrdata: Reverse-pass data, typically value-identified components (e.g., plain numbers), only needed for the reverse pass.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"This design improves performance by minimizing what needs to be propagated during the forward pass.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Example:   Consider Tuple{Float64, Vector{Float64}, Int}. Its tangent type is Tuple{Float64, Vector{Float64}, NoTangent} (since Int is non-differentiable). The fdata type is Tuple{NoFData, Vector{Float64}, NoFData}—only the vector is forwarded. The rdata type is Tuple{Float64, NoRData, NoRData}—only the float’s derivative is carried in reverse. Mooncake ensures that for any tangent t, if f = Mooncake.fdata(t) and r = Mooncake.rdata(t), then Mooncake.tangent(f, r) reconstructs the original t.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#2.-Why-Recursive-Types-Are-Challenging","page":"Writing Custom Tangent Types","title":"2. Why Recursive Types Are Challenging","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"A recursive type is a struct that contains itself (directly or indirectly) as a field. For example:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"mutable struct A{T}\n    x::T\n    a::Union{A{T},Nothing}\n\n    A(x::T) where {T} = new{T}(x, nothing)\n    A(x::T, child::A{T}) where {T} = new{T}(x, child)\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Here, A has a self-referential field a. If you ask Mooncake for the tangent type of A{Float64}, it tries to construct something like Tangent{Tuple{Float64, tangent_type(A)}}, which leads to infinite recursion. Calling tangent_type(A) in this scenario will overflow the stack.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"To solve this, you must manually define a custom tangent type that breaks this circular dependency.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#3.-Defining-a-Custom-Tangent-Type-for-Recursion","page":"Writing Custom Tangent Types","title":"3. Defining a Custom Tangent Type for Recursion","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"The first step is to define a new type to represent the tangent of A. This custom tangent should mimic the structure of A, but in a way that resolves the recursion:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"mutable struct TangentForA{Tx}\n    x::Tx\n    a::Union{TangentForA{Tx}, Mooncake.NoTangent}\n\n    function TangentForA{Tx}(x_tangent::Tx) where {Tx}\n        new{Tx}(x_tangent, Mooncake.NoTangent())\n    end\n\n    function TangentForA{Tx}(x_tangent::Tx, a_tangent::Union{TangentForA{Tx}, Mooncake.NoTangent}) where {Tx}\n        new{Tx}(x_tangent, a_tangent)\n    end\n\n    # This constructor is required by Mooncake's internal machinery for constructing tangents from named tuples\n    function TangentForA{Tx}(nt::@NamedTuple{x::Tx, a::Union{Mooncake.NoTangent, TangentForA{Tx}}}) where {Tx}\n        return new{Tx}(nt.x, nt.a)\n    end\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"This TangentForA type mirrors A's fields. Its a field is either another TangentForA (for nested or cyclic primal structures) or Mooncake.NoTangent (if the primal A.a is nothing). This explicit definition breaks the infinite type recursion that would occur with naive tangent derivation.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#4.-Registering-Your-Tangent-Type-with-Mooncake","page":"Writing Custom Tangent Types","title":"4. Registering Your Tangent Type with Mooncake","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Defining the tangent type is not enough—you must register it with Mooncake’s interface so Mooncake knows to use it and how to split it into fdata/rdata. Implement these methods:","category":"page"},{"location":"developer_documentation/custom_tangent_type/#4.1.-tangent_type","page":"Writing Custom Tangent Types","title":"4.1. tangent_type","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Tell Mooncake that the tangent of A is TangentForA:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function Mooncake.tangent_type(::Type{A{T}}) where {T}\n    Tx = Mooncake.tangent_type(T)\n    return Tx == Mooncake.NoTangent ? Mooncake.NoTangent : TangentForA{Tx}\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"This overrides the default mechanism and associates A with your custom tangent type.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#4.2.-fdata_type-and-rdata_type","page":"Writing Custom Tangent Types","title":"4.2. fdata_type and rdata_type","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Define the types of forward and reverse data for TangentForA. In this example, since both A and TangentForA are mutable, all updates can be done in-place, so the fdata is the tangent itself and rdata is NoRData. We shouldn't need to specifically define fdata_type and rdata_type because Mooncake can infer them in this case. In other cases, you may need to split these more carefully and define them explicitly.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#4.3.-tangent-(Combining-Function)","page":"Writing Custom Tangent Types","title":"4.3. tangent (Combining Function)","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake provides Mooncake.tangent to reassemble a tangent from fdata and rdata. For your type:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.tangent(t::TangentForA{Tx}, ::Mooncake.NoRData) where {Tx} = t","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"This ensures that Mooncake.tangent(Mooncake.fdata(t), Mooncake.rdata(t)) === t, which is a core requirement of Mooncake's tangent interface (see fdata_type). Mooncake’s tests will check that the reassembled tangent is the exact same object as the original.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"With these methods, your custom type is now connected to Mooncake’s AD system.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#5.-Bottom-Up-Integration:-Implement-Only-What-You-Need","page":"Writing Custom Tangent Types","title":"5. Bottom-Up Integration: Implement Only What You Need","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake provides extensive coverage and thorough testing. To get started, you can implement just enough to differentiate simple functions and add more as needed. For example, consider:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"f1(a::A) = 2.0 * a.x","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"When you try to differentiate this, Mooncake will complain it lacks an rrule!! for lgetfield. The lgetfield function is Mooncake's internal version of getfield that accepts a Val type for the field name, enabling better type stability. You need to implement it:","category":"page"},{"location":"developer_documentation/custom_tangent_type/#5.1.-Field-Access-(lgetfield)-Rule","page":"Writing Custom Tangent Types","title":"5.1. Field Access (lgetfield) Rule","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(Mooncake.lgetfield),A{T},Val} where {T}\n\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake.lgetfield)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_name_cd::Mooncake.CoDual{Val{FieldName}},\n) where {T,Tx,FieldName}\n    a = Mooncake.primal(obj_cd)\n    a_tangent = Mooncake.tangent(obj_cd)\n\n    value_primal = getfield(a, FieldName)\n    actual_field_tangent_value = FieldName === :x ? a_tangent.x :\n                                FieldName === :a ? a_tangent.a :\n                                throw(ArgumentError(\"lgetfield: Unknown field '$FieldName' for type A.\"))\n\n    value_output_fdata = Mooncake.fdata(actual_field_tangent_value)\n    y_cd = Mooncake.CoDual(value_primal, value_output_fdata)\n\n    function lgetfield_A_pullback(Δy_rdata)\n        if FieldName === :x\n            if !(Δy_rdata isa Mooncake.NoRData)\n                a_tangent.x = Mooncake.increment_rdata!!(a_tangent.x, Δy_rdata)\n            end\n        elseif FieldName === :a\n            @assert Δy_rdata isa Mooncake.NoRData  # for mutable TangentForA, rdata is not used\n        end\n        return (Mooncake.NoRData(), Mooncake.NoRData(), Mooncake.NoRData())\n    end\n    return y_cd, lgetfield_A_pullback\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/#5.2.-Zeroing-Out-the-Tangent","page":"Writing Custom Tangent Types","title":"5.2. Zeroing Out the Tangent","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake will next require set_to_zero!!:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function Mooncake.set_to_zero!!(t::TangentForA{Tx}) where Tx\n    t.x = Mooncake.set_to_zero!!(t.x)\n    if !(t.a isa Mooncake.NoTangent)\n        Mooncake.set_to_zero!!(t.a)\n    end\n    return t\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"With these, you can now differentiate simple functions:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"a = A(1.0)\nval, grad = DifferentiationInterface.value_and_gradient(f1, AutoMooncake(; config=nothing), a)","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Another example:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function prod_x(a::A{T}) where {T}\n    a_val = a.x\n    return a.a === nothing ? a_val : a_val * prod_x(a.a)\nend\nsum_a = A(1.0, A(2.0, A(3.0)))\nval_f5, grad_f5 = DifferentiationInterface.value_and_gradient(prod_x, AutoMooncake(; config=nothing), sum_a)","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Depending on your use case, this may be sufficient.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#6.-From-\"It-Works!\"-to-Passing-[TestUtils.test_data](@ref)","page":"Writing Custom Tangent Types","title":"6. From \"It Works!\" to Passing TestUtils.test_data","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"To fully integrate with Mooncake, you must implement additional operations on your tangent type so Mooncake’s algorithms can manipulate it robustly. At minimum, Mooncake expects the following functions for any custom tangent type:","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Checklist:-Functions-Needed-for-Recursive-Struct-Support","page":"Writing Custom Tangent Types","title":"Checklist: Functions Needed for Recursive Struct Support","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Below is a checklist of most functions you need to make Mooncake.TestUtils.test_data pass for the recursive struct A and its tangent TangentForA. They are grouped by their role in Mooncake’s test suite.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Primitive-rrules-(Mandatory-Differentiation-Hooks)","page":"Writing Custom Tangent Types","title":"Primitive rrules (Mandatory Differentiation Hooks)","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"You must provide adjoints for every getfield/lgetfield variant that appears in tests.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Primitive Variants to implement\nlgetfield (A, Val{:x}), (A, Val{:a}), plus Symbol, Int, and (Val, Val) fallbacks\nBase.getfield Same coverage as lgetfield\n_new_ A(x), A(x, a::A), A(x, nothing)—three separate rrule!! methods\nlsetfield! (A, Val{:field}, new_value) including both Symbol & Int field IDs","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Core-Tangent-Operations","page":"Writing Custom Tangent Types","title":"Core Tangent Operations","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Function Purpose/feature tested\nzero_tangent_internal Structure-preserving zero generation with cycle cache\nrandn_tangent_internal Random tangent generator (for stochastic interface tests)\nset_to_zero_internal!! Recursive in-place reset with cycle protection\nincrement_internal!! In-place accumulation used in reverse pass\n_add_to_primal_internal Adds a tangent to a primal (needed for finite-difference checks)\n_diff_internal Structural diff between two primals → tangent\n_dot_internal Inner-product between tangents (dual-number consistency)\n_scale_internal Scalar × tangent scaling","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Test-Utilities","page":"Writing Custom Tangent Types","title":"Test Utilities","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Override What it proves\nTestUtils.populate_address_map_internal Tangent-to-primal pointer correspondence (cycle safety)\nTestUtils.has_equal_data_internal (internal version of TestUtils.has_equal_data (primal & tangent) Deep equality ignoring pointer identity; handles recursion","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"By following this process—starting with a minimal set of methods and expanding as Mooncake requests more—you can support recursive types robustly in Mooncake.jl.","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Appendix:-Full-Implementations","page":"Writing Custom Tangent Types","title":"Appendix: Full Implementations","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Before defining the full implementation, TestUtils.test_data will fail.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"try\n    Mooncake.TestUtils.test_data(Random.default_rng(), A(1.0, A(2.0, A(3.0))))\ncatch e\n    @show e\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Basic-tangent-interface-methods","page":"Writing Custom Tangent Types","title":"Basic tangent interface methods","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"First, implement the core tangent interface methods:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.rdata(::TangentForA{Tx}) where {Tx} = Mooncake.NoRData()\nMooncake.tangent(t::TangentForA{Tx}, ::Mooncake.NoRData) where {Tx} = t\n\nfunction Mooncake.tangent_type(::Type{TangentForA{Tx}}) where {Tx}\n    return TangentForA{Tx}\nend\nMooncake.tangent_type(::Type{TangentForA{Tx}}, ::Type{Mooncake.NoRData}) where {Tx} = TangentForA{Tx}","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Field-access-helper-functions","page":"Writing Custom Tangent Types","title":"Field access helper functions","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Define utility functions for field access:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"\n_field_symbol(f::Symbol) = f\n_field_symbol(i::Int) = i == 1 ? :x : i == 2 ? :a :\n    throw(ArgumentError(\"Invalid field index '$i' for type A.\"))\n_field_symbol(::Type{Val{F}}) where F = _field_symbol(F)\n_field_symbol(::Val{F}) where F = _field_symbol(F)","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Common-getfield-rule-implementation","page":"Writing Custom Tangent Types","title":"Common getfield rule implementation","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Define a shared helper for getfield rules:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function _rrule_getfield_common(obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n                                field_sym::Symbol,\n                                n_args::Int) where {T,Tx}\n    a = Mooncake.primal(obj_cd)\n    a_t = Mooncake.tangent(obj_cd)\n\n    value_primal = getfield(a, field_sym)\n\n    field_tan = field_sym === :x ? a_t.x : field_sym === :a ? a_t.a :\n        throw(ArgumentError(\"Unknown field '$field_sym' for type A.\"))\n\n    y_cd = Mooncake.CoDual(value_primal, Mooncake.fdata(field_tan))\n\n    function pb(Δy_rdata)\n        if field_sym === :x\n            if !(Δy_rdata isa Mooncake.NoRData)\n                a_t.x = Mooncake.increment_rdata!!(a_t.x, Δy_rdata)\n            end\n        else\n            @assert Δy_rdata isa Mooncake.NoRData\n        end\n        return ntuple(_ -> Mooncake.NoRData(), n_args)\n    end\n\n    return y_cd, pb\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/#lgetfield-and-getfield-rules","page":"Writing Custom Tangent Types","title":"lgetfield and getfield rules","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Implement the various field access rules:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(Mooncake.lgetfield),A{T},Val{S}} where {T,S<:Symbol}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake.lgetfield),Mooncake.NoFData},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    ::Mooncake.CoDual{Val{FieldName},Mooncake.NoFData},\n) where {T,Tx,FieldName}\n    field_symbol = _field_symbol(FieldName)\n    return _rrule_getfield_common(obj_cd, field_symbol, 3)\nend\n\n# Rule for lgetfield(A, Val{Field}, Val{Order})\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(Mooncake.lgetfield),A{T},Val,Val} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake.lgetfield),F},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    ::Mooncake.CoDual{Val{VFieldName},Mooncake.NoFData},\n    ::Mooncake.CoDual{Val{VOrderName},Mooncake.NoFData}\n) where {F,T,Tx,VFieldName,VOrderName}\n    field_symbol = _field_symbol(VFieldName)\n    return _rrule_getfield_common(obj_cd, field_symbol, 4)\nend\n\n# Rule for getfield(A, ::Symbol)\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(getfield),A{T},Symbol} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(getfield)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_name_symbol_cd::Mooncake.CoDual{Symbol,Mooncake.NoFData},\n) where {T,Tx}\n    field_sym = Mooncake.primal(field_name_symbol_cd)\n    return _rrule_getfield_common(obj_cd, field_sym, 3)\nend\n\n# Rule for getfield(A, ::Int)\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(getfield),A{T},Int} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(getfield)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_idx_cd::Mooncake.CoDual{Int,Mooncake.NoFData},\n) where {T,Tx}\n    field_sym = _field_symbol(Mooncake.primal(field_idx_cd))\n    return _rrule_getfield_common(obj_cd, field_sym, 3)\nend\n\n# Rule for getfield(A, ::Symbol, ::Symbol) e.g. getfield(obj, :field, :not_atomic)\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(getfield),A{T},Symbol,Symbol} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(getfield)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_name_symbol_cd::Mooncake.CoDual{Symbol,Mooncake.NoFData},\n    ::Mooncake.CoDual{Symbol,Mooncake.NoFData}\n) where {T,Tx}\n    field_sym = Mooncake.primal(field_name_symbol_cd)\n    return _rrule_getfield_common(obj_cd, field_sym, 4)\nend\n\n# Rule for getfield(A, ::Int, ::Symbol) e.g. getfield(obj, 1, :not_atomic)\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(getfield),A{T},Int,Symbol} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(getfield)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_idx_cd::Mooncake.CoDual{Int,Mooncake.NoFData},\n    ::Mooncake.CoDual{Symbol,Mooncake.NoFData}\n) where {T,Tx}\n    field_sym = _field_symbol(Mooncake.primal(field_idx_cd))\n    return _rrule_getfield_common(obj_cd, field_sym, 4)\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Core-tangent-operations","page":"Writing Custom Tangent Types","title":"Core tangent operations","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Implement the essential tangent manipulation functions:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function Mooncake.zero_tangent_internal(p::A{T}, dict::Mooncake.MaybeCache) where {T}\n    Tx = Mooncake.tangent_type(T)\n    Tx == Mooncake.NoTangent && return Mooncake.NoTangent()\n    if haskey(dict, p)\n        return dict[p]::TangentForA{Tx}\n    end\n    x_t = Mooncake.zero_tangent_internal(p.x, dict)::Tx\n    t = TangentForA{Tx}(x_t)\n    dict[p] = t\n    if p.a === nothing\n        t.a = Mooncake.NoTangent()\n    else\n        t.a = Mooncake.zero_tangent_internal(p.a, dict)::Union{TangentForA{Tx},Mooncake.NoTangent}\n    end\n    return t\nend\n\nfunction Mooncake.randn_tangent_internal(rng::AbstractRNG, p::A{T}, dict::Mooncake.MaybeCache) where {T}\n    Tx = Mooncake.tangent_type(T)\n    Tx == Mooncake.NoTangent && return Mooncake.NoTangent()\n    if haskey(dict, p)\n        return dict[p]::TangentForA{Tx}\n    end\n    x_t = Mooncake.randn_tangent_internal(rng, p.x, dict)::Tx\n    t = TangentForA{Tx}(x_t)\n    dict[p] = t\n    if p.a === nothing\n        t.a = Mooncake.NoTangent()\n    else\n        t.a = Mooncake.randn_tangent_internal(rng, p.a, dict)::Union{TangentForA{Tx},Mooncake.NoTangent}\n    end\n    return t\nend\n\nfunction Mooncake.increment_internal!!(c::Mooncake.IncCache, t::TangentForA{Tx}, s::TangentForA{Tx}) where {Tx}\n    (haskey(c, t) || t === s) && return t\n    c[t] = true\n    t.x = Mooncake.increment_internal!!(c, t.x, s.x)\n    if !(t.a isa Mooncake.NoTangent)\n        t.a = Mooncake.increment_internal!!(c, t.a, s.a)\n    end\n    return t\nend\n\nfunction Mooncake.set_to_zero_internal!!(c::Mooncake.IncCache, t::TangentForA{Tx}) where {Tx}\n    haskey(c, t) && return t\n    c[t] = false\n    t.x = Mooncake.set_to_zero_internal!!(c, t.x)\n    if !(t.a isa Mooncake.NoTangent)\n        t.a = Mooncake.set_to_zero_internal!!(c, t.a)\n    end\n    return t\nend\n\nfunction Mooncake._add_to_primal_internal(c::Mooncake.MaybeCache, p::A{T}, t::TangentForA{Tx}, unsafe::Bool) where {T,Tx}\n    key = (p, t, unsafe)\n    haskey(c, key) && return c[key]::A{T}\n    x_new = Mooncake._add_to_primal_internal(c, p.x, t.x, unsafe)\n    a_new = p.a === nothing ? nothing : Mooncake._add_to_primal_internal(c, p.a, t.a, unsafe)\n    p_new = a_new === nothing ? A(x_new) : A(x_new, a_new)\n    c[key] = p_new\n    return p_new\nend\n\nfunction Mooncake._diff_internal(c::Mooncake.MaybeCache, p::A{T}, q::A{T}) where {T}\n    key = (p, q)\n    haskey(c, key) && return c[key]::Union{TangentForA{Mooncake.tangent_type(T)},Mooncake.NoTangent}\n    Tx = Mooncake.tangent_type(T)\n    if Tx == Mooncake.NoTangent\n        t = Mooncake.NoTangent()\n        c[key] = t\n        return t\n    end\n    x_t = Mooncake._diff_internal(c, p.x, q.x)\n    a_t = if p.a === nothing\n        Mooncake.NoTangent()\n    else\n        Mooncake._diff_internal(c, p.a, q.a)\n    end\n    t = TangentForA{Tx}(x_t, a_t)\n    c[key] = t\n    return t\nend\n\nfunction Mooncake._dot_internal(c::Mooncake.MaybeCache, t::TangentForA{Tx}, s::TangentForA{Tx}) where {Tx}\n    key = (t, s)\n    haskey(c, key) && return c[key]::Float64\n    c[key] = 0.0\n    res = Mooncake._dot_internal(c, t.x, s.x)\n    if !(t.a isa Mooncake.NoTangent)\n        res += Mooncake._dot_internal(c, t.a, s.a)\n    end\n    c[key] = res\n    return res\nend\n\nfunction Mooncake._scale_internal(c::Mooncake.MaybeCache, a::Float64, t::TangentForA{Tx}) where {Tx}\n    haskey(c, t) && return c[t]::TangentForA{Tx}\n    x_new = Mooncake._scale_internal(c, a, t.x)\n    a_new = t.a isa Mooncake.NoTangent ? Mooncake.NoTangent() : Mooncake._scale_internal(c, a, t.a)\n    t_new = TangentForA{Tx}(x_new, a_new)\n    c[t] = t_new\n    return t_new\nend\n\n@inline function Mooncake.get_tangent_field(t::TangentForA, f)\n    if f === :x\n        return t.x\n    elseif f === :a\n        return t.a\n    else\n        throw(error(\"Unhandled field $f\"))\n    end\nend\n\nMooncake.__verify_fdata_value(::IdDict{Any,Nothing}, ::A{T}, ::TangentForA{Tx}) where {T,Tx} = nothing","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Constructor-rules","page":"Writing Custom Tangent Types","title":"Constructor rules","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Implement rrules for the A constructors:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"# rrule for A(x::T)\nMooncake.@is_primitive Mooncake.DefaultCtx Tuple{typeof(Mooncake._new_),Type{A{T}},T} where {T}\n\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake._new_)},\n    ::Mooncake.CoDual{Type{A{T}}},\n    x_cd::Mooncake.CoDual{T},\n) where {T}\n    primal_x = Mooncake.primal(x_cd)\n    y_primal = A(primal_x)\n\n    Tx_for_field = Mooncake.tangent_type(T)\n\n    y_fdata = if Tx_for_field == Mooncake.NoTangent\n        Mooncake.NoTangent()\n    else\n        raw_x_tan = Mooncake.tangent(x_cd)\n        processed_x_tan = if (raw_x_tan isa Mooncake.NoTangent) || (raw_x_tan isa Mooncake.NoFData)\n            Mooncake.zero_tangent(primal_x)::Tx_for_field\n        else\n            raw_x_tan\n        end\n        TangentForA{Tx_for_field}(processed_x_tan)\n    end\n\n    y_cd = Mooncake.CoDual(y_primal, y_fdata)\n\n    function _new_A_x_pullback(Δy_rdata)\n        # For scalar types, return the appropriate zero value\n        if T <: AbstractFloat || T <: Integer\n            return (Mooncake.NoRData(), Mooncake.NoRData(), zero(T))\n        else\n            x_tangent_val = Mooncake.tangent(x_cd)\n            rdata_for_x = (x_tangent_val isa Mooncake.NoTangent) || (x_tangent_val isa Mooncake.NoFData) ? Mooncake.NoRData() : zero(Mooncake.rdata(x_tangent_val))\n            return (Mooncake.NoRData(), Mooncake.NoRData(), rdata_for_x)\n        end\n    end\n    return y_cd, _new_A_x_pullback\nend\n\n# A(x::T, a::A{T})\nMooncake.@is_primitive Mooncake.DefaultCtx Tuple{typeof(Mooncake._new_),Type{A{T}},T,A{T}} where {T}\n\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake._new_)},\n    ::Mooncake.CoDual{Type{A{T}}},\n    x_cd::Mooncake.CoDual{T},\n    a_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n) where {T,Tx}\n    primal_x = Mooncake.primal(x_cd)\n\n    raw_tangent_x = Mooncake.tangent(x_cd)\n\n    final_tangent_for_x_field = if (raw_tangent_x isa Mooncake.NoTangent) || (raw_tangent_x isa Mooncake.NoFData)\n        Mooncake.zero_tangent(primal_x)::Tx\n    else\n        raw_tangent_x\n    end\n\n    primal_a = Mooncake.primal(a_cd)\n    tangent_a = Mooncake.tangent(a_cd)\n\n    y_primal = A(primal_x, primal_a)\n\n    y_fdata = TangentForA{Tx}(final_tangent_for_x_field, tangent_a)\n\n    y_cd = Mooncake.CoDual(y_primal, y_fdata)\n\n    function _new_A_x_a_pullback(Δy_rdata)\n        # For scalar types, return the appropriate zero value\n        if T <: AbstractFloat || T <: Integer\n            rdata_for_x = zero(T)\n        else\n            x_tangent_val = Mooncake.tangent(x_cd)\n            rdata_for_x = (x_tangent_val isa Mooncake.NoTangent) || (x_tangent_val isa Mooncake.NoFData) ? Mooncake.NoRData() : zero(Mooncake.rdata(x_tangent_val))\n        end\n\n        rdata_for_a = Mooncake.NoRData()\n\n        return (Mooncake.NoRData(), Mooncake.NoRData(), rdata_for_x, rdata_for_a)\n    end\n    return y_cd, _new_A_x_a_pullback\nend\n\n# A(x::T, a::Nothing)\nMooncake.@is_primitive Mooncake.DefaultCtx Tuple{typeof(Mooncake._new_),Type{A{T}},T,Nothing} where {T}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake._new_)},\n    ::Mooncake.CoDual{Type{A{T}}},\n    x_cd::Mooncake.CoDual{T},\n    a_nothing_cd::Mooncake.CoDual{Nothing,Mooncake.NoFData},\n) where {T}\n    primal_x = Mooncake.primal(x_cd)\n\n    y_primal = A(primal_x)\n\n    Tx = Mooncake.tangent_type(T)\n\n    y_fdata = if Tx == Mooncake.NoTangent\n        Mooncake.NoTangent()\n    else\n        raw_tangent_x = Mooncake.tangent(x_cd)\n        processed_tx = (raw_tangent_x isa Mooncake.NoTangent) || (raw_tangent_x isa Mooncake.NoFData) ? Mooncake.zero_tangent(primal_x) : raw_tangent_x\n        TangentForA{Tx}(processed_tx)\n    end\n\n    y_cd = Mooncake.CoDual(y_primal, y_fdata)\n\n    function _new_A_x_nothing_pullback(Δy_rdata)\n        # For Float64 inputs, we need to return Float64 rdata, not NoRData\n        if T <: AbstractFloat\n            return (Mooncake.NoRData(), Mooncake.NoRData(), zero(T), Mooncake.NoRData())\n        else\n            x_tangent_val = Mooncake.tangent(x_cd)\n            rdata_for_x = (x_tangent_val isa Mooncake.NoTangent) || (x_tangent_val isa Mooncake.NoFData) ? Mooncake.NoRData() : zero(Mooncake.rdata(x_tangent_val))\n            return (Mooncake.NoRData(), Mooncake.NoRData(), rdata_for_x, Mooncake.NoRData())\n        end\n    end\n    return y_cd, _new_A_x_nothing_pullback\nend\n\n# rrule for lsetfield!(A)\nMooncake.@is_primitive Mooncake.MinimalCtx Tuple{typeof(Mooncake.lsetfield!),A{T},Val{F},Any} where {T,F}\nfunction Mooncake.rrule!!(\n    ::Mooncake.CoDual{typeof(Mooncake.lsetfield!)},\n    obj_cd::Mooncake.CoDual{A{T},TangentForA{Tx}},\n    field_val_cd::Mooncake.CoDual{Val{FieldName}},\n    new_val_cd::Mooncake.CoDual{V}\n) where {T,Tx,FieldName,V}\n    a = Mooncake.primal(obj_cd)\n    a_t = Mooncake.tangent(obj_cd)\n    new_val_primal = Mooncake.primal(new_val_cd)\n    new_val_tangent = Mooncake.tangent(new_val_cd)\n\n    field_sym = if FieldName isa Symbol\n        FieldName\n    elseif FieldName isa Int\n        FieldName == 1 ? :x : FieldName == 2 ? :a : throw(ArgumentError(\"lsetfield!: Invalid integer field '$FieldName' for type A.\"))\n    else\n        throw(ArgumentError(\"lsetfield!: Unsupported field type for lsetfield!\"))\n    end\n\n    old_val = getfield(a, field_sym)\n    old_tangent = if field_sym === :x\n        a_t.x\n    elseif field_sym === :a\n        a_t.a\n    else\n        throw(ArgumentError(\"lsetfield!: Unknown field '$field_sym' for type A.\"))\n    end\n\n    Mooncake.lsetfield!(a, Val(field_sym), new_val_primal)\n    new_field_tangent = if (new_val_tangent isa Mooncake.NoTangent) || (new_val_tangent isa Mooncake.NoFData)\n        Mooncake.zero_tangent(new_val_primal)\n    else\n        new_val_tangent\n    end\n    if field_sym === :x\n        a_t.x = new_field_tangent\n    elseif field_sym === :a\n        a_t.a = new_field_tangent\n    end\n\n    y_fdata = Mooncake.fdata(new_field_tangent)\n    y_cd = Mooncake.CoDual(new_val_primal, y_fdata)\n\n    function lsetfield_A_pullback(dy_rdata)\n        Mooncake.lsetfield!(a, Val(field_sym), old_val)\n        if field_sym === :x\n            a_t.x = old_tangent\n        elseif field_sym === :a\n            a_t.a = old_tangent\n        end\n        return (Mooncake.NoRData(), Mooncake.NoRData(), Mooncake.NoRData(), dy_rdata)\n    end\n\n    return y_cd, lsetfield_A_pullback\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/#Test-utilities","page":"Writing Custom Tangent Types","title":"Test utilities","text":"","category":"section"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Implement the test utility functions:","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"function Mooncake.TestUtils.populate_address_map_internal(m::Mooncake.TestUtils.AddressMap, p::A{T}, t::TangentForA{Tx}) where {T,Tx}\n    k = Base.pointer_from_objref(p)\n    v = Base.pointer_from_objref(t)\n    if haskey(m, k)\n        @assert m[k] == v\n        return m\n    end\n    m[k] = v\n    Mooncake.TestUtils.populate_address_map_internal(m, p.x, t.x)\n    if !(t.a isa Mooncake.NoTangent)\n        Mooncake.TestUtils.populate_address_map_internal(m, p.a, t.a)\n    end\n    return m\nend\n\nfunction Mooncake.TestUtils.has_equal_data_internal(x::A{T}, y::A{T}, equal_undefs::Bool, d::Dict{Tuple{UInt,UInt},Bool}) where {T}\n    id_pair = (objectid(x), objectid(y))\n    haskey(d, id_pair) && return d[id_pair]\n    d[id_pair] = true\n    eq = Mooncake.TestUtils.has_equal_data_internal(x.x, y.x, equal_undefs, d)\n    if (x.a === nothing) != (y.a === nothing)\n        return false\n    elseif x.a === nothing\n        return eq\n    else\n        return eq && Mooncake.TestUtils.has_equal_data_internal(x.a, y.a, equal_undefs, d)\n    end\nend\n\nfunction Mooncake.TestUtils.has_equal_data_internal(t::TangentForA{Tx}, s::TangentForA{Tx}, equal_undefs::Bool, d::Dict{Tuple{UInt,UInt},Bool}) where {Tx}\n    id_pair = (objectid(t), objectid(s))\n    haskey(d, id_pair) && return d[id_pair]\n    d[id_pair] = true\n    eq = Mooncake.TestUtils.has_equal_data_internal(t.x, s.x, equal_undefs, d)\n    if (t.a isa Mooncake.NoTangent) != (s.a isa Mooncake.NoTangent)\n        return false\n    elseif t.a isa Mooncake.NoTangent\n        return eq\n    else\n        return eq && Mooncake.TestUtils.has_equal_data_internal(t.a, s.a, equal_undefs, d)\n    end\nend","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Now we can run it again and successfully check if all the tangent / fdata / rdata and other required functionality works correctly for the self-referential type A.","category":"page"},{"location":"developer_documentation/custom_tangent_type/","page":"Writing Custom Tangent Types","title":"Writing Custom Tangent Types","text":"Mooncake.TestUtils.test_data(Random.default_rng(), A(1.0, A(2.0, A(3.0))))","category":"page"},{"location":"developer_documentation/ir_representation/#IR-Representation","page":"IR Representation","title":"IR Representation","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Mooncake.jl works by transforming Julia's SSA-form (static single assignment) Intermediate Representation (IR), so a good understanding of Julia's IR is needed to understand Mooncake. Furthermore, Mooncake holds Julia's IR in a different data structure than the one usually used when producing code for reverse-mode AD. We discuss both data structures below, and provide examples of the kinds of transformations which must be applied to Julia's IR in order to implement AD, contrasting the two different data structures.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Please note that Julia's SSA-form IR typically changes representation slightly between minor versions of Julia, as it's not part of the public interface of the language. The information below is accurate on version 1.11.4, but you might well find that things are slightly different on different versions.","category":"page"},{"location":"developer_documentation/ir_representation/#Julia's-SSA-form-IR","page":"IR Representation","title":"Julia's SSA-form IR","text":"","category":"section"},{"location":"developer_documentation/ir_representation/#Straight-Line-Code","page":"IR Representation","title":"Straight-Line Code","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"You can find the IR associated to a given signature using Base.code_ircode_by_type:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> function foo(x)\n           y = sin(x)\n           z = cos(y)\n           return z\n       end\nfoo (generic function with 1 method)\n\njulia> signature = Tuple{typeof(foo), Float64}\nTuple{typeof(foo), Float64}\n\njulia> Base.code_ircode_by_type(signature)[1][1]\n2 1 ─ %1 = invoke sin(_2::Float64)::Float64\n3 │   %2 = invoke cos(%1::Float64)::Float64\n4 └──      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"What you can see here is that the calls to sin and cos in the original function are associated to a number, denoted %1 and %2. We refers to these as the \"ssa\"s associated to each statement. Each statement is associated to a single ssa, and this association is determined by where it appears in the list of statements – the first statement is associated to %1, the second to %2, and so on. You will also notice that the argument x has been replaced with a _2 in the first statement – in general, all uses of the nth argument are indicated by _n (the first argument is the function itself). The final statement requires no explanation.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Note that this IR is obtained after both type inference and various Julia-level optimisation passes. This means that the type information is available for each statement. For example, the ::Float64 at the end of the first and second statements indicates that the type of %1 and %2 is always Float64. The types are also displayed at uses – the call to sin involves _2::Float64, not just _2.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Additionally notice that the statements are invoke statements, rather than just call statements. In Julia's IR, an invoke statement represents static dispatch to a particular MethodInstance – i.e. running type inference + optimisation passes has determined enough about the argument types to make it possible to know exactly which MethodInstance of sin and cos to call. This is a very common occurrence in type-stable code.","category":"page"},{"location":"developer_documentation/ir_representation/#Control-Flow","page":"IR Representation","title":"Control Flow","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The above is straight-line code – it does not involve any control flow. Julia has several statements which are involved in handling control flow. For example","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> function bar(x)\n           if x > 0\n               return x\n           else\n               return 5x\n           end\n       end\nbar (generic function with 1 method)\n\njulia> Base.code_ircode_by_type(Tuple{typeof(bar),Float64})[1][1]\n2 1 ─ %1 = Base.lt_float(0.0, _2)::Bool\n  │   %2 = Base.or_int(%1, false)::Bool\n  └──      goto #3 if not %2\n3 2 ─      return _2\n5 3 ─ %5 = Base.mul_float(5.0, _2)::Float64\n  └──      return %5","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"In this example we see the statement goto #3 if not %2. This should be read as \"jump to basic block 3 if %2 is false\". The second half of that statement should be clear, but to understand the first half requires knowing what a basic block is:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"  1 ─\n  │  \n  └──\n  2 ─\n  3 ─\n  └──","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Here, everything is removed from the above example except for information about the basic block structure. To first approximation, each basic block is a sequence of statements which must always execute one after the other. Once all statements in a basic block have run, we typically either jump to another basic block, or hit a return statement. In this example, we have three basic blocks – you can see this from the numbers 1, 2, and 3. The first basic block comprises three statements, the second only one statement, and the third two statements. Another way to investigate this structure is to look at the control-flow graph associated to the IR:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> Base.code_ircode_by_type(Tuple{typeof(bar),Float64})[1][1].cfg\nCFG with 3 blocks:\n  bb 1 (stmts 1:3) → bb 3, 2\n  bb 2 (stmt 4)\n  bb 3 (stmts 5:6)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"For example, the above states that \"bb\" (basic block) 1 comprises statements 1 to 3, and has successor blocks 2 and 3 (ie. once the statements in basic block 1 have executed, we know for certain that either those in block 2 or block 3 will run next). Blocks 2 and 3 have no successors, because they both end in a return statement. The predecessors of each basic block (the blocks which could possibly have run immediately prior to a given block) are also stored in the blocks of the CFG, even though this is not printed – you should have a play around with this data structure to see what is in there.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Additionally, note that Base.lt_float (used to check if one floating point number is less than another) and Base.or_int do not appear as invoke statements – this is because they are not generic Julia functions. Rather, they are Julia intrinsics:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> Base.lt_float\nlt_float (intrinsic function #31)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"These intrinsics have special handling in the compiler. Either way, the overall point is to be aware that these kinds of low-level intrinsics exist, and appear regularly in Julia IR.","category":"page"},{"location":"developer_documentation/ir_representation/#Simple-Loops-and-Phi-Nodes","page":"IR Representation","title":"Simple Loops and Phi-Nodes","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Finally, we shall consider a simple loop:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> function my_factorial(x::Int)\n           n = 0\n           s = 1\n           while n < x\n               n += 1\n               s *= n\n           end\n           return s\n       end\nmy_factorial (generic function with 1 method)\n\njulia> ir = Base.code_ircode_by_type(Tuple{typeof(my_factorial), Int})[1][1]\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %7)::Int64\n  │   %3 = φ (#1 => 0, #3 => %6)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─ %6 = Base.add_int(%3, 1)::Int64\n6 │   %7 = Base.mul_int(%2, %6)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"There are a few new intrinsics that we have not seen previously (Base.slt_int (used to check whether one int is strictly less than another), Base.add_int, and Base.mul_int). Additionally, there is the node goto #2, which simply states that control flow should jump to basic block 2 whenever it is hit.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The most interesting additional nodes, however, are the two φ (phi) nodes. These are a defining feature of SSA-form IR. Consider the first φ node:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"%2 = φ (#1 => 1, #3 => %7)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"means ssa %2 takes value 1 if the previous basic block was #1, and whatever value is currently associated to ssa %7 if the previous basic block was #3. It is helpful to step through this code in your head: upon calling my_factorial we enter basic block #1, and proceed directly to basic block #2. Therefore, on the first iteration, %2 takes value 1. We never return to basic block #1, so all subsequent visits to this φ node will result in %2 taking the value associated to %7. You should convince yourself that %2 corresponds to the value of s at each iteration, and %3 corresponds to the value of n at each iteration.","category":"page"},{"location":"developer_documentation/ir_representation/#Summary","page":"IR Representation","title":"Summary","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Julia's SSA-form IR comprises a sequence of statements, which can be broken down into a collection of basic blocks. Each basic block begins with a (potentially empty) collection of phi nodes, followed by a sequence of statements, and potentially finished by a terminator (goto, goto-if-not, return). Control flow is dictated by the terminators at the end of basic blocks – if there is no terminator then we \"fall through\" to the next basic block.","category":"page"},{"location":"developer_documentation/ir_representation/#Julia-Compiler's-IR-Datastructure","page":"IR Representation","title":"Julia Compiler's IR Datastructure","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The Julia compiler represents the IR associated to a signature via a struct called Core.Compiler.IRCode. The statements are given by the stmts field, which is a Core.Compiler.InstructionStream. An InstructionStream is a collection of 5 Vectors, each of which have the same length. The properties of the nth statement in the IR are given by the nth element of each of these vectors. For example, the stmt field contains the statement itself, the type field contains the inferred type associated to the statement. We'll skip the rest for now. For example, the statements associated to the my_factorial function above can be retrieved as follows:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> ir.stmts.stmt\n9-element Vector{Any}:\n nothing\n :(φ (%1 => 1, %3 => %7))\n :(φ (%1 => 0, %3 => %6))\n :(Base.slt_int(%3, _2))\n :(goto %4 if not %4)\n :(Base.add_int(%3, 1))\n :(Base.mul_int(%2, %6))\n :(goto %2)\n :(return %2)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The types can be accessed in a similar way:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> ir.stmts.type\n9-element Vector{Any}:\n Nothing\n Int64\n Int64\n Bool\n Any\n Int64\n Int64\n Any\n Any","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"As seen in Control Flow, the control flow graph (CFG) is represented as a separate data structure, stored in the cfg field of the IRCode. The argument types associated to the signature are stored in the argtypes field of the IRCode.","category":"page"},{"location":"developer_documentation/ir_representation/#An-Alternative-IR-Datastructure","page":"IR Representation","title":"An Alternative IR Datastructure","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"IRCode is a perfectly good way to represent Julia's IR the vast majority of the time. For example, it suffices for the code transformations required for forwards-mode AD. However, IR transformations involving multiple changes to the control flow structure of a programme are needed in reverse-mode, and are prohibitively awkward to undertake using IRCode. Mooncake's implementation of reverse-mode AD instead makes use of a custom representation of Julia's IR, called BBCode. We emphasise that BBCode represents the same thing under the hood, it is just represented in memory in a slightly different way, such that certain kinds of transformations are straightforward to implement.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"You can construct a BBCode from an IRCode, and vice versa:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> using Mooncake: BBCode\n\njulia> bb_ir = BBCode(ir);\n\njulia> bb_ir isa BBCode\ntrue\n\njulia> Core.Compiler.IRCode(bb_ir)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %7)::Int64\n  │   %3 = φ (#1 => 0, #3 => %6)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─ %6 = Base.add_int(%3, 1)::Int64\n6 │   %7 = Base.mul_int(%2, %6)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"At present, BBCode does not display itself nicely, so to look at it we must either inspect its fields, or convert it back to an IRCode (which does print nicely).","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Instead of storing all of the statements in a single vector (and the types in their own vector, etc), BBCode stores all statements associated to a particular basic block in a Mooncake.BBlock, and stores these in a Vector{Mooncake.BBlock}.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> typeof(bb_ir.blocks)\nVector{BBlock} (alias for Array{Mooncake.BasicBlockCode.BBlock, 1})","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Each BBlock has a field insts, containing the statements associated to that basic block. This is stored as a Vector{Core.Compiler.NewInstruction}, because Core.Compiler.NewInstruction contains the 5 fields that define an instruction in IRCode (you should compare the fields of a Core.Compiler.NewInstruction with those of Core.Compiler.InstructionStream to see the correspondence). For example, consider","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> using Mooncake.BasicBlockCode: ID # to improve printing\n\njulia> bb_ir.blocks[3].insts[1]\nCore.Compiler.NewInstruction(:(Base.add_int(ID(97), 1)), Int64, Core.Compiler.NoCallInfo(), 9, 0x000012e0)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"This is the first instruction of the third basic block. The first field is a call to Base.add_int, the second field is Int64 (we promise that the other fields are just copies of the corresponding data from the Core.Compiler.InstructionStream in the original IRCode representation of this IR).","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The other structural difference is that BBCode has no field containing the control-flow graph. Instead, the control-flow graph is represented implicitly as part of the blocks field. The upside of this is that any transformations of blocks which modify the CFG are automatically reflected in the blocks – there is no need to perform any book-keeping to ensure that the CFG is kept in sync with the instructions. This saves both time and memory when inserting new basic blocks – when basic block structure changes, a scan of the entire IRCode is required to modify any statements which refer to a given block, and yields code simplifications. The downside is that the CFG must be computed whenever we need to know about it. As a resut, neither IRCode nor BBCode's representation of the CFG is strictly better than the other. To extract CFG-related information from a BBCode, see Mooncake.BasicBlockCode.compute_all_successors, Mooncake.BasicBlockCode.compute_all_predecessors, and Mooncake.BasicBlockCode.control_flow_graph.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The final major difference between IRCode and BBCode is that all ssa values in an IRCode (%1, %2, %n, etc) are replaced with unique IDs. The ID associated to a statement is stored separately from the statement in the inst_ids field of a BBlock:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> bb_ir.blocks[3].inst_ids\n3-element Vector{ID}:\n ID(100)\n ID(101)\n ID(102)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"There is exactly one ID per instruction, and it is an error to have the same ID associated to multiple instructions. Similarly, while the number associated to a basic block in IRCode is a function of the number of basic blocks which preceed it, the ID of a basic block in BBCode is stored in its id field:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> bb_ir.blocks[3].id\nID(106)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"As a result of this, all references to ssa values and basic block numbers in IRCode are replaced with IDs in BBCode. The purpose of this is to guarantee that the \"name\" of a basic block and an instruction does not change when you insert new basic blocks and new instructions. We shall see how this is useful in the examples below.","category":"page"},{"location":"developer_documentation/ir_representation/#Code-Transformations","page":"IR Representation","title":"Code Transformations","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"In what follows, we look at a few transformations of Julia's IR, and see how these can be undertaken using both IRCode and BBCode. The purpose is two-fold:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"to enable readers to understand the code used to implement Mooncake, and\nto highlight the relative merits of IRCode vs BBCode.","category":"page"},{"location":"developer_documentation/ir_representation/#Replacing-Instructions","page":"IR Representation","title":"Replacing Instructions","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"This is a very simple code transformation. It is used in both forwards-mode and reverse-mode in Mooncake to replace calls of the form","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"f(x, y, z)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"with calls of the form","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"frule!!(f, x, y, z)","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"This kind of transformation is performed in basically the same way for both IRCode and BBCode. For example, the mul_int statement associated to ssa %7 can be replaced with an add_int statement as follows:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> using Core: SSAValue\n\njulia> const CC = Core.Compiler;\n\njulia> new_ir = Core.Compiler.copy(ir);\n\njulia> old_stmt = new_ir.stmts.stmt[7]\n:(Base.mul_int(%2, %6))\n\njulia> new_stmt = Expr(:call, Base.add_int, old_stmt.args[2:end]...)\n:((Core.Intrinsics.add_int)(%2, %6))\n\njulia> # new_ir[SSAValue(7)][:stmt] = new_stmt\n       CC.setindex!(CC.getindex(new_ir, SSAValue(7)), new_stmt, :stmt);\n\njulia> new_ir\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %7)::Int64\n  │   %3 = φ (#1 => 0, #3 => %6)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─ %6 = Base.add_int(%3, 1)::Int64\n6 │   %7 = (Core.Intrinsics.add_int)(%2, %6)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Observe that ssa 7 has been replaced with the new :call to add_int. Unfortunately, in order to avoid committing type-piracy against Core.Compiler, we cannot currently write new_ir[SSAValue(7)][:stmt]. (CC.getindex is a different function from Base.getindex – the same is true for CC.setindex! vs Base.setindex!). In general, I would recommend defining helper functions to improve the DRYness of your code.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"The same transformation can be performed on BBCode:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> bb_ir_copy = copy(bb_ir);\n\njulia> old_inst = bb_ir_copy.blocks[3].insts[2]\nCore.Compiler.NewInstruction(:(Base.mul_int(ID(96), ID(100))), Int64, Core.Compiler.NoCallInfo(), 10, 0x000012e0)\n\njulia> new_stmt = Expr(:call, Base.add_int, old_inst.stmt.args[2:end]...)\n:((Core.Intrinsics.add_int)(ID(96), ID(100)))\n\njulia> bb_ir_copy.blocks[3].insts[2] = CC.NewInstruction(old_inst; stmt=new_stmt);\n\njulia> CC.IRCode(bb_ir_copy)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %7)::Int64\n  │   %3 = φ (#1 => 0, #3 => %6)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─ %6 = Base.add_int(%3, 1)::Int64\n6 │   %7 = (Core.Intrinsics.add_int)(%2, %6)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"As you can see, in both cases we wind up with the same IRCode at the end.","category":"page"},{"location":"developer_documentation/ir_representation/#Inserting-New-Instructions","page":"IR Representation","title":"Inserting New Instructions","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Inserting entirely new instructions into the IR requires a little more thought, but is ultimately very straightforward using either IRCode or BBCode.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"First, IRCode. Suppose that we wish to insert another instruction immediately before the first add_int instruction which multiplies %3 by 2 before adding 1 to it in #3. In IRCode, this kind of modification requires some care, because naively inserting an instruction between the 5th and 6th line changes the name of all instructions from the 6th onwards. Consequently, we need to replace all existing uses of e.g. %6 with uses of %7, etc. Happily, IRCode has a mechanism to achieve just this.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> ni = CC.NewInstruction(Expr(:call, Base.mul_int, SSAValue(3), 2), Int)\nCore.Compiler.NewInstruction(:((Core.Intrinsics.mul_int)(%3, 2)), Int64, Core.Compiler.NoCallInfo(), nothing, nothing)\n\njulia> new_ssa = CC.insert_node!(new_ir, SSAValue(6), ni)\n:(%10)\n\njulia> new_ir\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %7)::Int64\n  │   %3 = φ (#1 => 0, #3 => %6)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─      (Core.Intrinsics.mul_int)(%3, 2)::Int64\n  │   %6 = Base.add_int(%3, 1)::Int64\n6 │   %7 = (Core.Intrinsics.add_int)(%2, %6)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"CC.insert_node!(ir, ssa, new_inst) inserts new_inst into ir immediately before ssa, and attaches it to the same basic block as ssa resides. It returns an SSAValue, which is the \"name\" associated to the inserted instruction in the IR. Here, we see it has inserted the instruction to multiply %3 by 2 immediately before %6. However, observe that the IRCode has not changed the name associated to the subsequent add_int instruction – it still assigns to %6, despite not being the 6th statement in the IR anymore. This is achieved via IRCode's new_nodes field – upon calling CC.insert_node!, rather than inserting the instruction directly into the InstructionStream, this list is appended to. We can do this as many times as we like, and then call CC.compact! at the end to handle all of the book-keeping involved in inserting all of the statements, updating all ssa uses where required, and updating the cfg field of the IR.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Also observe that the inserted statement is printed without a %10 = at the start of it – this is because there are not (yet) any uses of %10, so IRCode does not print it out (presumably in order to reduce visual noise).","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"To conclude this transformation, we replace the first argument of the add_int instruction with the new ssa returned by insert_node!, and then call CC.compact! to process all of the nodes currently in the new_nodes list, and produce a valid IRCode:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> stmt = CC.getindex(CC.getindex(new_ir, SSAValue(6)), :stmt)\n:(Base.add_int(%3, 1))\n\njulia> stmt.args[2] = new_ssa;\n\njulia> new_ir\n  1 ─       nothing::Nothing\n4 2 ┄ %2  = φ (#1 => 1, #3 => %7)::Int64\n  │   %3  = φ (#1 => 0, #3 => %6)::Int64\n  │   %4  = Base.slt_int(%3, _2)::Bool\n  └──       goto #4 if not %4\n5 3 ─ %10 = (Core.Intrinsics.mul_int)(%3, 2)::Int64\n  │   %6  = Base.add_int(%10, 1)::Int64\n6 │   %7  = (Core.Intrinsics.add_int)(%2, %6)::Int64\n7 └──       goto #2\n8 4 ─       return %2\n\njulia> new_ir = CC.compact!(new_ir)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %8)::Int64\n  │   %3 = φ (#1 => 0, #3 => %7)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n5 3 ─ %6 = (Core.Intrinsics.mul_int)(%3, 2)::Int64\n  │   %7 = Base.add_int(%6, 1)::Int64\n6 │   %8 = (Core.Intrinsics.add_int)(%2, %7)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Observe that, before compact!-ing, the first instruction in basic block #3 is still labelled as being %10. After compact!-ing, we have standard sequentially-labelled IR again. Note that the above is exactly the kind of thing that we do in our implementation of forwards-mode AD – all insertions of nodes are performed in a single pass over the IRCode, and CC.compact! is called once at the end.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Performing this transformation using BBCode is similarly straightforward. Since the name associated to instructions does not change when you insert another instruction, you really just need to insert an instruction + its ID, update the next instruction (as before), and you're done:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> using Mooncake.BasicBlockCode: ID, new_inst\n\njulia> new_id = ID() # this produces a new unique `ID`.\nID(108)\n\njulia> target_id = bb_ir_copy.blocks[3].insts[1].stmt.args[2] # find `ID` of argument to add_int.\nID(97)\n\njulia> ni = new_inst(Expr(:call, Base.mul_int, target_id, 2), Int);\n\njulia> insert!(bb_ir_copy.blocks[3], 1, new_id, ni)\n\njulia> bb_ir_copy.blocks[3].insts[2].stmt.args[2] = new_id\nID(108)\n\njulia> CC.IRCode(bb_ir_copy)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %8)::Int64\n  │   %3 = φ (#1 => 0, #3 => %7)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #4 if not %4\n2 3 ─ %6 = (Core.Intrinsics.mul_int)(%3, 2)::Int64\n5 │   %7 = Base.add_int(%6, 1)::Int64\n6 │   %8 = (Core.Intrinsics.add_int)(%2, %7)::Int64\n7 └──      goto #2\n8 4 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"We see here that IRCode and BBCode involve similar levels of complexity to insert an instruction.","category":"page"},{"location":"developer_documentation/ir_representation/#Inserting-New-Basic-Blocks","page":"IR Representation","title":"Inserting New Basic Blocks","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"This is the situation in which the design of BBCode shines vs IRCode. IRCode does not, at present, really have much to say about transformations which change control flow. It is, however, straightforward using BBCode. Suppose that we wish to modify the above to display the value of %2 if it is even on any given iteration. Since this involves control flow, it necessarily requires at least one additional basic block.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"We do this in two steps. We first insert an additional basic block between blocks #3 and #4 which always prints out the value of %2, and then goes to block #2:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> using Mooncake.BasicBlockCode: BBlock, new_inst, IDGotoNode, IDGotoIfNot\n\njulia> block_2_id = bb_ir_copy.blocks[2].id;\n\njulia> new_bb_id = ID();\n\njulia> new_bb = BBlock(\n           new_bb_id,\n           ID[ID(), ID()],\n           CC.NewInstruction[\n               new_inst(Expr(:call, println, CC.SSAValue(2))),\n               new_inst(IDGotoNode(block_2_id)),\n           ],\n       );\n\njulia> insert!(bb_ir_copy.blocks, 4, new_bb);\n\njulia> CC.IRCode(bb_ir_copy)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %8)::Int64\n  │   %3 = φ (#1 => 0, #3 => %7)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #5 if not %4\n2 3 ─ %6 = (Core.Intrinsics.mul_int)(%3, 2)::Int64\n5 │   %7 = Base.add_int(%6, 1)::Int64\n6 │   %8 = (Core.Intrinsics.add_int)(%2, %7)::Int64\n7 └──      goto #2\n2 4 ─      (println)(%2)::Any\n  └──      goto #2\n8 5 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Observe that, in this case, rather than creating new_bb and then inserting instructions into it, we simply create the block with the instructions. This programming style is often more convenient. Additionally note that we create an ID for each statement in the new basic block. These IDs are never actually used anywhere, but BBCode requires that each instruction be associated to an ID, so we must create them.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Additionally, note the usage of an Mooncake.BasicBlockCode.IDGotoNode. This is exactly the same thing as a Core.Compiler.GotoNode, except it contains an ID stating which basic block to jump to, rather than an Int. Similarly, the Mooncake.BasicBlockCode.IDGotoIfNot is a direct translation of Core.Compiler.GotoIfNot, with the dest field being an ID rather than an Int.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Furthermore, note that the goto if not instruction at the end of basic block #2 now (correctly) jumps to basic block #5, whereas before it jumped to block #4. That is, by virtue of the fact that the ID associated to each basic block remains unchanged in BBCode, all pre-existing control flow relationships have remained the same. Moreover, we did not have to write any book-keeping code to ensure that this update happened correctly.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Now that we've created the new basic block, we modify block #3 to fall-through to the new block if %2 is even, and to jump straight back to block #2 if not:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> bb = bb_ir_copy.blocks[3];\n\njulia> cond_id = ID();\n\njulia> target_id = bb_ir_copy.blocks[2].inst_ids[1];\n\njulia> insert!(bb, 4, cond_id, new_inst(Expr(:call, iseven, target_id)));\n\njulia> bb.insts[end] = new_inst(IDGotoIfNot(cond_id, block_2_id));\n\njulia> new_ir = CC.IRCode(bb_ir_copy)\n  1 ─      nothing::Nothing\n4 2 ┄ %2 = φ (#1 => 1, #3 => %8)::Int64\n  │   %3 = φ (#1 => 0, #3 => %7)::Int64\n  │   %4 = Base.slt_int(%3, _2)::Bool\n  └──      goto #5 if not %4\n2 3 ─ %6 = (Core.Intrinsics.mul_int)(%3, 2)::Int64\n5 │   %7 = Base.add_int(%6, 1)::Int64\n6 │   %8 = (Core.Intrinsics.add_int)(%2, %7)::Int64\n2 │   %9 = (iseven)(%2)::Any\n  └──      goto #2 if not %9\n  4 ─      (println)(%2)::Any\n  └──      goto #2\n8 5 ─      return %2","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Observe that in order to tie the conditional to the goto-if-not, we simply ensure that the ID associated to the instruction which computes the conditional appears in the IDGotoIfNot instruction.","category":"page"},{"location":"developer_documentation/ir_representation/#Run-the-new-code","page":"IR Representation","title":"Run the new code","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"As ever, we can construct a Core.OpaqueClosure using IRCode in order to produce something runnable:","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"julia> oc = Core.OpaqueClosure(new_ir; do_compile=true)\n(::Int64)::Int64->◌\n\njulia> oc(1000)\n2\n12\n58\n248\n1014\n2037","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"Exactly what oc is computing is neither here nor there. The point is that we've successfully inserted a new basic block into Julia's IR, and produced a callable from it.","category":"page"},{"location":"developer_documentation/ir_representation/#Summary-2","page":"IR Representation","title":"Summary","text":"","category":"section"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"We have reviewed the two representations of Julia IR used in Mooncake. Where possible, we always use IRCode – as discussed, forwards-mode AD exclusively uses IRCode. BBCode is basically only needed when undertaking transformations which involve changes to basic block structure – the insertion of new basic blocks, and the modification of terminators in a way which changes the predecessors / successors of a given block being the primary sources of these kinds of changes. Reverse-mode AD makes extensive use of such transformations, so BBCode is currently important there.","category":"page"},{"location":"developer_documentation/ir_representation/","page":"IR Representation","title":"IR Representation","text":"There are efforts such as this PR to augment IRCode with the capability to manipulate the CFG structure in a convenient manner. Ideally these efforts will succeed, then we can do away with BBCode.","category":"page"},{"location":"developer_documentation/ir_representation/#Docstrings","page":"IR Representation","title":"Docstrings","text":"","category":"section"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode","page":"IR Representation","title":"Mooncake.BasicBlockCode","text":"module BasicBlockCode\n\nSee the docstring for the BBCode struct for info on this file.\n\n\n\n\n\n","category":"module"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.Terminator","page":"IR Representation","title":"Mooncake.BasicBlockCode.Terminator","text":"Terminator = Union{Switch, IDGotoIfNot, IDGotoNode, ReturnNode}\n\nA Union of the possible types of a terminator node.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Core.Compiler.IRCode-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Core.Compiler.IRCode","text":"IRCode(bb_code::BBCode)\n\nProduce an IRCode instance which is equivalent to bb_code. The resulting IRCode shares no memory with bb_code, so can be safely mutated without modifying bb_code.\n\nAll IDPhiNodes, IDGotoIfNots, and IDGotoNodes are converted into PhiNodes, GotoIfNots, and GotoNodes respectively.\n\nIn the resulting bb_code, any Switch nodes are lowered into a semantically-equivalent collection of GotoIfNot nodes.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.BBCode","page":"IR Representation","title":"Mooncake.BasicBlockCode.BBCode","text":"BBCode(\n    blocks::Vector{BBlock}\n    argtypes::Vector{Any}\n    sptypes::Vector{CC.VarState}\n    linetable::Vector{Core.LineInfoNode}\n    meta::Vector{Expr}\n)\n\nA BBCode is a data structure which is similar to IRCode, but adds additional structure.\n\nIn particular, a BBCode comprises a sequence of basic blocks (BBlocks), each of which comprise a sequence of statements. Moreover, each BBlock has its own unique ID, as does each statment.\n\nThe consequence of this is that new basic blocks can be inserted into a BBCode. This is distinct from IRCode, in which to create a new basic block, one must insert additional statments which you know will create a new basic block – this is generally quite an unreliable process, while inserting a new BBlock into BBCode is entirely predictable. Furthermore, inserting a new BBlock does not change the ID associated to the other blocks, meaning that you can safely assume that references from existing basic block terminators / phi nodes to other blocks will not be modified by inserting a new basic block.\n\nAdditionally, since each statment in each basic block has its own unique ID, new statments can be inserted without changing references between other blocks. IRCode also has some support for this via its new_nodes field, but eventually all statements will be renamed upon compact!ing the IRCode, meaning that the name of any given statement will eventually change.\n\nFinally, note that the basic blocks in a BBCode support the custom Switch statement. This statement is not valid in IRCode, and is therefore lowered into a collection of GotoIfNots and GotoNodes when a BBCode is converted back into an IRCode.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.BBCode-Tuple{Core.Compiler.IRCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.BBCode","text":"BBCode(ir::IRCode)\n\nConvert an ir into a BBCode. Creates a completely independent data structure, so mutating the BBCode returned will not mutate ir.\n\nAll PhiNodes, GotoIfNots, and GotoNodes will be replaced with the IDPhiNodes, IDGotoIfNots, and IDGotoNodes respectively.\n\nSee IRCode for conversion back to IRCode.\n\nNote that IRCode(BBCode(ir)) should be equal to the identity function.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.BBCode-Tuple{Union{Mooncake.BasicBlockCode.BBCode, Core.Compiler.IRCode}, Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode.BBCode","text":"BBCode(ir::Union{IRCode, BBCode}, new_blocks::Vector{Block})\n\nMake a new BBCode whose blocks is given by new_blocks, and fresh copies are made of all other fields from ir.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.BBlock","page":"IR Representation","title":"Mooncake.BasicBlockCode.BBlock","text":"BBlock(id::ID, stmt_ids::Vector{ID}, stmts::InstVector)\n\nA basic block data structure (not called BasicBlock to avoid accidental confusion with CC.BasicBlock). Forms a single basic block.\n\nEach BBlock has an ID (a unique name). This makes it possible to refer to blocks in a way that does not change when additional BBlocks are inserted into a BBCode. This differs from the positional block numbering found in IRCode, in which the number associated to a basic block changes when new blocks are inserted.\n\nThe nth line of code in a BBlock is associated to ID stmt_ids[n], and the nth instruction from stmts.\n\nNote that PhiNodes, GotoIfNots, and GotoNodes should not appear in a BBlock – instead an IDPhiNode, IDGotoIfNot, or IDGotoNode should be used.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.BBlock-Tuple{Mooncake.BasicBlockCode.ID, Vector{Tuple{Mooncake.BasicBlockCode.ID, Core.Compiler.NewInstruction}}}","page":"IR Representation","title":"Mooncake.BasicBlockCode.BBlock","text":"BBlock(id::ID, inst_pairs::Vector{IDInstPair})\n\nConvenience constructor – splits inst_pairs into a Vector{ID} and InstVector in order to build a BBlock.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.ID","page":"IR Representation","title":"Mooncake.BasicBlockCode.ID","text":"ID()\n\nAn ID (read: unique name) is just a wrapper around an Int32. Uniqueness is ensured via a global counter, which is incremented each time that an ID is created.\n\nThis counter can be reset using seed_id! if you need to ensure deterministic IDs are produced, in the same way that seed for random number generators can be set.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.IDGotoIfNot","page":"IR Representation","title":"Mooncake.BasicBlockCode.IDGotoIfNot","text":"IDGotoIfNot(cond::Any, dest::ID)\n\nLike a GotoIfNot, but dest is an ID rather than an Int64.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.IDGotoNode","page":"IR Representation","title":"Mooncake.BasicBlockCode.IDGotoNode","text":"IDGotoNode(label::ID)\n\nLike a GotoNode, but label is an ID rather than an Int64.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.IDInstPair","page":"IR Representation","title":"Mooncake.BasicBlockCode.IDInstPair","text":"const IDInstPair = Tuple{ID, NewInstruction}\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.IDPhiNode","page":"IR Representation","title":"Mooncake.BasicBlockCode.IDPhiNode","text":"IDPhiNode(edges::Vector{ID}, values::Vector{Any})\n\nLike a PhiNode, but edges are IDs rather than Int32s.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.InstVector","page":"IR Representation","title":"Mooncake.BasicBlockCode.InstVector","text":"const InstVector = Vector{NewInstruction}\n\nNote: the CC.NewInstruction type is used to represent instructions because it has the correct fields. While it is only used to represent new instrucdtions in Core.Compiler, it is used to represent all instructions in BBCode.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.Switch","page":"IR Representation","title":"Mooncake.BasicBlockCode.Switch","text":"Switch(conds::Vector{Any}, dests::Vector{ID}, fallthrough_dest::ID)\n\nA switch-statement node. These can be inserted in the BBCode representation of Julia IR. Switch has the following semantics:\n\ngoto dests[1] if not conds[1]\ngoto dests[2] if not conds[2]\n...\ngoto dests[N] if not conds[N]\ngoto fallthrough_dest\n\nwhere the value associated to each element of conds is a Bool, and dests indicate which block to jump to. If none of the conditions are met, then we go to whichever block is specified by fallthrough_dest.\n\nSwitch statements are lowered into the above sequence of GotoIfNots and GotoNodes when converting BBCode back into IRCode, because Switch statements are not valid nodes in regular Julia IR.\n\n\n\n\n\n","category":"type"},{"location":"developer_documentation/ir_representation/#Base.insert!-Tuple{Mooncake.BasicBlockCode.BBlock, Int64, Mooncake.BasicBlockCode.ID, Core.Compiler.NewInstruction}","page":"IR Representation","title":"Base.insert!","text":"Base.insert!(bb::BBlock, n::Int, id::ID, stmt::CC.NewInstruction)::Nothing\n\nInserts stmt and id into bb immediately before the nth instruction.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.__line_numbers_to_block_numbers!-Tuple{Vector{Any}, Core.Compiler.CFG}","page":"IR Representation","title":"Mooncake.BasicBlockCode.__line_numbers_to_block_numbers!","text":"__line_numbers_to_block_numbers!(insts::Vector{Any}, cfg::CC.CFG)\n\nConverts any edges in GotoNodes, GotoIfNots, PhiNodes, and :enter expressions which refer to line numbers into references to block numbers. The cfg provides the information required to perform this conversion.\n\nFor context, CodeInfo objects have references to line numbers, while IRCode uses block numbers.\n\nThis code is copied over directly from the body of Core.Compiler.inflate_ir!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._block_nums_to_ids-Tuple{Vector{Core.Compiler.NewInstruction}, Core.Compiler.CFG}","page":"IR Representation","title":"Mooncake.BasicBlockCode._block_nums_to_ids","text":"_block_nums_to_ids(insts::InstVector, cfg::CC.CFG)::Tuple{Vector{ID}, InstVector}\n\nAssign to each basic block in cfg an ID. Replace all integers referencing block numbers in insts with the corresponding ID. Return the IDs and the updated instructions.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._build_graph_of_cfg-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._build_graph_of_cfg","text":"_build_graph_of_cfg(blks::Vector{BBlock})::Tuple{SimpleDiGraph, Dict{ID, Int}}\n\nBuilds a SimpleDiGraph, g, representing of the CFG associated to blks, where blks comprises the collection of basic blocks associated to a BBCode. This is a type from Graphs.jl, so constructing g makes it straightforward to analyse the control flow structure of ir using algorithms from Graphs.jl.\n\nReturns a 2-tuple, whose first element is g, and whose second element is a map from the ID associated to each basic block in ir, to the Int corresponding to its node index in g.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._compute_all_predecessors-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._compute_all_predecessors","text":"_compute_all_predecessors(blks::Vector{BBlock})::Dict{ID, Vector{ID}}\n\nInternal method implementing compute_all_predecessors. This method is easier to construct test cases for because it only requires the collection of BBlocks, not all of the other stuff that goes into a BBCode.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._compute_all_successors-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._compute_all_successors","text":"_compute_all_successors(blks::Vector{BBlock})::Dict{ID, Vector{ID}}\n\nInternal method implementing compute_all_successors. This method is easier to construct test cases for because it only requires the collection of BBlocks, not all of the other stuff that goes into a BBCode.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._control_flow_graph-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._control_flow_graph","text":"_control_flow_graph(blks::Vector{BBlock})::Core.Compiler.CFG\n\nInternal function, used to implement control_flow_graph. Easier to write test cases for because there is no need to construct an ensure BBCode object, just the BBlocks.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._distance_to_entry-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._distance_to_entry","text":"_distance_to_entry(blks::Vector{BBlock})::Vector{Int}\n\nFor each basic block in blks, compute the distance from it to the entry point (the first block. The distance is typemax(Int) if no path from the entry point to a given node.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._find_id_uses!-Tuple{Dict{Mooncake.BasicBlockCode.ID, Bool}, Expr}","page":"IR Representation","title":"Mooncake.BasicBlockCode._find_id_uses!","text":"_find_id_uses!(d::Dict{ID, Bool}, x)\n\nHelper function used in characterise_used_ids. For all uses of IDs in x, set the corresponding value of d to true.\n\nFor example, if x = ReturnNode(ID(5)), then this function sets d[ID(5)] = true.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._ids_to_line_numbers-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode._ids_to_line_numbers","text":"_ids_to_line_numbers(bb_code::BBCode)::InstVector\n\nFor each statement in bb_code, returns a NewInstruction in which every ID is replaced by either an SSAValue, or an Int64 / Int32 which refers to an SSAValue.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._is_reachable-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._is_reachable","text":"_is_reachable(blks::Vector{BBlock})::Vector{Bool}\n\nComputes a Vector whose length is length(blks). The nth element is true iff it is possible for control flow to reach the nth block.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._lines_to_blocks-Tuple{Vector{Core.Compiler.NewInstruction}, Core.Compiler.CFG}","page":"IR Representation","title":"Mooncake.BasicBlockCode._lines_to_blocks","text":"_instructions_to_blocks(insts::InstVector, cfg::CC.CFG)::InstVector\n\nPulls out the instructions from insts, and calls __line_numbers_to_block_numbers!.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._lower_switch_statements-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode._lower_switch_statements","text":"_lower_switch_statements(bb_code::BBCode)\n\nConverts all Switchs into a semantically-equivalent collection of GotoIfNots. See the Switch docstring for an explanation of what is going on here.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._remove_double_edges-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode._remove_double_edges","text":"_remove_double_edges(ir::BBCode)::BBCode\n\nIf the dest field of an IDGotoIfNot node in block n of ir points towards the n+1th block then we have two edges from block n to block n+1. This transformation replaces all such IDGotoIfNot nodes with unconditional IDGotoNodes pointing towards the n+1th block in ir.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._ssa_to_ids-Tuple{Dict{Core.SSAValue, Mooncake.BasicBlockCode.ID}, Core.Compiler.NewInstruction}","page":"IR Representation","title":"Mooncake.BasicBlockCode._ssa_to_ids","text":"_ssa_to_ids(d::SSAToIdDict, inst::NewInstruction)\n\nProduce a new instance of inst in which all instances of SSAValues are replaced with the IDs prescribed by d, all basic block numbers are replaced with the IDs prescribed by d, and GotoIfNot, GotoNode, and PhiNode instances are replaced with the corresponding ID versions.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._ssas_to_ids-Tuple{Vector{Core.Compiler.NewInstruction}}","page":"IR Representation","title":"Mooncake.BasicBlockCode._ssas_to_ids","text":"_ssas_to_ids(insts::InstVector)::Tuple{Vector{ID}, InstVector}\n\nAssigns an ID to each line in stmts, and replaces each instance of an SSAValue in each line with the corresponding ID. For example, a call statement of the form Expr(:call, :f, %4) is be replaced with Expr(:call, :f, id_assigned_to_%4).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode._to_ssas-Tuple{Dict, Core.Compiler.NewInstruction}","page":"IR Representation","title":"Mooncake.BasicBlockCode._to_ssas","text":"_to_ssas(d::Dict, inst::NewInstruction)\n\nLike _ssas_to_ids, but in reverse. Converts IDs to SSAValues / (integers corresponding to ssas).\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.characterise_unique_predecessor_blocks-Tuple{Vector{Mooncake.BasicBlockCode.BBlock}}","page":"IR Representation","title":"Mooncake.BasicBlockCode.characterise_unique_predecessor_blocks","text":"characterise_unique_predecessor_blocks(blks::Vector{BBlock}) ->\n    Tuple{Dict{ID, Bool}, Dict{ID, Bool}}\n\nWe call a block b a unique predecessor in the control flow graph associated to blks if it is the only predecessor to all of its successors. Put differently we call b a unique predecessor if, whenever control flow arrives in any of the successors of b, we know for certain that the previous block must have been b.\n\nReturns two Dicts. A value in the first Dict is true if the block associated to its key is a unique precessor, and is false if not. A value in the second Dict is true if  it has a single predecessor, and that predecessor is a unique predecessor.\n\nContext:\n\nThis information is important for optimising AD because knowing that b is a unique predecessor means that\n\non the forwards-pass, there is no need to push the ID of b to the block stack when  passing through it, and\non the reverse-pass, there is no need to pop the block stack when passing through one of  the successors to b.\n\nUtilising this reduces the overhead associated to doing AD. It is quite important when working with cheap loops – loops where the operations performed at each iteration are inexpensive – for which minimising memory pressure is critical to performance. It is also important for single-block functions, because it can be used to entirely avoid using a block stack at all.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.characterise_used_ids-Tuple{Vector{Tuple{Mooncake.BasicBlockCode.ID, Core.Compiler.NewInstruction}}}","page":"IR Representation","title":"Mooncake.BasicBlockCode.characterise_used_ids","text":"characterise_used_ids(stmts::Vector{IDInstPair})::Dict{ID, Bool}\n\nFor each line in stmts, determine whether it is referenced anywhere else in the code. Returns a dictionary containing the results. An element is false if the corresponding ID is unused, and true if is used.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.collect_stmts-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.collect_stmts","text":"collect_stmts(ir::BBCode)::Vector{IDInstPair}\n\nProduce a Vector containing all of the statements in ir. These are returned in order, so it is safe to assume that element n refers to the nth element of the IRCode associated to ir. \n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.collect_stmts-Tuple{Mooncake.BasicBlockCode.BBlock}","page":"IR Representation","title":"Mooncake.BasicBlockCode.collect_stmts","text":"collect_stmts(bb::BBlock)::Vector{IDInstPair}\n\nReturns a Vector containing the IDs and instructions associated to each line in bb. These should be assumed to be ordered.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.compute_all_predecessors-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.compute_all_predecessors","text":"compute_all_predecessors(ir::BBCode)::Dict{ID, Vector{ID}}\n\nCompute a map from the ID of each BBlock in ir to its possible predecessors.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.compute_all_successors-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.compute_all_successors","text":"compute_all_successors(ir::BBCode)::Dict{ID, Vector{ID}}\n\nCompute a map from the ID of each BBlock in ir to its possible successors.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.control_flow_graph-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.control_flow_graph","text":"control_flow_graph(bb_code::BBCode)::Core.Compiler.CFG\n\nComputes the Core.Compiler.CFG object associated to this bb_code.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.id_to_line_map-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.id_to_line_map","text":"id_to_line_map(ir::BBCode)\n\nProduces a Dict mapping from each ID associated with a line in ir to its line number. This is isomorphic to mapping to its SSAValue in IRCode. Terminators do not have IDs associated to them, so not every line in the original IRCode is mapped to.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.insert_before_terminator!-Tuple{Mooncake.BasicBlockCode.BBlock, Mooncake.BasicBlockCode.ID, Core.Compiler.NewInstruction}","page":"IR Representation","title":"Mooncake.BasicBlockCode.insert_before_terminator!","text":"insert_before_terminator!(bb::BBlock, id::ID, inst::NewInstruction)::Nothing\n\nIf the final instruction in bb is a Terminator, insert inst immediately before it. Otherwise, insert inst at the end of the block.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.is_reachable_return_node-Tuple{Core.ReturnNode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.is_reachable_return_node","text":"is_reachable_return_node(x::ReturnNode)\n\nDetermine whether x is a ReturnNode, and if it is, if it is also reachable. This is purely a function of whether or not its val field is defined or not.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.new_inst","page":"IR Representation","title":"Mooncake.BasicBlockCode.new_inst","text":"new_inst(stmt, type=Any, flag=CC.IR_FLAG_REFINED)::NewInstruction\n\nCreate a NewInstruction with fields:\n\nstmt = stmt\ntype = type\ninfo = CC.NoCallInfo()\nline = Int32(1)\nflag = flag\n\n\n\n\n\n","category":"function"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.new_inst_vec-Tuple{Core.Compiler.InstructionStream}","page":"IR Representation","title":"Mooncake.BasicBlockCode.new_inst_vec","text":"new_inst_vec(x::CC.InstructionStream)\n\nConvert an Compiler.InstructionStream into a list of Compiler.NewInstructions.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.phi_nodes-Tuple{Mooncake.BasicBlockCode.BBlock}","page":"IR Representation","title":"Mooncake.BasicBlockCode.phi_nodes","text":"phi_nodes(bb::BBlock)::Tuple{Vector{ID}, Vector{IDPhiNode}}\n\nReturns all of the IDPhiNodes at the start of bb, along with their IDs. If there are no IDPhiNodes at the start of bb, then both vectors will be empty.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.remove_unreachable_blocks!-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.remove_unreachable_blocks!","text":"remove_unreachable_blocks!(ir::BBCode)::BBCode\n\nIf a basic block in ir cannot possibly be reached during execution, then it can be safely removed from ir without changing its functionality. A block is unreachable if either:\n\nit has no predecessors and it is not the first block, or\nall of its predecessors are themselves unreachable.\n\nFor example, consider the following IR:\n\njulia> ir = Mooncake.ircode(\n           Any[Core.ReturnNode(nothing), Expr(:call, sin, 5), Core.ReturnNode(Core.SSAValue(2))],\n           Any[Any, Any, Any],\n       );\n\nThere is no possible way to reach the second basic block (lines 2 and 3). Applying this function will therefore remove it, yielding the following:\n\njulia> Mooncake.IRCode(Mooncake.remove_unreachable_blocks!(Mooncake.BBCode(ir)))\n1 1 ─     return nothing\n\nIn the blocks which have not been removed, there may be references to blocks which have been removed. For example, the edges in a PhiNode may contain a reference to a removed block. These references are removed in-place from these remaining blocks, so this function will (in general) modify ir.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.seed_id!-Tuple{}","page":"IR Representation","title":"Mooncake.BasicBlockCode.seed_id!","text":"seed_id!()\n\nSet the global counter used to ensure ID uniqueness to 0. This is useful when you want to ensure determinism between two runs of the same function which makes use of IDs.\n\nThis is akin to setting the random seed associated to a random number generator globally.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.sort_blocks!-Tuple{Mooncake.BasicBlockCode.BBCode}","page":"IR Representation","title":"Mooncake.BasicBlockCode.sort_blocks!","text":"sort_blocks!(ir::BBCode)::BBCode\n\nEnsure that blocks appear in order of distance-from-entry-point, where distance the distance from block b to the entry point is defined to be the minimum number of basic blocks that must be passed through in order to reach b.\n\nFor reasons unknown (to me, Will), the compiler / optimiser needs this for inference to succeed. Since we do quite a lot of re-ordering on the reverse-pass of AD, this is a problem there.\n\nWARNING: use with care. Only use if you are confident that arbitrary re-ordering of basic blocks in ir is valid. Notably, this does not hold if you have any IDGotoIfNot nodes in ir.\n\n\n\n\n\n","category":"method"},{"location":"developer_documentation/ir_representation/#Mooncake.BasicBlockCode.terminator-Tuple{Mooncake.BasicBlockCode.BBlock}","page":"IR Representation","title":"Mooncake.BasicBlockCode.terminator","text":"terminator(bb::BBlock)\n\nReturns the terminator associated to bb. If the last instruction in bb isa Terminator then that is returned, otherwise nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"utilities/debug_mode/#Debug-Mode","page":"Debug Mode","title":"Debug Mode","text":"","category":"section"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"The Problem","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"A major source of potential problems in AD systems is rules returning the wrong type of tangent / fdata / rdata for a given primal value. For example, if someone writes a rule like","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"function rrule!!(::CoDual{typeof(+)}, x::CoDual{<:Real}, y::CoDual{<:Real})\n    plus_reverse_pass(dz::Real) = NoRData(), dz, dz\n    return zero_fcodual(primal(x) + primal(y))\nend","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"and calls","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"rrule(zero_fcodual(+), zero_fcodual(5.0), zero_fcodual(4f0))","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"then the type of dz on the reverse pass will be Float64 (assuming everything happens correctly), and this rule will return a Float64 as the rdata for y. However, the primal value of y is a Float32, and rdata_type(Float32) is Float32, so returning a Float64 is incorrect. This error might cause the reverse pass to fail loudly immediately, but it might also fail silently. It might cause an error much later in the reverse pass, making it hard to determine that the source of the error was the above rule. Worst of all, in some cases it could plausibly cause a segfault, which is more-or-less the worst kind of outcome possible.","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"The Solution","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"Check that the types of the fdata / rdata associated to arguments are exactly what tangent_type / fdata_type / rdata_type require upon entry to / exit from rules and pullbacks.","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"This is implemented via DebugRRule:","category":"page"},{"location":"utilities/debug_mode/#Mooncake.DebugRRule-utilities-debug_mode","page":"Debug Mode","title":"Mooncake.DebugRRule","text":"DebugRRule(rule)\n\nConstruct a callable which is equivalent to rule, but inserts additional type checking. In particular:\n\ncheck that the fdata in each argument is of the correct type for the primal\ncheck that the fdata in the CoDual returned from the rule is of the correct type for the   primal.\n\nThis happens recursively. For example, each element of a Vector{Any} is compared against each element of the associated fdata to ensure that its type is correct, as this cannot be guaranteed from the static type alone.\n\nSome additional dynamic checks are also performed (e.g. that an fdata array of the same size as its primal).\n\nLet rule return y, pb!!, then DebugRRule(rule) returns y, DebugPullback(pb!!). DebugPullback inserts the same kind of checks as DebugRRule, but on the reverse-pass. See the docstring for details.\n\nNote: at any given point in time, the checks performed by this function constitute a necessary but insufficient set of conditions to ensure correctness. If you find that an error isn't being caught by these tests, but you believe it ought to be, please open an issue or (better still) a PR.\n\n\n\n\n\n","category":"type"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"You can straightforwardly enable it when building a rule via the debug_mode kwarg in the following:","category":"page"},{"location":"utilities/debug_mode/#Mooncake.build_rrule-utilities-debug_mode","page":"Debug Mode","title":"Mooncake.build_rrule","text":"build_rrule(args...; kwargs...)\n\nHelper method: equivalent to extracting the signature from args and calling build_rrule(sig; kwargs...).\n\n\n\n\n\nbuild_rrule(sig::Type{<:Tuple}; kwargs...)\n\nHelper method: Equivalent to build_rrule(Mooncake.get_interpreter(), sig; kwargs...).\n\n\n\n\n\nbuild_rrule(interp::MooncakeInterpreter{C}, sig_or_mi; debug_mode=false) where {C}\n\nReturns a DerivedRule which is an rrule!! for sig_or_mi in context C. See the docstring for rrule!! for more info.\n\nIf debug_mode is true, then all calls to rules are replaced with calls to DebugRRules.\n\n\n\n\n\n","category":"function"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"When using ADTypes.jl, you can choose whether or not to use it via the debug_mode kwarg:","category":"page"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"julia> AutoMooncake(; config=Mooncake.Config(; debug_mode=true))\nAutoMooncake{Mooncake.Config}(Mooncake.Config(true, false))","category":"page"},{"location":"utilities/debug_mode/#When-Should-You-Use-Debug-Mode?","page":"Debug Mode","title":"When Should You Use Debug Mode?","text":"","category":"section"},{"location":"utilities/debug_mode/","page":"Debug Mode","title":"Debug Mode","text":"Only use debug_mode when debugging a problem. This is because is has substantial performance implications.","category":"page"},{"location":"understanding_mooncake/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"The point of Mooncake.jl is to perform reverse-mode algorithmic differentiation (AD). The purpose of this section is to explain what precisely is meant by this, and how it can be interpreted mathematically.","category":"page"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"we recap what AD is, and introduce the mathematics necessary to understand is,\nexplain how this mathematics relates to functions and data structures in Julia, and\nhow this is handled in Mooncake.jl.","category":"page"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"Since Mooncake.jl supports in-place operations / mutation, these will push beyond what is encountered in Zygote / Diffractor / ChainRules. Consequently, while there is a great deal of overlap with these existing systems, you will need to read through this section of the docs in order to properly understand Mooncake.jl.","category":"page"},{"location":"understanding_mooncake/introduction/#Who-Are-These-Docs-For?","page":"Introduction","title":"Who Are These Docs For?","text":"","category":"section"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"These are primarily designed for anyone who is interested in contributing to Mooncake.jl. They are also hopefully of interest to anyone how is interested in understanding AD more broadly. If you aren't interested in understanding how Mooncake.jl and AD work, you don't need to have read them in order to make use of this package.","category":"page"},{"location":"understanding_mooncake/introduction/#Prerequisites-and-Resources","page":"Introduction","title":"Prerequisites and Resources","text":"","category":"section"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"This introduction assumes familiarity with the differentiation of vector-valued functions – familiarity with the gradient and Jacobian matrices is a given.","category":"page"},{"location":"understanding_mooncake/introduction/","page":"Introduction","title":"Introduction","text":"In order to provide a convenient exposition of AD, we need to abstract a little further than this and make use of a slightly more general notion of the derivative, gradient, and \"transposed Jacobian\". Please note that, fortunately, we only ever have to handle finite dimensional objects when doing AD, so there is no need for any knowledge of functional analysis to understand what is going on here. The required concepts will be introduced here, but I cannot promise that these docs give the best exposition – they're most appropriate as a refresher and to establish notation. Rather, I would recommend a couple of lectures from the \"Matrix Calculus for Machine Learning and Beyond\" course, which you can find on MIT's OCW website, delivered by Edelman and Johnson (who will be familiar faces to anyone who has spent much time in the Julia world!). It is designed for undergraduates, and is accessible to anyone with some undergraduate-level linear algebra and calculus. While I recommend the whole course, Lecture 1 part 2 and Lecture 4 part 1 are especially relevant to the problems we shall discuss – you can skip to 11:30 in Lecture 4 part 1 if you're in a hurry.","category":"page"},{"location":"utilities/defining_rules/#Defining-Rules","page":"Defining Rules","title":"Defining Rules","text":"","category":"section"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"Most of the time, Mooncake.jl can just differentiate your code, but you will need to intervene if you make use of a language feature which is unsupported. However, this does not always necessitate writing your own rrule!! from scratch. In this section, we detail some useful strategies which can help you avoid having to write rrule!!s in many situations, which we discuss before discussing the more involved process of actually writing rules.","category":"page"},{"location":"utilities/defining_rules/#Simplfiying-Code-via-Overlays","page":"Defining Rules","title":"Simplfiying Code via Overlays","text":"","category":"section"},{"location":"utilities/defining_rules/#Mooncake.@mooncake_overlay-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.@mooncake_overlay","text":"@mooncake_overlay method_expr\n\nDefine a method of a function which only Mooncake can see. This can be used to write versions of methods which can be successfully differentiated by Mooncake if the original cannot be.\n\nFor example, suppose that you have a function\n\njulia> foo(x::Float64) = bar(x)\nfoo (generic function with 1 method)\n\nwhere Mooncake.jl fails to differentiate bar for some reason. If you have access to another function baz, which does the same thing as bar, but does     so in a way which Mooncake.jl can differentiate, you can simply write:\n\njulia> Mooncake.@mooncake_overlay foo(x::Float64) = baz(x)\n\n\nWhen looking up the code for foo(::Float64), Mooncake.jl will see this method, rather than the original, and differentiate it instead.\n\nA Worked Example\n\nTo demonstrate how to use @mooncake_overlays in practice, we here demonstrate how the answer that Mooncake.jl gives changes if you change the definition of a function using a @mooncake_overlay. Do not do this in practice – this is just a simple way to demonostrate how to use overlays!\n\nFirst, consider a simple example:\n\njulia> scale(x) = 2x\nscale (generic function with 1 method)\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(10.0, (NoTangent(), 2.0))\n\nWe can use @mooncake_overlay to change the definition which Mooncake.jl sees:\n\njulia> Mooncake.@mooncake_overlay scale(x) = 3x\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(15.0, (NoTangent(), 3.0))\n\nAs can be seen from the output, the result of differentiating using Mooncake.jl has changed to reflect the overlay-ed definition of the method.\n\nAdditionally, it is possible to use the usual multi-line syntax to declare an overlay:\n\njulia> Mooncake.@mooncake_overlay function scale(x)\n           return 4x\n       end\n\njulia> rule = Mooncake.build_rrule(Tuple{typeof(scale), Float64});\n\njulia> Mooncake.value_and_gradient!!(rule, scale, 5.0)\n(20.0, (NoTangent(), 4.0))\n\n\n\n\n\n","category":"macro"},{"location":"utilities/defining_rules/#Functions-with-Zero-Adjoint","page":"Defining Rules","title":"Functions with Zero Adjoint","text":"","category":"section"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"If the above strategy does not work, but you find yourself in the surprisingly common situation that the adjoint of the derivative of your function is always zero, you can very straightforwardly write a rule by making use of the following:","category":"page"},{"location":"utilities/defining_rules/#Mooncake.@zero_adjoint-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.@zero_adjoint","text":"@zero_adjoint ctx sig\n\nDefines is_primitive(context_type, sig) = true, and defines a method of Mooncake.rrule!! which returns zero for all inputs. Users of ChainRules.jl should be familiar with this functionality – it is morally the same as ChainRulesCore.@non_differentiable.\n\nFor example:\n\njulia> using Mooncake: @zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive\n\njulia> foo(x) = 5\nfoo (generic function with 1 method)\n\njulia> @zero_adjoint DefaultCtx Tuple{typeof(foo), Any}\n\njulia> is_primitive(DefaultCtx, Tuple{typeof(foo), Any})\ntrue\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(3.0))[2](NoRData())\n(NoRData(), 0.0)\n\nLimited support for Varargs is also available. For example\n\njulia> using Mooncake: @zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive\n\njulia> foo_varargs(x...) = 5\nfoo_varargs (generic function with 1 method)\n\njulia> @zero_adjoint DefaultCtx Tuple{typeof(foo_varargs), Vararg}\n\njulia> is_primitive(DefaultCtx, Tuple{typeof(foo_varargs), Any, Float64, Int})\ntrue\n\njulia> rrule!!(zero_fcodual(foo_varargs), zero_fcodual(3.0), zero_fcodual(5))[2](NoRData())\n(NoRData(), 0.0, NoRData())\n\nBe aware that it is not currently possible to specify any of the type parameters of the Vararg. For example, the signature Tuple{typeof(foo), Vararg{Float64, 5}} will not work with this macro.\n\nWARNING: this is only correct if the output of the function does not alias any fields of the function, or any of its arguments. For example, applying this macro to the function x -> x will yield incorrect results.\n\nAs always, you should use TestUtils.test_rule to ensure that you've not made a mistake.\n\nSignatures Unsupported By This Macro\n\nIf the signature you wish to apply @zero_adjoint to is not supported, for example because it uses a Vararg with a type parameter, you can still make use of zero_adjoint.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/defining_rules/#Mooncake.zero_adjoint-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.zero_adjoint","text":"zero_adjoint(f::CoDual, x::Vararg{CoDual, N}) where {N}\n\nUtility functionality for constructing rrule!!s for functions which produce adjoints which always return zero.\n\nNOTE: you should only make use of this function if you cannot make use of the @zero_adjoint macro.\n\nYou make use of this functionality by writing a method of Mooncake.rrule!!, and passing all of its arguments (including the function itself) to this function. For example:\n\njulia> import Mooncake: zero_adjoint, DefaultCtx, zero_fcodual, rrule!!, is_primitive, CoDual\n\njulia> foo(x::Vararg{Int}) = 5\nfoo (generic function with 1 method)\n\njulia> is_primitive(::Type{DefaultCtx}, ::Type{<:Tuple{typeof(foo), Vararg{Int}}}) = true;\n\njulia> rrule!!(f::CoDual{typeof(foo)}, x::Vararg{CoDual{Int}}) = zero_adjoint(f, x...);\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(3), zero_fcodual(2))[2](NoRData())\n(NoRData(), NoRData(), NoRData())\n\nWARNING: this is only correct if the output of primal(f)(map(primal, x)...) does not alias anything in f or x. This is always the case if the result is a bits type, but more care may be required if it is not. ```\n\n\n\n\n\n","category":"function"},{"location":"utilities/defining_rules/#Using-ChainRules.jl","page":"Defining Rules","title":"Using ChainRules.jl","text":"","category":"section"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"ChainRules.jl provides a large number of rules for differentiating functions in reverse-mode. These rules are methods of the ChainRulesCore.rrule function. There are some instances where it is most convenient to implement a Mooncake.rrule!! by wrapping an existing ChainRulesCore.rrule.","category":"page"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"There is enough similarity between these two systems that most of the boilerplate code can be avoided.","category":"page"},{"location":"utilities/defining_rules/#Mooncake.@from_rrule-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.@from_rrule","text":"@from_rrule ctx sig [has_kwargs=false]\n\nConvenience functionality to assist in using ChainRulesCore.rrules to write rrule!!s.\n\nArguments\n\nctx: A Mooncake context type\nsig: the signature which you wish to assert should be a primitive in Mooncake.jl, and   use an existing ChainRulesCore.rrule to implement this functionality.\nhas_kwargs: a Bool state whether or not the function has keyword arguments. This   feature has the same limitations as ChainRulesCore.rrule – the derivative w.r.t. all   kwargs must be zero.\n\nExample Usage\n\nA Basic Example\n\njulia> using Mooncake: @from_rrule, DefaultCtx, rrule!!, zero_fcodual, TestUtils\n\njulia> import ChainRulesCore\n\njulia> foo(x::Real) = 5x;\n\njulia> function ChainRulesCore.rrule(::typeof(foo), x::Real)\n           foo_pb(Ω::Real) = ChainRulesCore.NoTangent(), 5Ω\n           return foo(x), foo_pb\n       end;\n\njulia> @from_rrule DefaultCtx Tuple{typeof(foo), Base.IEEEFloat}\n\njulia> rrule!!(zero_fcodual(foo), zero_fcodual(5.0))[2](1.0)\n(NoRData(), 5.0)\n\njulia> # Check that the rule works as intended.\n       TestUtils.test_rule(Xoshiro(123), foo, 5.0; is_primitive=true)\nTest Passed\n\nAn Example with Keyword Arguments\n\njulia> using Mooncake: @from_rrule, DefaultCtx, rrule!!, zero_fcodual, TestUtils\n\njulia> import ChainRulesCore\n\njulia> foo(x::Real; cond::Bool) = cond ? 5x : 4x;\n\njulia> function ChainRulesCore.rrule(::typeof(foo), x::Real; cond::Bool)\n           foo_pb(Ω::Real) = ChainRulesCore.NoTangent(), cond ? 5Ω : 4Ω\n           return foo(x; cond), foo_pb\n       end;\n\njulia> @from_rrule DefaultCtx Tuple{typeof(foo), Base.IEEEFloat} true\n\njulia> _, pb = rrule!!(\n           zero_fcodual(Core.kwcall),\n           zero_fcodual((cond=false, )),\n           zero_fcodual(foo),\n           zero_fcodual(5.0),\n       );\n\njulia> pb(3.0)\n(NoRData(), NoRData(), NoRData(), 12.0)\n\njulia> # Check that the rule works as intended.\n       TestUtils.test_rule(\n           Xoshiro(123), Core.kwcall, (cond=false, ), foo, 5.0; is_primitive=true\n       )\nTest Passed\n\nNotice that, in order to access the kwarg method we must call the method of Core.kwcall, as Mooncake's rrule!! does not itself permit the use of kwargs.\n\nLimitations\n\nIt is your responsibility to ensure that\n\ncalls with signature sig do not mutate their arguments,\nthe output of calls with signature sig does not alias any of the inputs.\n\nAs with all hand-written rules, you should definitely make use of TestUtils.test_rule to verify correctness on some test cases.\n\nArgument Type Constraints\n\nMany methods of ChainRuleCore.rrule are implemented with very loose type constraints. For example, it would not be surprising to see a method of rrule with the signature\n\nTuple{typeof(rrule), typeof(foo), Real, AbstractVector{<:Real}}\n\nThere are a variety of reasons for this way of doing things, and whether it is a good idea to write rules for such generic objects has been debated at length.\n\nSuffice it to say, you should not write rules for this package which are so generically typed. Rather, you should create rules for the subset of types for which you believe that the ChainRulesCore.rrule will work correctly, and leave this package to derive rules for the rest. For example, it is quite common to be confident that a given rule will work correctly for any Base.IEEEFloat argument, i.e. Union{Float16, Float32, Float64}, but it is usually not possible to know that the rule is correct for all possible subtypes of Real that someone might define.\n\nConversions Between Different Tangent Type Systems\n\nUnder the hood, this functionality relies on two functions: Mooncake.to_cr_tangent, and Mooncake.increment_and_get_rdata!. These two functions handle conversion to / from Mooncake tangent types and ChainRulesCore tangent types. This functionality is known to work well for simple types, but has not been tested to a great extent on complicated composite types. If @from_rrule does not work in your case because the required method of either of these functions does not exist, please open an issue.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/defining_rules/#Adding-Methods-To-rrule!!-And-build_primitive_rrule","page":"Defining Rules","title":"Adding Methods To rrule!! And build_primitive_rrule","text":"","category":"section"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"If the above strategies do not work for you, you should first implement a method of Mooncake.is_primitive for the signature of interest:","category":"page"},{"location":"utilities/defining_rules/#Mooncake.is_primitive-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.is_primitive","text":"is_primitive(::Type{Ctx}, sig) where {Ctx}\n\nReturns a Bool specifying whether the methods specified by sig are considered primitives in the context of contexts of type Ctx.\n\nis_primitive(DefaultCtx, Tuple{typeof(sin), Float64})\n\nwill return if calling sin(5.0) should be treated as primitive when the context is a DefaultCtx.\n\nObserve that this information means that whether or not something is a primitive in a particular context depends only on static information, not any run-time information that might live in a particular instance of Ctx.\n\n\n\n\n\n","category":"function"},{"location":"utilities/defining_rules/","page":"Defining Rules","title":"Defining Rules","text":"Then implement a method of one of the following:","category":"page"},{"location":"utilities/defining_rules/#Mooncake.rrule!!-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.rrule!!","text":"rrule!!(f::CoDual, x::CoDual...)\n\nPerforms the forwards-pass of AD. The tangent field of f and each x should contain the forwards tangent data (fdata) associated to each corresponding primal field.\n\nReturns a 2-tuple. The first element, y, is a CoDual whose primal field is the value associated to running f.primal(map(x -> x.primal, x)...), and whose tangent field is its associated fdata. The second element contains the pullback, which runs the reverse-pass. It maps from the rdata associated to y to the rdata associated to f and each x.\n\nusing Mooncake: zero_fcodual, CoDual, NoFData, rrule!!\ny, pb!! = rrule!!(zero_fcodual(sin), CoDual(5.0, NoFData()))\npb!!(1.0)\n\n# output\n\n(NoRData(), 0.28366218546322625)\n\n\n\n\n\n","category":"function"},{"location":"utilities/defining_rules/#Mooncake.build_primitive_rrule-utilities-defining_rules","page":"Defining Rules","title":"Mooncake.build_primitive_rrule","text":"build_primitive_rrule(sig::Type{<:Tuple})\n\nConstruct an rrule for signature sig. For this function to be called in build_rrule, you must also ensure that is_primitive(context_type, sig) is true. The callable returned by this must obey the rrule interface, but there are no restrictions on the type of callable itself. For example, you might return a callable struct. By default, this function returns rrule!! so, most of the time, you should just implement a method of rrule!!.\n\nExtended Help\n\nThe purpose of this function is to permit computation at rule construction time, which can be re-used at runtime. For example, you might wish to derive some information from sig which you use at runtime (e.g. the fdata type of one of the arguments). While constant propagation will often optimise this kind of computation away, it will sometimes fail to do so in hard-to-predict circumstances. Consequently, if you need certain computations not to happen at runtime in order to guarantee good performance, you might wish to e.g. emit a callable struct with type parameters which are the result of this computation. In this context, the motivation for using this function is the same as that of using staged programming (e.g. via @generated functions) more generally.\n\n\n\n\n\n","category":"function"},{"location":"#Mooncake.jl","page":"Mooncake.jl","title":"Mooncake.jl","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Documentation for Mooncake.jl is on its way!","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"details: Documentation Updates\nNote (03/10/2024): Various bits of utility functionality are now carefully documented. This includes how to change the code which Mooncake sees, declare that the derivative of a function is zero, make use of existing ChainRules.rrules to quicky create new rules in Mooncake, and more.Note (02/07/2024): The first round of documentation has arrived. This is largely targetted at those who are interested in contributing to Mooncake.jl – you can find this work in the \"Understanding Mooncake.jl\" section of the docs. There is more to to do, but it should be sufficient to understand how AD works in principle, and the core abstractions underlying Mooncake.jl.Note (29/05/2024): I (Will) am currently actively working on the documentation. It will be merged in chunks over the next month or so as good first drafts of sections are completed. Please don't be alarmed that not all of it is here!","category":"page"},{"location":"#Getting-Started","page":"Mooncake.jl","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Check that you're running a version of Julia that Mooncake.jl supports. See the SUPPORT_POLICY.md for more info.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"There are several ways to interact with Mooncake.jl. The way that we recommend people to interact with Mooncake.jl is via  DifferentiationInterface.jl. For example, use it as follows to compute the gradient of a function mapping a Vector{Float64} to Float64.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"using DifferentiationInterface\nimport Mooncake\n\nf(x) = sum(cos, x)\nbackend = AutoMooncake(; config=nothing)\nx = ones(1_000)\nprep = prepare_gradient(f, backend, x)\ngradient(f, prep, backend, x)","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"You should expect that prepare_gradient takes a little bit of time to run, but that gradient is fast.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"We are committed to ensuring support for DifferentiationInterface, which is why we recommend using that. If you are interested in interacting in a more direct fashion with Mooncake.jl, you should consider Mooncake.value_and_gradient!!. See its docstring for more info.","category":"page"},{"location":"#Project-Goals","page":"Mooncake.jl","title":"Project Goals","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Below the four central objectives of this project are outlined, and the approaches that we take to achieve them.","category":"page"},{"location":"#Coverage-of-more-of-the-Language","page":"Mooncake.jl","title":"Coverage of more of the Language","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"The need for first-class support for mutation has been well understood in the Julia AD community for a number of years now. Its primary benefit is the ability to differentiate through the truly vast quantity of mutating code on which users depend in Base / Core, the standard libraries, and packages in the general registry – empowering users to AD through code which they write in a mutating way is often of secondary importance. Thus you should equate rrule!!'s support for mutation with good support for existing code. Conversely, you should equate Zygote.jl's / ReverseDiff.jl's patchy support for mutation with patchy support for existing code.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"rrule!!s impose no constraints on the types which can be operated on, as with ChainRules's rrule and Zygote's _pullback. Consequently, there is in principle nothing to prevent Mooncake.jl from operating on any type, for example, structured arrays, GPU arrays, and complicated structs / mutable structs.","category":"page"},{"location":"#Correctness-and-Testing","page":"Mooncake.jl","title":"Correctness and Testing","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Mutation support enables writing rrule!!s at a low-level (Core.InstrincFunctions, built-in functions, ccalls to e.g. BLAS and LAPACK and the bits of Base Julia which are implemented in C). The simplicity of this low-level functionality makes implementing correct rrule!!s for it a simple task. In conjunction with being strict about the types used internally to represent (co)tangents, we have found this leads to rrule!!s composing very well, and AD being correct in practice as a consequence.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Furthermore, the interfaces for rrule!! and the (co)tangent type system have been designed to make a reliable test_rule function possible to create. All of our testing is implemented via this (or via another function which calls this) which makes adding test-cases trivial, and has meant that we have produced a lot of test cases.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"This contrasts with Zygote.jl / ChainRules.jl, where the permissive (co)tangent type system complicates both composition of rrules and testing.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Additionally, our approach to AD naturally handles control flow which differs between multiple calls to the same function. This contrasts with e.g. ReverseDiff.jl's compiled tape, which can give silent numerical errors if control flow ought to differ between gradient evaluations at different arguments.","category":"page"},{"location":"#Performance","page":"Mooncake.jl","title":"Performance","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Hand-written rrule!!s have excellent performance, provided that they have been written well (most of the hand-written rules in Mooncake.jl have excellent performance, but some require optimisation. Doing this just requires investing some time). Consequently, whether or not the overall AD system has good performance is largely a question of how much overhead is associated to the mechanism by which hand-written rrules!!s are algorithmically composed.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"At present (03/2024), we do this in a reasonably performant way (but better than the previous way!) See Project Status below for more info.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Additionally, the strategy of immediately incrementing (co)tangents resolves long-standing performance issues associated with indexing arrays.","category":"page"},{"location":"#Written-entirely-in-Julia","page":"Mooncake.jl","title":"Written entirely in Julia","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Mooncake.jl is written entirely in Julia. This sits in contrast to Enzyme.jl, which targets LLVM and is primarily written in C++. These two approaches entail different tradeoffs.","category":"page"},{"location":"#Project-Name","page":"Mooncake.jl","title":"Project Name","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Before an initial release, this package was called Taped.jl, but that name ceased to be helpful when we stopped using a classic \"Wengert list\"-style type to implement AD. For about 48 hours is was called Phi.jl, but the community guidelines state that the name of packages in the general registry should generally be at least 5 characters in length.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"We then chose Tapir.jl, and didn't initially feel that other work of the same name presented a serious name clash, as it isn't AD-specific or a Julia project. As it turns out, there has been significant work attempting to integrate the ideas from this work into the Julia compiler, so the clash is something of a problem.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"On 18/09/2024 this package was renamed from Tapir.jl to Mooncake.jl. The last version while the package was called Tapir.jl was 0.2.51. Upon renaming, the version was bumped to 0.3.0. We finally settled on Mooncake.jl. Hopefully this name will stick.","category":"page"},{"location":"#Project-Status","page":"Mooncake.jl","title":"Project Status","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"The plan is to proceed in three phases:","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"design, correctness and testing\nperformance optimisation\nmaintenance","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"You should take this with a pinch of salt, as it seems highly likely that we will have to revisit some design choices when optimising performance – we do not, however, anticipate requiring major re-writes to the design as part of performance optimisation. We aim to reach the maintenance phase of the project before 01/06/2024.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"details: Updates\nUpdate: (07/02/2025) We're largely in phase 3 now. We're largely working on documentation, and resolving existing issues. There are several ways that we could improve the performance of Mooncake.jl on e.g. low-level loops, but our feeling is that the performance is generally good enough to mean that it's more important to ensure that Mooncake is very stable.Update: (30/04/2024) Phase 2 continues! We are now finding that Mooncake.jl comfortably outperforms compiled ReverseDiff.jl on type-stable code in all of the situations we have tested. Optimising to get similar performance to Enzyme.jl is an on-going process.Update: (22/03/2024) Phase 2 is now further along. Mooncake.jl now uses something which could reasonably be described as a source-to-source system to perform AD. At present the performance of this system is not as good as that of Enzyme, but often beats compiled ReverseDiff, and comfortably beats Zygote in any situations involving dynamic control flow. The present focus is on dealing with some remaining performance limitations that should make Mooncake.jl's performance much closer to that of Enzyme, and consistently beat ReverseDiff on a range of benchmarks. Fortunately, dealing with these performance limitations necessitates simplifying the internals substantially.Update: (16/01/2024) Phase 2 is now well underway. We now make use of a much faster approach to interpreting / executing Julia code, which yields performance that is comparable with ReverseDiff (when things go well). The current focus is on ironing out performance issues, and simplifying the implementation.Update: (06/11/2023) We are mostly through the first phase. Correctness testing is proceeding well, and we are ironing out known issues. Notably, our broad experience at present is that as we continue to increase the amount of Julia code on which the package is tested, things fail for known, predictable, straightforwardly-fixable reasons (largely missing rrules for ccalls), rather than unanticipated problems. Please note that, since we have yet to enter phase 2 of the project, we have spent no time whatsoever optimising for performance. We strongly believe that there is nothing in principle preventing us from achieving excellent performance. However, currently, you should expect to experience amazingly poor performance.","category":"page"},{"location":"#What-things-should-work-well","page":"Mooncake.jl","title":"What things should work well","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Noteworthy things which should work and be performant include:","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"code containing control flow\nvalue-dependent control flow\nmutation of arrays and mutable structs","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"These are noteworthy in the sense that they are different from ReverseDiff / Zygote. Enzyme is also able to do these things.","category":"page"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"Please be aware that by \"performant\" we mean similar or better performance than ReverseDiff with a compiled tape, but not as good performance as Enzyme.","category":"page"},{"location":"#What-won't-work","page":"Mooncake.jl","title":"What won't work","text":"","category":"section"},{"location":"","page":"Mooncake.jl","title":"Mooncake.jl","text":"See known limitations. ","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are two ways to compute gradients with Mooncake.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"through the standardized DifferentiationInterface.jl API\nthrough the native Mooncake.jl API","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We recommend the former to start with, especially if you want to experiment with other automatic differentiation packages.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import DifferentiationInterface as DI\nimport Mooncake","category":"page"},{"location":"tutorial/#DifferentiationInterface.jl-API","page":"Tutorial","title":"DifferentiationInterface.jl API","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DifferentiationInterface.jl (or DI for short) provides a common entry point for every automatic differentiation package in Julia. To specify that you want to use Mooncake.jl, just create the right \"backend\" object (with an optional Mooncake.Config):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backend = DI.AutoMooncake(; config=nothing)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This object is actually defined by a third package called ADTypes.jl, but re-exported by DI.","category":"page"},{"location":"tutorial/#Single-argument","page":"Tutorial","title":"Single argument","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose you want to differentiate the following function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = sum(abs2, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"on the following input","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x = float.(1:3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The naive way is to simply call DI.gradient:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DI.gradient(f, backend, x)  # slow, do not do this","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This returns the correct gradient, but it is very slow because it includes the time taken by Mooncake.jl to compute a differentiation rule for f (see Mooncake.jl's Rule System). If you anticipate you will need more than one gradient, it is better to call DI.prepare_gradient on a typical (e.g. random) input first:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"typical_x = rand(3)\nprep = DI.prepare_gradient(f, backend, typical_x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The typical input should have the same size and type as the actual inputs we will provide later on. As for the contents of the preparation result, they do not matter. What matters is that it captures everything you need for DI.gradient to be fast:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DI.gradient(f, prep, backend, x)  # fast","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For optimal speed, you can provide storage space for the gradient and call DI.gradient! instead:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grad = similar(x)\nDI.gradient!(f, grad, prep, backend, x)  # very fast","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you also need the value of the function, check out DI.value_and_gradient or DI.value_and_gradient!:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DI.value_and_gradient(f, prep, backend, x)","category":"page"},{"location":"tutorial/#Multiple-arguments","page":"Tutorial","title":"Multiple arguments","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"What should you do if your function takes more than one input argument? Well, DI can still handle it, assuming that you only want the derivative with respect to one of them (the first one, by convention). For instance, consider the function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"g(x, a, b) = a * f(x) + b","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can easily compute the gradient with respect to x, while keeping a and b fixed. To do that, just wrap these two arguments inside DI.Constant, like so:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"typical_a, typical_b = 1.0, 1.0\nprep = DI.prepare_gradient(g, backend, typical_x, DI.Constant(typical_a), DI.Constant(typical_b))\n\na, b = 42.0, 3.14\nDI.value_and_gradient(g, prep, backend, x, DI.Constant(a), DI.Constant(b))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that this works even when you change the value of a or b (those are not baked into the preparation result).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If one of your additional arguments behaves like a scratch space in memory (instead of a meaningful constant), you can use DI.Cache instead.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now what if you care about the derivatives with respect to every argument? You can always go back to the single-argument case by putting everything inside a tuple:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"g_tup(xab) = xab[2] * f(xab[1]) + xab[3]\nprep = DI.prepare_gradient(g_tup, backend, (typical_x, typical_a, typical_b))\nDI.value_and_gradient(g_tup, prep, backend, (x, a, b))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use the native API of Mooncake.jl, discussed below.","category":"page"},{"location":"tutorial/#Beyond-gradients","page":"Tutorial","title":"Beyond gradients","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Going through DI allows you to compute other kinds of derivatives, like (reverse-mode) Jacobian matrices. The syntax is very similar:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"h(x) = cos.(x) .* sin.(reverse(x))\nprep = DI.prepare_jacobian(h, backend, x)\nDI.jacobian(h, prep, backend, x)","category":"page"},{"location":"tutorial/#Mooncake.jl-API","page":"Tutorial","title":"Mooncake.jl API","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nWork in progress.","category":"page"}]
}
